// vim:fileencoding=utf-8
(function(external_namespace) {
"use strict;"
var rs_version = "0.7.13";
var rs_commit_sha = "97d75a9b6079624dfbc04d153206b2df43514026";

// Embedded modules {{{
var data = {"compiler.js":"(function(){\n    \"use strict\";\n    var ρσ_iterator_symbol = (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") ? Symbol.iterator : \"iterator-Symbol-5d0927e5554349048cf0e3762a228256\";\n    var ρσ_kwargs_symbol = (typeof Symbol === \"function\") ? Symbol(\"kwargs-object\") : \"kwargs-object-Symbol-5d0927e5554349048cf0e3762a228256\";\n    var ρσ_cond_temp, ρσ_expr_temp, ρσ_last_exception;\n    var ρσ_object_counter = 0;\nvar ρσ_len;\nfunction ρσ_bool(val) {\n    return !!val;\n};\nif (!ρσ_bool.__argnames__) Object.defineProperties(ρσ_bool, {\n    __argnames__ : {value: [\"val\"]}\n});\n\nfunction ρσ_print() {\n    var parts;\n    if (typeof console === \"object\") {\n        parts = [];\n        for (var i = 0; i < arguments.length; i++) {\n            parts.push(ρσ_str(arguments[(typeof i === \"number\" && i < 0) ? arguments.length + i : i]));\n        }\n        console.log(parts.join(\" \"));\n    }\n};\n\nfunction ρσ_int(val, base) {\n    var ans;\n    ans = parseInt(val, base || 10);\n    if (isNaN(ans)) {\n        throw new ValueError(\"Invalid literal for int with base \" + (base || 10) + \": \" + val);\n    }\n    return ans;\n};\nif (!ρσ_int.__argnames__) Object.defineProperties(ρσ_int, {\n    __argnames__ : {value: [\"val\", \"base\"]}\n});\n\nfunction ρσ_float() {\n    var ans;\n    ans = parseFloat.apply(null, arguments);\n    if (isNaN(ans)) {\n        throw new ValueError(\"Could not convert string to float: \" + arguments[0]);\n    }\n    return ans;\n};\n\nfunction ρσ_arraylike_creator() {\n    var names;\n    names = \"Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array\".split(\" \");\n    if (typeof HTMLCollection === \"function\") {\n        names = names.concat(\"HTMLCollection NodeList NamedNodeMap\".split(\" \"));\n    }\n    return (function() {\n        var ρσ_anonfunc = function (x) {\n            if (Array.isArray(x) || typeof x === \"string\" || names.indexOf(Object.prototype.toString.call(x).slice(8, -1)) > -1) {\n                return true;\n            }\n            return false;\n        };\n        if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n            __argnames__ : {value: [\"x\"]}\n        });\n        return ρσ_anonfunc;\n    })();\n};\n\nfunction options_object(f) {\n    return function () {\n        if (typeof arguments[arguments.length - 1] === \"object\") {\n            arguments[ρσ_bound_index(arguments.length - 1, arguments)][ρσ_kwargs_symbol] = true;\n        }\n        return f.apply(this, arguments);\n    };\n};\nif (!options_object.__argnames__) Object.defineProperties(options_object, {\n    __argnames__ : {value: [\"f\"]}\n});\n\nfunction ρσ_id(x) {\n    return x.ρσ_object_id;\n};\nif (!ρσ_id.__argnames__) Object.defineProperties(ρσ_id, {\n    __argnames__ : {value: [\"x\"]}\n});\n\nfunction ρσ_dir(item) {\n    var arr;\n    arr = ρσ_list_decorate([]);\n    for (var i in item) {\n        arr.push(i);\n    }\n    return arr;\n};\nif (!ρσ_dir.__argnames__) Object.defineProperties(ρσ_dir, {\n    __argnames__ : {value: [\"item\"]}\n});\n\nfunction ρσ_ord(x) {\n    var ans, second;\n    ans = x.charCodeAt(0);\n    if (55296 <= ans && ans <= 56319) {\n        second = x.charCodeAt(1);\n        if (56320 <= second && second <= 57343) {\n            return (ans - 55296) * 1024 + second - 56320 + 65536;\n        }\n        throw new TypeError(\"string is missing the low surrogate char\");\n    }\n    return ans;\n};\nif (!ρσ_ord.__argnames__) Object.defineProperties(ρσ_ord, {\n    __argnames__ : {value: [\"x\"]}\n});\n\nfunction ρσ_chr(code) {\n    if (code <= 65535) {\n        return String.fromCharCode(code);\n    }\n    code -= 65536;\n    return String.fromCharCode(55296 + (code >> 10), 56320 + (code & 1023));\n};\nif (!ρσ_chr.__argnames__) Object.defineProperties(ρσ_chr, {\n    __argnames__ : {value: [\"code\"]}\n});\n\nfunction ρσ_callable(x) {\n    return typeof x === \"function\";\n};\nif (!ρσ_callable.__argnames__) Object.defineProperties(ρσ_callable, {\n    __argnames__ : {value: [\"x\"]}\n});\n\nfunction ρσ_bin(x) {\n    var ans;\n    if (typeof x !== \"number\" || x % 1 !== 0) {\n        throw new TypeError(\"integer required\");\n    }\n    ans = x.toString(2);\n    if (ans[0] === \"-\") {\n        ans = \"-\" + \"0b\" + ans.slice(1);\n    } else {\n        ans = \"0b\" + ans;\n    }\n    return ans;\n};\nif (!ρσ_bin.__argnames__) Object.defineProperties(ρσ_bin, {\n    __argnames__ : {value: [\"x\"]}\n});\n\nfunction ρσ_hex(x) {\n    var ans;\n    if (typeof x !== \"number\" || x % 1 !== 0) {\n        throw new TypeError(\"integer required\");\n    }\n    ans = x.toString(16);\n    if (ans[0] === \"-\") {\n        ans = \"-\" + \"0x\" + ans.slice(1);\n    } else {\n        ans = \"0x\" + ans;\n    }\n    return ans;\n};\nif (!ρσ_hex.__argnames__) Object.defineProperties(ρσ_hex, {\n    __argnames__ : {value: [\"x\"]}\n});\n\nfunction ρσ_enumerate(iterable) {\n    var ans, iterator;\n    ans = {\"_i\":-1};\n    ans[ρσ_iterator_symbol] = function () {\n        return this;\n    };\n    if (ρσ_arraylike(iterable)) {\n        ans[\"next\"] = function () {\n            this._i += 1;\n            if (this._i < iterable.length) {\n                return {'done':false, 'value':[this._i, iterable[this._i]]};\n            }\n            return {'done':true};\n        };\n        return ans;\n    }\n    if (typeof iterable[ρσ_iterator_symbol] === \"function\") {\n        iterator = (typeof Map === \"function\" && iterable instanceof Map) ? iterable.keys() : iterable[ρσ_iterator_symbol]();\n        ans[\"_iterator\"] = iterator;\n        ans[\"next\"] = function () {\n            var r;\n            r = this._iterator.next();\n            if (r.done) {\n                return {'done':true};\n            }\n            this._i += 1;\n            return {'done':false, 'value':[this._i, r.value]};\n        };\n        return ans;\n    }\n    return ρσ_enumerate(Object.keys(iterable));\n};\nif (!ρσ_enumerate.__argnames__) Object.defineProperties(ρσ_enumerate, {\n    __argnames__ : {value: [\"iterable\"]}\n});\n\nfunction ρσ_reversed(iterable) {\n    var ans;\n    if (ρσ_arraylike(iterable)) {\n        ans = {\"_i\": iterable.length};\n        ans[\"next\"] = function () {\n            this._i -= 1;\n            if (this._i > -1) {\n                return {'done':false, 'value':iterable[this._i]};\n            }\n            return {'done':true};\n        };\n        ans[ρσ_iterator_symbol] = function () {\n            return this;\n        };\n        return ans;\n    }\n    throw new TypeError(\"reversed() can only be called on arrays or strings\");\n};\nif (!ρσ_reversed.__argnames__) Object.defineProperties(ρσ_reversed, {\n    __argnames__ : {value: [\"iterable\"]}\n});\n\nfunction ρσ_iter(iterable) {\n    var ans;\n    if (typeof iterable[ρσ_iterator_symbol] === \"function\") {\n        return (typeof Map === \"function\" && iterable instanceof Map) ? iterable.keys() : iterable[ρσ_iterator_symbol]();\n    }\n    if (ρσ_arraylike(iterable)) {\n        ans = {\"_i\":-1};\n        ans[ρσ_iterator_symbol] = function () {\n            return this;\n        };\n        ans[\"next\"] = function () {\n            this._i += 1;\n            if (this._i < iterable.length) {\n                return {'done':false, 'value':iterable[this._i]};\n            }\n            return {'done':true};\n        };\n        return ans;\n    }\n    return ρσ_iter(Object.keys(iterable));\n};\nif (!ρσ_iter.__argnames__) Object.defineProperties(ρσ_iter, {\n    __argnames__ : {value: [\"iterable\"]}\n});\n\nfunction ρσ_range_next(step, length) {\n    var ρσ_unpack;\n    this._i += step;\n    this._idx += 1;\n    if (this._idx >= length) {\n        ρσ_unpack = [this.__i, -1];\n        this._i = ρσ_unpack[0];\n        this._idx = ρσ_unpack[1];\n        return {'done':true};\n    }\n    return {'done':false, 'value':this._i};\n};\nif (!ρσ_range_next.__argnames__) Object.defineProperties(ρσ_range_next, {\n    __argnames__ : {value: [\"step\", \"length\"]}\n});\n\nfunction ρσ_range(start, stop, step) {\n    var length, ans;\n    if (arguments.length <= 1) {\n        stop = start || 0;\n        start = 0;\n    }\n    step = arguments[2] || 1;\n    length = Math.max(Math.ceil((stop - start) / step), 0);\n    ans = {start:start, step:step, stop:stop};\n    ans[ρσ_iterator_symbol] = function () {\n        var it;\n        it = {\"_i\": start - step, \"_idx\": -1};\n        it.next = ρσ_range_next.bind(it, step, length);\n        it[ρσ_iterator_symbol] = function () {\n            return this;\n        };\n        return it;\n    };\n    ans.count = (function() {\n        var ρσ_anonfunc = function (val) {\n            if (!this._cached) {\n                this._cached = list(this);\n            }\n            return this._cached.count(val);\n        };\n        if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n            __argnames__ : {value: [\"val\"]}\n        });\n        return ρσ_anonfunc;\n    })();\n    ans.index = (function() {\n        var ρσ_anonfunc = function (val) {\n            if (!this._cached) {\n                this._cached = list(this);\n            }\n            return this._cached.index(val);\n        };\n        if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n            __argnames__ : {value: [\"val\"]}\n        });\n        return ρσ_anonfunc;\n    })();\n    if (typeof Proxy === \"function\") {\n        ans = new Proxy(ans, (function(){\n            var ρσ_d = {};\n            ρσ_d[\"get\"] = (function() {\n                var ρσ_anonfunc = function (obj, prop) {\n                    var iprop;\n                    if (typeof prop === \"string\") {\n                        iprop = parseInt(prop);\n                        if (!isNaN(iprop)) {\n                            prop = iprop;\n                        }\n                    }\n                    if (typeof prop === \"number\") {\n                        if (!obj._cached) {\n                            obj._cached = list(obj);\n                        }\n                        return (ρσ_expr_temp = obj._cached)[(typeof prop === \"number\" && prop < 0) ? ρσ_expr_temp.length + prop : prop];\n                    }\n                    return obj[(typeof prop === \"number\" && prop < 0) ? obj.length + prop : prop];\n                };\n                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                    __argnames__ : {value: [\"obj\", \"prop\"]}\n                });\n                return ρσ_anonfunc;\n            })();\n            return ρσ_d;\n        }).call(this));\n    }\n    return ans;\n};\nif (!ρσ_range.__argnames__) Object.defineProperties(ρσ_range, {\n    __argnames__ : {value: [\"start\", \"stop\", \"step\"]}\n});\n\nfunction ρσ_getattr(obj, name, defval) {\n    var ret;\n    try {\n        ret = obj[(typeof name === \"number\" && name < 0) ? obj.length + name : name];\n    } catch (ρσ_Exception) {\n        ρσ_last_exception = ρσ_Exception;\n        if (ρσ_Exception instanceof TypeError) {\n            if (defval === undefined) {\n                throw new AttributeError(\"The attribute \" + name + \" is not present\");\n            }\n            return defval;\n        } else {\n            throw ρσ_Exception;\n        }\n    }\n    if (ret === undefined && !(name in obj)) {\n        if (defval === undefined) {\n            throw new AttributeError(\"The attribute \" + name + \" is not present\");\n        }\n        ret = defval;\n    }\n    return ret;\n};\nif (!ρσ_getattr.__argnames__) Object.defineProperties(ρσ_getattr, {\n    __argnames__ : {value: [\"obj\", \"name\", \"defval\"]}\n});\n\nfunction ρσ_setattr(obj, name, value) {\n    obj[(typeof name === \"number\" && name < 0) ? obj.length + name : name] = value;\n};\nif (!ρσ_setattr.__argnames__) Object.defineProperties(ρσ_setattr, {\n    __argnames__ : {value: [\"obj\", \"name\", \"value\"]}\n});\n\nfunction ρσ_hasattr(obj, name) {\n    return name in obj;\n};\nif (!ρσ_hasattr.__argnames__) Object.defineProperties(ρσ_hasattr, {\n    __argnames__ : {value: [\"obj\", \"name\"]}\n});\n\nρσ_len = function () {\n    function len(obj) {\n        if (ρσ_arraylike(obj)) {\n            return obj.length;\n        }\n        if (typeof obj.__len__ === \"function\") {\n            return obj.__len__();\n        }\n        if (obj instanceof Set || obj instanceof Map) {\n            return obj.size;\n        }\n        return Object.keys(obj).length;\n    };\n    if (!len.__argnames__) Object.defineProperties(len, {\n        __argnames__ : {value: [\"obj\"]}\n    });\n\n    function len5(obj) {\n        if (ρσ_arraylike(obj)) {\n            return obj.length;\n        }\n        if (typeof obj.__len__ === \"function\") {\n            return obj.__len__();\n        }\n        return Object.keys(obj).length;\n    };\n    if (!len5.__argnames__) Object.defineProperties(len5, {\n        __argnames__ : {value: [\"obj\"]}\n    });\n\n    return (typeof Set === \"function\" && typeof Map === \"function\") ? len : len5;\n}();\nfunction ρσ_get_module(name) {\n    return ρσ_modules[(typeof name === \"number\" && name < 0) ? ρσ_modules.length + name : name];\n};\nif (!ρσ_get_module.__argnames__) Object.defineProperties(ρσ_get_module, {\n    __argnames__ : {value: [\"name\"]}\n});\n\nfunction ρσ_pow(x, y, z) {\n    var ans;\n    ans = Math.pow(x, y);\n    if (z !== undefined) {\n        ans %= z;\n    }\n    return ans;\n};\nif (!ρσ_pow.__argnames__) Object.defineProperties(ρσ_pow, {\n    __argnames__ : {value: [\"x\", \"y\", \"z\"]}\n});\n\nfunction ρσ_type(x) {\n    return x.constructor;\n};\nif (!ρσ_type.__argnames__) Object.defineProperties(ρσ_type, {\n    __argnames__ : {value: [\"x\"]}\n});\n\nfunction ρσ_divmod(x, y) {\n    var d;\n    if (y === 0) {\n        throw new ZeroDivisionError(\"integer division or modulo by zero\");\n    }\n    d = Math.floor(x / y);\n    return [d, x - d * y];\n};\nif (!ρσ_divmod.__argnames__) Object.defineProperties(ρσ_divmod, {\n    __argnames__ : {value: [\"x\", \"y\"]}\n});\n\nfunction ρσ_max() {\n    var kwargs = arguments[arguments.length-1];\n    if (kwargs === null || typeof kwargs !== \"object\" || kwargs [ρσ_kwargs_symbol] !== true) kwargs = {};\n    var args = Array.prototype.slice.call(arguments, 0);\n    if (kwargs !== null && typeof kwargs === \"object\" && kwargs [ρσ_kwargs_symbol] === true) args.pop();\n    var args, x;\n    if (args.length === 0) {\n        if (kwargs.defval !== undefined) {\n            return kwargs.defval;\n        }\n        throw new TypeError(\"expected at least one argument\");\n    }\n    if (args.length === 1) {\n        args = args[0];\n    }\n    if (kwargs.key) {\n        args = (function() {\n            var ρσ_Iter = ρσ_Iterable(args), ρσ_Result = [], x;\n            for (var ρσ_Index = 0; ρσ_Index < ρσ_Iter.length; ρσ_Index++) {\n                x = ρσ_Iter[ρσ_Index];\n                ρσ_Result.push(kwargs.key(x));\n            }\n            ρσ_Result = ρσ_list_constructor(ρσ_Result);\n            return ρσ_Result;\n        })();\n    }\n    if (!Array.isArray(args)) {\n        args = list(args);\n    }\n    if (args.length) {\n        return this.apply(null, args);\n    }\n    if (kwargs.defval !== undefined) {\n        return kwargs.defval;\n    }\n    throw new TypeError(\"expected at least one argument\");\n};\nif (!ρσ_max.__handles_kwarg_interpolation__) Object.defineProperties(ρσ_max, {\n    __handles_kwarg_interpolation__ : {value: true}\n});\n\nvar abs = Math.abs, max = ρσ_max.bind(Math.max), min = ρσ_max.bind(Math.min), bool = ρσ_bool, type = ρσ_type;\nvar float = ρσ_float, int = ρσ_int, arraylike = ρσ_arraylike_creator(), ρσ_arraylike = arraylike;\nvar print = ρσ_print, id = ρσ_id, get_module = ρσ_get_module, pow = ρσ_pow, divmod = ρσ_divmod;\nvar dir = ρσ_dir, ord = ρσ_ord, chr = ρσ_chr, bin = ρσ_bin, hex = ρσ_hex, callable = ρσ_callable;\nvar enumerate = ρσ_enumerate, iter = ρσ_iter, reversed = ρσ_reversed, len = ρσ_len;\nvar range = ρσ_range, getattr = ρσ_getattr, setattr = ρσ_setattr, hasattr = ρσ_hasattr;function ρσ_equals(a, b) {\n    var ρσ_unpack, akeys, bkeys, key;\n    if (a === b) {\n        return true;\n    }\n    if (a && typeof a.__eq__ === \"function\") {\n        return a.__eq__(b);\n    }\n    if (b && typeof b.__eq__ === \"function\") {\n        return b.__eq__(a);\n    }\n    if (ρσ_arraylike(a) && ρσ_arraylike(b)) {\n        if ((a.length !== b.length && (typeof a.length !== \"object\" || ρσ_not_equals(a.length, b.length)))) {\n            return false;\n        }\n        for (var i=0; i < a.length; i++) {\n            if (!((a[(typeof i === \"number\" && i < 0) ? a.length + i : i] === b[(typeof i === \"number\" && i < 0) ? b.length + i : i] || typeof a[(typeof i === \"number\" && i < 0) ? a.length + i : i] === \"object\" && ρσ_equals(a[(typeof i === \"number\" && i < 0) ? a.length + i : i], b[(typeof i === \"number\" && i < 0) ? b.length + i : i])))) {\n                return false;\n            }\n        }\n        return true;\n    }\n    if (typeof a === \"object\" && typeof b === \"object\" && a !== null && b !== null && (a.constructor === Object && b.constructor === Object || Object.getPrototypeOf(a) === null && Object.getPrototypeOf(b) === null)) {\n        ρσ_unpack = [Object.keys(a), Object.keys(b)];\n        akeys = ρσ_unpack[0];\n        bkeys = ρσ_unpack[1];\n        if (akeys.length !== bkeys.length) {\n            return false;\n        }\n        for (var j=0; j < akeys.length; j++) {\n            key = akeys[(typeof j === \"number\" && j < 0) ? akeys.length + j : j];\n            if (!((a[(typeof key === \"number\" && key < 0) ? a.length + key : key] === b[(typeof key === \"number\" && key < 0) ? b.length + key : key] || typeof a[(typeof key === \"number\" && key < 0) ? a.length + key : key] === \"object\" && ρσ_equals(a[(typeof key === \"number\" && key < 0) ? a.length + key : key], b[(typeof key === \"number\" && key < 0) ? b.length + key : key])))) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n};\nif (!ρσ_equals.__argnames__) Object.defineProperties(ρσ_equals, {\n    __argnames__ : {value: [\"a\", \"b\"]}\n});\n\nfunction ρσ_not_equals(a, b) {\n    if (a === b) {\n        return false;\n    }\n    if (a && typeof a.__ne__ === \"function\") {\n        return a.__ne__(b);\n    }\n    if (b && typeof b.__ne__ === \"function\") {\n        return b.__ne__(a);\n    }\n    return !ρσ_equals(a, b);\n};\nif (!ρσ_not_equals.__argnames__) Object.defineProperties(ρσ_not_equals, {\n    __argnames__ : {value: [\"a\", \"b\"]}\n});\n\nvar equals = ρσ_equals;\nfunction ρσ_list_extend(iterable) {\n    var start, iterator, result;\n    if (Array.isArray(iterable) || typeof iterable === \"string\") {\n        start = this.length;\n        this.length += iterable.length;\n        for (var i = 0; i < iterable.length; i++) {\n            (ρσ_expr_temp = this)[ρσ_bound_index(start + i, ρσ_expr_temp)] = iterable[(typeof i === \"number\" && i < 0) ? iterable.length + i : i];\n        }\n    } else {\n        iterator = (typeof Map === \"function\" && iterable instanceof Map) ? iterable.keys() : iterable[ρσ_iterator_symbol]();\n        result = iterator.next();\n        while (!result.done) {\n            this.push(result.value);\n            result = iterator.next();\n        }\n    }\n};\nif (!ρσ_list_extend.__argnames__) Object.defineProperties(ρσ_list_extend, {\n    __argnames__ : {value: [\"iterable\"]}\n});\n\nfunction ρσ_list_index(val, start, stop) {\n    var idx;\n    start = start || 0;\n    if (start < 0) {\n        start = this.length + start;\n    }\n    if (start < 0) {\n        throw new ValueError(val + \" is not in list\");\n    }\n    if (stop === undefined) {\n        idx = this.indexOf(val, start);\n        if (idx === -1) {\n            throw new ValueError(val + \" is not in list\");\n        }\n        return idx;\n    }\n    if (stop < 0) {\n        stop = this.length + stop;\n    }\n    for (var i = start; i < stop; i++) {\n        if (((ρσ_expr_temp = this)[(typeof i === \"number\" && i < 0) ? ρσ_expr_temp.length + i : i] === val || typeof (ρσ_expr_temp = this)[(typeof i === \"number\" && i < 0) ? ρσ_expr_temp.length + i : i] === \"object\" && ρσ_equals((ρσ_expr_temp = this)[(typeof i === \"number\" && i < 0) ? ρσ_expr_temp.length + i : i], val))) {\n            return i;\n        }\n    }\n    throw new ValueError(val + \" is not in list\");\n};\nif (!ρσ_list_index.__argnames__) Object.defineProperties(ρσ_list_index, {\n    __argnames__ : {value: [\"val\", \"start\", \"stop\"]}\n});\n\nfunction ρσ_list_pop(index) {\n    var ans;\n    if (this.length === 0) {\n        throw new IndexError(\"list is empty\");\n    }\n    ans = this.splice(index, 1);\n    if (!ans.length) {\n        throw new IndexError(\"pop index out of range\");\n    }\n    return ans[0];\n};\nif (!ρσ_list_pop.__argnames__) Object.defineProperties(ρσ_list_pop, {\n    __argnames__ : {value: [\"index\"]}\n});\n\nfunction ρσ_list_remove(value) {\n    var idx;\n    idx = this.indexOf(value);\n    if (idx === -1) {\n        throw new ValueError(value + \" not in list\");\n    }\n    this.splice(idx, 1);\n};\nif (!ρσ_list_remove.__argnames__) Object.defineProperties(ρσ_list_remove, {\n    __argnames__ : {value: [\"value\"]}\n});\n\nfunction ρσ_list_to_string() {\n    return \"[\" + this.join(\", \") + \"]\";\n};\n\nfunction ρσ_list_insert(index, val) {\n    if (index < 0) {\n        index += this.length;\n    }\n    index = min(this.length, max(index, 0));\n    if (index === 0) {\n        this.unshift(val);\n        return;\n    }\n    for (var i = this.length; i > index; i--) {\n        (ρσ_expr_temp = this)[(typeof i === \"number\" && i < 0) ? ρσ_expr_temp.length + i : i] = (ρσ_expr_temp = this)[ρσ_bound_index(i - 1, ρσ_expr_temp)];\n    }\n    (ρσ_expr_temp = this)[(typeof index === \"number\" && index < 0) ? ρσ_expr_temp.length + index : index] = val;\n};\nif (!ρσ_list_insert.__argnames__) Object.defineProperties(ρσ_list_insert, {\n    __argnames__ : {value: [\"index\", \"val\"]}\n});\n\nfunction ρσ_list_copy() {\n    return ρσ_list_constructor(this);\n};\n\nfunction ρσ_list_clear() {\n    this.length = 0;\n};\n\nfunction ρσ_list_as_array() {\n    return Array.prototype.slice.call(this);\n};\n\nfunction ρσ_list_count(value) {\n    return this.reduce((function() {\n        var ρσ_anonfunc = function (n, val) {\n            return n + (val === value);\n        };\n        if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n            __argnames__ : {value: [\"n\", \"val\"]}\n        });\n        return ρσ_anonfunc;\n    })(), 0);\n};\nif (!ρσ_list_count.__argnames__) Object.defineProperties(ρσ_list_count, {\n    __argnames__ : {value: [\"value\"]}\n});\n\nfunction ρσ_list_sort_key(value) {\n    var t;\n    t = typeof value;\n    if (t === \"string\" || t === \"number\") {\n        return value;\n    }\n    return value.toString();\n};\nif (!ρσ_list_sort_key.__argnames__) Object.defineProperties(ρσ_list_sort_key, {\n    __argnames__ : {value: [\"value\"]}\n});\n\nfunction ρσ_list_sort_cmp(a, b, ap, bp) {\n    if (a < b) {\n        return -1;\n    }\n    if (a > b) {\n        return 1;\n    }\n    return ap - bp;\n};\nif (!ρσ_list_sort_cmp.__argnames__) Object.defineProperties(ρσ_list_sort_cmp, {\n    __argnames__ : {value: [\"a\", \"b\", \"ap\", \"bp\"]}\n});\n\nfunction ρσ_list_sort() {\n    var key = (arguments[0] === undefined || ( 0 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === \"object\" && arguments[arguments.length-1] [ρσ_kwargs_symbol] === true)) ? ρσ_list_sort.__defaults__.key : arguments[0];\n    var reverse = (arguments[1] === undefined || ( 1 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === \"object\" && arguments[arguments.length-1] [ρσ_kwargs_symbol] === true)) ? ρσ_list_sort.__defaults__.reverse : arguments[1];\n    var ρσ_kwargs_obj = arguments[arguments.length-1];\n    if (ρσ_kwargs_obj === null || typeof ρσ_kwargs_obj !== \"object\" || ρσ_kwargs_obj [ρσ_kwargs_symbol] !== true) ρσ_kwargs_obj = {};\n    if (Object.prototype.hasOwnProperty.call(ρσ_kwargs_obj, \"key\")){\n        key = ρσ_kwargs_obj.key;\n    }\n    if (Object.prototype.hasOwnProperty.call(ρσ_kwargs_obj, \"reverse\")){\n        reverse = ρσ_kwargs_obj.reverse;\n    }\n    var mult, keymap, posmap, k;\n    key = key || ρσ_list_sort_key;\n    mult = (reverse) ? -1 : 1;\n    keymap = dict();\n    posmap = dict();\n    for (var i=0; i < this.length; i++) {\n        k = (ρσ_expr_temp = this)[(typeof i === \"number\" && i < 0) ? ρσ_expr_temp.length + i : i];\n        keymap.set(k, key(k));\n        posmap.set(k, i);\n    }\n    this.sort((function() {\n        var ρσ_anonfunc = function (a, b) {\n            return mult * ρσ_list_sort_cmp(keymap.get(a), keymap.get(b), posmap.get(a), posmap.get(b));\n        };\n        if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n            __argnames__ : {value: [\"a\", \"b\"]}\n        });\n        return ρσ_anonfunc;\n    })());\n};\nif (!ρσ_list_sort.__defaults__) Object.defineProperties(ρσ_list_sort, {\n    __defaults__ : {value: {key:null, reverse:false}},\n    __handles_kwarg_interpolation__ : {value: true},\n    __argnames__ : {value: [\"key\", \"reverse\"]}\n});\n\nfunction ρσ_list_concat() {\n    var ans;\n    ans = Array.prototype.concat.apply(this, arguments);\n    ρσ_list_decorate(ans);\n    return ans;\n};\n\nfunction ρσ_list_slice() {\n    var ans;\n    ans = Array.prototype.slice.apply(this, arguments);\n    ρσ_list_decorate(ans);\n    return ans;\n};\n\nfunction ρσ_list_iterator(value) {\n    var self;\n    self = this;\n    return (function(){\n        var ρσ_d = {};\n        ρσ_d[\"_i\"] = -1;\n        ρσ_d[\"_list\"] = self;\n        ρσ_d[\"next\"] = function () {\n            this._i += 1;\n            if (this._i >= this._list.length) {\n                return (function(){\n                    var ρσ_d = {};\n                    ρσ_d[\"done\"] = true;\n                    return ρσ_d;\n                }).call(this);\n            }\n            return (function(){\n                var ρσ_d = {};\n                ρσ_d[\"done\"] = false;\n                ρσ_d[\"value\"] = (ρσ_expr_temp = this._list)[ρσ_bound_index(this._i, ρσ_expr_temp)];\n                return ρσ_d;\n            }).call(this);\n        };\n        return ρσ_d;\n    }).call(this);\n};\nif (!ρσ_list_iterator.__argnames__) Object.defineProperties(ρσ_list_iterator, {\n    __argnames__ : {value: [\"value\"]}\n});\n\nfunction ρσ_list_len() {\n    return this.length;\n};\n\nfunction ρσ_list_contains(val) {\n    for (var i = 0; i < this.length; i++) {\n        if (((ρσ_expr_temp = this)[(typeof i === \"number\" && i < 0) ? ρσ_expr_temp.length + i : i] === val || typeof (ρσ_expr_temp = this)[(typeof i === \"number\" && i < 0) ? ρσ_expr_temp.length + i : i] === \"object\" && ρσ_equals((ρσ_expr_temp = this)[(typeof i === \"number\" && i < 0) ? ρσ_expr_temp.length + i : i], val))) {\n            return true;\n        }\n    }\n    return false;\n};\nif (!ρσ_list_contains.__argnames__) Object.defineProperties(ρσ_list_contains, {\n    __argnames__ : {value: [\"val\"]}\n});\n\nfunction ρσ_list_eq(other) {\n    if (!ρσ_arraylike(other)) {\n        return false;\n    }\n    if ((this.length !== other.length && (typeof this.length !== \"object\" || ρσ_not_equals(this.length, other.length)))) {\n        return false;\n    }\n    for (var i = 0; i < this.length; i++) {\n        if (!(((ρσ_expr_temp = this)[(typeof i === \"number\" && i < 0) ? ρσ_expr_temp.length + i : i] === other[(typeof i === \"number\" && i < 0) ? other.length + i : i] || typeof (ρσ_expr_temp = this)[(typeof i === \"number\" && i < 0) ? ρσ_expr_temp.length + i : i] === \"object\" && ρσ_equals((ρσ_expr_temp = this)[(typeof i === \"number\" && i < 0) ? ρσ_expr_temp.length + i : i], other[(typeof i === \"number\" && i < 0) ? other.length + i : i])))) {\n            return false;\n        }\n    }\n    return true;\n};\nif (!ρσ_list_eq.__argnames__) Object.defineProperties(ρσ_list_eq, {\n    __argnames__ : {value: [\"other\"]}\n});\n\nfunction ρσ_list_decorate(ans) {\n    ans.append = Array.prototype.push;\n    ans.toString = ρσ_list_to_string;\n    ans.inspect = ρσ_list_to_string;\n    ans.extend = ρσ_list_extend;\n    ans.index = ρσ_list_index;\n    ans.pypop = ρσ_list_pop;\n    ans.remove = ρσ_list_remove;\n    ans.insert = ρσ_list_insert;\n    ans.copy = ρσ_list_copy;\n    ans.clear = ρσ_list_clear;\n    ans.count = ρσ_list_count;\n    ans.concat = ρσ_list_concat;\n    ans.pysort = ρσ_list_sort;\n    ans.slice = ρσ_list_slice;\n    ans.as_array = ρσ_list_as_array;\n    ans.__len__ = ρσ_list_len;\n    ans.__contains__ = ρσ_list_contains;\n    ans.__eq__ = ρσ_list_eq;\n    ans.constructor = ρσ_list_constructor;\n    if (typeof ans[ρσ_iterator_symbol] !== \"function\") {\n        ans[ρσ_iterator_symbol] = ρσ_list_iterator;\n    }\n    return ans;\n};\nif (!ρσ_list_decorate.__argnames__) Object.defineProperties(ρσ_list_decorate, {\n    __argnames__ : {value: [\"ans\"]}\n});\n\nfunction ρσ_list_constructor(iterable) {\n    var ans, iterator, result;\n    if (iterable === undefined) {\n        ans = [];\n    } else if (ρσ_arraylike(iterable)) {\n        ans = new Array(iterable.length);\n        for (var i = 0; i < iterable.length; i++) {\n            ans[(typeof i === \"number\" && i < 0) ? ans.length + i : i] = iterable[(typeof i === \"number\" && i < 0) ? iterable.length + i : i];\n        }\n    } else if (typeof iterable[ρσ_iterator_symbol] === \"function\") {\n        iterator = (typeof Map === \"function\" && iterable instanceof Map) ? iterable.keys() : iterable[ρσ_iterator_symbol]();\n        ans = ρσ_list_decorate([]);\n        result = iterator.next();\n        while (!result.done) {\n            ans.push(result.value);\n            result = iterator.next();\n        }\n    } else if (typeof iterable === \"number\") {\n        ans = new Array(iterable);\n    } else {\n        ans = Object.keys(iterable);\n    }\n    return ρσ_list_decorate(ans);\n};\nif (!ρσ_list_constructor.__argnames__) Object.defineProperties(ρσ_list_constructor, {\n    __argnames__ : {value: [\"iterable\"]}\n});\n\nρσ_list_constructor.__name__ = \"list\";\nvar list = ρσ_list_constructor, list_wrap = ρσ_list_decorate;\nfunction sorted() {\n    var iterable = ( 0 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === \"object\" && arguments[arguments.length-1] [ρσ_kwargs_symbol] === true) ? undefined : arguments[0];\n    var key = (arguments[1] === undefined || ( 1 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === \"object\" && arguments[arguments.length-1] [ρσ_kwargs_symbol] === true)) ? sorted.__defaults__.key : arguments[1];\n    var reverse = (arguments[2] === undefined || ( 2 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === \"object\" && arguments[arguments.length-1] [ρσ_kwargs_symbol] === true)) ? sorted.__defaults__.reverse : arguments[2];\n    var ρσ_kwargs_obj = arguments[arguments.length-1];\n    if (ρσ_kwargs_obj === null || typeof ρσ_kwargs_obj !== \"object\" || ρσ_kwargs_obj [ρσ_kwargs_symbol] !== true) ρσ_kwargs_obj = {};\n    if (Object.prototype.hasOwnProperty.call(ρσ_kwargs_obj, \"key\")){\n        key = ρσ_kwargs_obj.key;\n    }\n    if (Object.prototype.hasOwnProperty.call(ρσ_kwargs_obj, \"reverse\")){\n        reverse = ρσ_kwargs_obj.reverse;\n    }\n    var ans;\n    ans = ρσ_list_constructor(iterable);\n    ans.pysort(key, reverse);\n    return ans;\n};\nif (!sorted.__defaults__) Object.defineProperties(sorted, {\n    __defaults__ : {value: {key:null, reverse:false}},\n    __handles_kwarg_interpolation__ : {value: true},\n    __argnames__ : {value: [\"iterable\", \"key\", \"reverse\"]}\n});\n\nvar ρσ_global_object_id = 0, ρσ_set_implementation;\nfunction ρσ_set_keyfor(x) {\n    var t, ans;\n    t = typeof x;\n    if (t === \"string\" || t === \"number\" || t === \"boolean\") {\n        return \"_\" + t[0] + x;\n    }\n    if (x === null) {\n        return \"__!@#$0\";\n    }\n    ans = x.ρσ_hash_key_prop;\n    if (ans === undefined) {\n        ans = \"_!@#$\" + (++ρσ_global_object_id);\n        Object.defineProperty(x, \"ρσ_hash_key_prop\", (function(){\n            var ρσ_d = {};\n            ρσ_d[\"value\"] = ans;\n            return ρσ_d;\n        }).call(this));\n    }\n    return ans;\n};\nif (!ρσ_set_keyfor.__argnames__) Object.defineProperties(ρσ_set_keyfor, {\n    __argnames__ : {value: [\"x\"]}\n});\n\nfunction ρσ_set_polyfill() {\n    this._store = {};\n    this.size = 0;\n};\n\nρσ_set_polyfill.prototype.add = (function() {\n    var ρσ_anonfunc = function (x) {\n        var key;\n        key = ρσ_set_keyfor(x);\n        if (!Object.prototype.hasOwnProperty.call(this._store, key)) {\n            this.size += 1;\n            (ρσ_expr_temp = this._store)[(typeof key === \"number\" && key < 0) ? ρσ_expr_temp.length + key : key] = x;\n        }\n        return this;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"x\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_set_polyfill.prototype.clear = (function() {\n    var ρσ_anonfunc = function (x) {\n        this._store = {};\n        this.size = 0;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"x\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_set_polyfill.prototype.delete = (function() {\n    var ρσ_anonfunc = function (x) {\n        var key;\n        key = ρσ_set_keyfor(x);\n        if (Object.prototype.hasOwnProperty.call(this._store, key)) {\n            this.size -= 1;\n            delete this._store[key];\n            return true;\n        }\n        return false;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"x\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_set_polyfill.prototype.has = (function() {\n    var ρσ_anonfunc = function (x) {\n        return Object.prototype.hasOwnProperty.call(this._store, ρσ_set_keyfor(x));\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"x\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_set_polyfill.prototype.values = (function() {\n    var ρσ_anonfunc = function (x) {\n        var ans;\n        ans = {'_keys': Object.keys(this._store), '_i':-1, '_s':this._store};\n        ans[ρσ_iterator_symbol] = function () {\n            return this;\n        };\n        ans[\"next\"] = function () {\n            this._i += 1;\n            if (this._i >= this._keys.length) {\n                return {'done': true};\n            }\n            return {'done':false, 'value':this._s[this._keys[this._i]]};\n        };\n        return ans;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"x\"]}\n    });\n    return ρσ_anonfunc;\n})();\nif (typeof Set !== \"function\" || typeof Set.prototype.delete !== \"function\") {\n    ρσ_set_implementation = ρσ_set_polyfill;\n} else {\n    ρσ_set_implementation = Set;\n}\nfunction ρσ_set(iterable) {\n    var ans, s, iterator, result, keys;\n    if (this instanceof ρσ_set) {\n        this.jsset = new ρσ_set_implementation;\n        ans = this;\n        if (iterable === undefined) {\n            return ans;\n        }\n        s = ans.jsset;\n        if (ρσ_arraylike(iterable)) {\n            for (var i = 0; i < iterable.length; i++) {\n                s.add(iterable[(typeof i === \"number\" && i < 0) ? iterable.length + i : i]);\n            }\n        } else if (typeof iterable[ρσ_iterator_symbol] === \"function\") {\n            iterator = (typeof Map === \"function\" && iterable instanceof Map) ? iterable.keys() : iterable[ρσ_iterator_symbol]();\n            result = iterator.next();\n            while (!result.done) {\n                s.add(result.value);\n                result = iterator.next();\n            }\n        } else {\n            keys = Object.keys(iterable);\n            for (var j=0; j < keys.length; j++) {\n                s.add(keys[(typeof j === \"number\" && j < 0) ? keys.length + j : j]);\n            }\n        }\n        return ans;\n    } else {\n        return new ρσ_set(iterable);\n    }\n};\nif (!ρσ_set.__argnames__) Object.defineProperties(ρσ_set, {\n    __argnames__ : {value: [\"iterable\"]}\n});\n\nρσ_set.prototype.__name__ = \"set\";\nObject.defineProperties(ρσ_set.prototype, (function(){\n    var ρσ_d = {};\n    ρσ_d[\"length\"] = (function(){\n        var ρσ_d = {};\n        ρσ_d[\"get\"] = function () {\n            return this.jsset.size;\n        };\n        return ρσ_d;\n    }).call(this);\n    ρσ_d[\"size\"] = (function(){\n        var ρσ_d = {};\n        ρσ_d[\"get\"] = function () {\n            return this.jsset.size;\n        };\n        return ρσ_d;\n    }).call(this);\n    return ρσ_d;\n}).call(this));\nρσ_set.prototype.__len__ = function () {\n    return this.jsset.size;\n};\nρσ_set.prototype.has = ρσ_set.prototype.__contains__ = (function() {\n    var ρσ_anonfunc = function (x) {\n        return this.jsset.has(x);\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"x\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_set.prototype.add = (function() {\n    var ρσ_anonfunc = function (x) {\n        this.jsset.add(x);\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"x\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_set.prototype.clear = function () {\n    this.jsset.clear();\n};\nρσ_set.prototype.copy = function () {\n    return ρσ_set(this);\n};\nρσ_set.prototype.discard = (function() {\n    var ρσ_anonfunc = function (x) {\n        this.jsset.delete(x);\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"x\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_set.prototype[ρσ_iterator_symbol] = function () {\n    return this.jsset.values();\n};\nρσ_set.prototype.difference = function () {\n    var ans, s, iterator, r, x, has;\n    ans = new ρσ_set;\n    s = ans.jsset;\n    iterator = this.jsset.values();\n    r = iterator.next();\n    while (!r.done) {\n        x = r.value;\n        has = false;\n        for (var i = 0; i < arguments.length; i++) {\n            if (arguments[(typeof i === \"number\" && i < 0) ? arguments.length + i : i].has(x)) {\n                has = true;\n                break;\n            }\n        }\n        if (!has) {\n            s.add(x);\n        }\n        r = iterator.next();\n    }\n    return ans;\n};\nρσ_set.prototype.difference_update = function () {\n    var s, remove, iterator, r, x;\n    s = this.jsset;\n    remove = [];\n    iterator = s.values();\n    r = iterator.next();\n    while (!r.done) {\n        x = r.value;\n        for (var i = 0; i < arguments.length; i++) {\n            if (arguments[(typeof i === \"number\" && i < 0) ? arguments.length + i : i].has(x)) {\n                remove.push(x);\n                break;\n            }\n        }\n        r = iterator.next();\n    }\n    for (var j = 0; j < remove.length; j++) {\n        s.delete(remove[(typeof j === \"number\" && j < 0) ? remove.length + j : j]);\n    }\n};\nρσ_set.prototype.intersection = function () {\n    var ans, s, iterator, r, x, has;\n    ans = new ρσ_set;\n    s = ans.jsset;\n    iterator = this.jsset.values();\n    r = iterator.next();\n    while (!r.done) {\n        x = r.value;\n        has = true;\n        for (var i = 0; i < arguments.length; i++) {\n            if (!arguments[(typeof i === \"number\" && i < 0) ? arguments.length + i : i].has(x)) {\n                has = false;\n                break;\n            }\n        }\n        if (has) {\n            s.add(x);\n        }\n        r = iterator.next();\n    }\n    return ans;\n};\nρσ_set.prototype.intersection_update = function () {\n    var s, remove, iterator, r, x;\n    s = this.jsset;\n    remove = [];\n    iterator = s.values();\n    r = iterator.next();\n    while (!r.done) {\n        x = r.value;\n        for (var i = 0; i < arguments.length; i++) {\n            if (!arguments[(typeof i === \"number\" && i < 0) ? arguments.length + i : i].has(x)) {\n                remove.push(x);\n                break;\n            }\n        }\n        r = iterator.next();\n    }\n    for (var j = 0; j < remove.length; j++) {\n        s.delete(remove[(typeof j === \"number\" && j < 0) ? remove.length + j : j]);\n    }\n};\nρσ_set.prototype.isdisjoint = (function() {\n    var ρσ_anonfunc = function (other) {\n        var iterator, r, x;\n        iterator = this.jsset.values();\n        r = iterator.next();\n        while (!r.done) {\n            x = r.value;\n            if (other.has(x)) {\n                return false;\n            }\n            r = iterator.next();\n        }\n        return true;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"other\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_set.prototype.issubset = (function() {\n    var ρσ_anonfunc = function (other) {\n        var iterator, r, x;\n        iterator = this.jsset.values();\n        r = iterator.next();\n        while (!r.done) {\n            x = r.value;\n            if (!other.has(x)) {\n                return false;\n            }\n            r = iterator.next();\n        }\n        return true;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"other\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_set.prototype.issuperset = (function() {\n    var ρσ_anonfunc = function (other) {\n        var s, iterator, r, x;\n        s = this.jsset;\n        iterator = other.jsset.values();\n        r = iterator.next();\n        while (!r.done) {\n            x = r.value;\n            if (!s.has(x)) {\n                return false;\n            }\n            r = iterator.next();\n        }\n        return true;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"other\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_set.prototype.pop = function () {\n    var iterator, r;\n    iterator = this.jsset.values();\n    r = iterator.next();\n    if (r.done) {\n        throw new KeyError(\"pop from an empty set\");\n    }\n    this.jsset.delete(r.value);\n    return r.value;\n};\nρσ_set.prototype.remove = (function() {\n    var ρσ_anonfunc = function (x) {\n        if (!this.jsset.delete(x)) {\n            throw new KeyError(x.toString());\n        }\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"x\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_set.prototype.symmetric_difference = (function() {\n    var ρσ_anonfunc = function (other) {\n        return this.union(other).difference(this.intersection(other));\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"other\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_set.prototype.symmetric_difference_update = (function() {\n    var ρσ_anonfunc = function (other) {\n        var common;\n        common = this.intersection(other);\n        this.update(other);\n        this.difference_update(common);\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"other\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_set.prototype.union = function () {\n    var ans;\n    ans = ρσ_set(this);\n    ans.update.apply(ans, arguments);\n    return ans;\n};\nρσ_set.prototype.update = function () {\n    var s, iterator, r;\n    s = this.jsset;\n    for (var i=0; i < arguments.length; i++) {\n        iterator = arguments[(typeof i === \"number\" && i < 0) ? arguments.length + i : i][ρσ_iterator_symbol]();\n        r = iterator.next();\n        while (!r.done) {\n            s.add(r.value);\n            r = iterator.next();\n        }\n    }\n};\nρσ_set.prototype.toString = ρσ_set.prototype.inspect = function () {\n    return \"{\" + list(this).join(\", \") + \"}\";\n};\nρσ_set.prototype.__eq__ = (function() {\n    var ρσ_anonfunc = function (other) {\n        var iterator, r;\n        if (!other instanceof this.constructor) {\n            return false;\n        }\n        if (other.size !== this.size) {\n            return false;\n        }\n        if (other.size === 0) {\n            return true;\n        }\n        iterator = other[ρσ_iterator_symbol]();\n        r = iterator.next();\n        while (!r.done) {\n            if (!this.has(r.value)) {\n                return false;\n            }\n            r = iterator.next();\n        }\n        return true;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"other\"]}\n    });\n    return ρσ_anonfunc;\n})();\nfunction ρσ_set_wrap(x) {\n    var ans;\n    ans = new ρσ_set;\n    ans.jsset = x;\n    return ans;\n};\nif (!ρσ_set_wrap.__argnames__) Object.defineProperties(ρσ_set_wrap, {\n    __argnames__ : {value: [\"x\"]}\n});\n\nvar set = ρσ_set, set_wrap = ρσ_set_wrap;\nvar ρσ_dict_implementation;\nfunction ρσ_dict_polyfill() {\n    this._store = {};\n    this.size = 0;\n};\n\nρσ_dict_polyfill.prototype.set = (function() {\n    var ρσ_anonfunc = function (x, value) {\n        var key;\n        key = ρσ_set_keyfor(x);\n        if (!Object.prototype.hasOwnProperty.call(this._store, key)) {\n            this.size += 1;\n        }\n        (ρσ_expr_temp = this._store)[(typeof key === \"number\" && key < 0) ? ρσ_expr_temp.length + key : key] = [x, value];\n        return this;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"x\", \"value\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_dict_polyfill.prototype.clear = (function() {\n    var ρσ_anonfunc = function (x) {\n        this._store = {};\n        this.size = 0;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"x\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_dict_polyfill.prototype.delete = (function() {\n    var ρσ_anonfunc = function (x) {\n        var key;\n        key = ρσ_set_keyfor(x);\n        if (Object.prototype.hasOwnProperty.call(this._store, key)) {\n            this.size -= 1;\n            delete this._store[key];\n            return true;\n        }\n        return false;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"x\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_dict_polyfill.prototype.has = (function() {\n    var ρσ_anonfunc = function (x) {\n        return Object.prototype.hasOwnProperty.call(this._store, ρσ_set_keyfor(x));\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"x\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_dict_polyfill.prototype.get = (function() {\n    var ρσ_anonfunc = function (x) {\n        try {\n            return (ρσ_expr_temp = this._store)[ρσ_bound_index(ρσ_set_keyfor(x), ρσ_expr_temp)][1];\n        } catch (ρσ_Exception) {\n            ρσ_last_exception = ρσ_Exception;\n            if (ρσ_Exception instanceof TypeError) {\n                return undefined;\n            } else {\n                throw ρσ_Exception;\n            }\n        }\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"x\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_dict_polyfill.prototype.values = (function() {\n    var ρσ_anonfunc = function (x) {\n        var ans;\n        ans = {'_keys': Object.keys(this._store), '_i':-1, '_s':this._store};\n        ans[ρσ_iterator_symbol] = function () {\n            return this;\n        };\n        ans[\"next\"] = function () {\n            this._i += 1;\n            if (this._i >= this._keys.length) {\n                return {'done': true};\n            }\n            return {'done':false, 'value':this._s[this._keys[this._i]][1]};\n        };\n        return ans;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"x\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_dict_polyfill.prototype.keys = (function() {\n    var ρσ_anonfunc = function (x) {\n        var ans;\n        ans = {'_keys': Object.keys(this._store), '_i':-1, '_s':this._store};\n        ans[ρσ_iterator_symbol] = function () {\n            return this;\n        };\n        ans[\"next\"] = function () {\n            this._i += 1;\n            if (this._i >= this._keys.length) {\n                return {'done': true};\n            }\n            return {'done':false, 'value':this._s[this._keys[this._i]][0]};\n        };\n        return ans;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"x\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_dict_polyfill.prototype.entries = (function() {\n    var ρσ_anonfunc = function (x) {\n        var ans;\n        ans = {'_keys': Object.keys(this._store), '_i':-1, '_s':this._store};\n        ans[ρσ_iterator_symbol] = function () {\n            return this;\n        };\n        ans[\"next\"] = function () {\n            this._i += 1;\n            if (this._i >= this._keys.length) {\n                return {'done': true};\n            }\n            return {'done':false, 'value':this._s[this._keys[this._i]]};\n        };\n        return ans;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"x\"]}\n    });\n    return ρσ_anonfunc;\n})();\nif (typeof Map !== \"function\" || typeof Map.prototype.delete !== \"function\") {\n    ρσ_dict_implementation = ρσ_dict_polyfill;\n} else {\n    ρσ_dict_implementation = Map;\n}\nfunction ρσ_dict() {\n    var iterable = ( 0 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === \"object\" && arguments[arguments.length-1] [ρσ_kwargs_symbol] === true) ? undefined : arguments[0];\n    var kw = arguments[arguments.length-1];\n    if (kw === null || typeof kw !== \"object\" || kw [ρσ_kwargs_symbol] !== true) kw = {};\n    if (this instanceof ρσ_dict) {\n        this.jsmap = new ρσ_dict_implementation;\n        if (iterable !== undefined) {\n            this.update(iterable);\n        }\n        this.update(kw);\n        return this;\n    } else {\n        return ρσ_interpolate_kwargs_constructor.call(Object.create(ρσ_dict.prototype), false, ρσ_dict, [iterable].concat([ρσ_desugar_kwargs(kw)]));\n    }\n};\nif (!ρσ_dict.__handles_kwarg_interpolation__) Object.defineProperties(ρσ_dict, {\n    __handles_kwarg_interpolation__ : {value: true},\n    __argnames__ : {value: [\"iterable\"]}\n});\n\nρσ_dict.prototype.__name__ = \"dict\";\nObject.defineProperties(ρσ_dict.prototype, (function(){\n    var ρσ_d = {};\n    ρσ_d[\"length\"] = (function(){\n        var ρσ_d = {};\n        ρσ_d[\"get\"] = function () {\n            return this.jsmap.size;\n        };\n        return ρσ_d;\n    }).call(this);\n    ρσ_d[\"size\"] = (function(){\n        var ρσ_d = {};\n        ρσ_d[\"get\"] = function () {\n            return this.jsmap.size;\n        };\n        return ρσ_d;\n    }).call(this);\n    return ρσ_d;\n}).call(this));\nρσ_dict.prototype.__len__ = function () {\n    return this.jsmap.size;\n};\nρσ_dict.prototype.has = ρσ_dict.prototype.__contains__ = (function() {\n    var ρσ_anonfunc = function (x) {\n        return this.jsmap.has(x);\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"x\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_dict.prototype.set = ρσ_dict.prototype.__setitem__ = (function() {\n    var ρσ_anonfunc = function (key, value) {\n        this.jsmap.set(key, value);\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"key\", \"value\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_dict.prototype.__delitem__ = (function() {\n    var ρσ_anonfunc = function (key) {\n        this.jsmap.delete(key);\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"key\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_dict.prototype.clear = function () {\n    this.jsmap.clear();\n};\nρσ_dict.prototype.copy = function () {\n    return ρσ_dict(this);\n};\nρσ_dict.prototype.keys = function () {\n    return this.jsmap.keys();\n};\nρσ_dict.prototype.values = function () {\n    return this.jsmap.values();\n};\nρσ_dict.prototype.items = ρσ_dict.prototype.entries = function () {\n    return this.jsmap.entries();\n};\nρσ_dict.prototype[ρσ_iterator_symbol] = function () {\n    return this.jsmap.keys();\n};\nρσ_dict.prototype.__getitem__ = (function() {\n    var ρσ_anonfunc = function (key) {\n        var ans;\n        ans = this.jsmap.get(key);\n        if (ans === undefined && !this.jsmap.has(key)) {\n            throw new KeyError(key + \"\");\n        }\n        return ans;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"key\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_dict.prototype.get = (function() {\n    var ρσ_anonfunc = function (key, defval) {\n        var ans;\n        ans = this.jsmap.get(key);\n        if (ans === undefined && !this.jsmap.has(key)) {\n            return (defval === undefined) ? null : defval;\n        }\n        return ans;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"key\", \"defval\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_dict.prototype.set_default = (function() {\n    var ρσ_anonfunc = function (key, defval) {\n        var j;\n        j = this.jsmap;\n        if (!j.has(key)) {\n            j.set(key, defval);\n            return defval;\n        }\n        return j.get(key);\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"key\", \"defval\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_dict.fromkeys = ρσ_dict.prototype.fromkeys = (function() {\n    var ρσ_anonfunc = function () {\n        var iterable = ( 0 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === \"object\" && arguments[arguments.length-1] [ρσ_kwargs_symbol] === true) ? undefined : arguments[0];\n        var value = (arguments[1] === undefined || ( 1 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === \"object\" && arguments[arguments.length-1] [ρσ_kwargs_symbol] === true)) ? ρσ_anonfunc.__defaults__.value : arguments[1];\n        var ρσ_kwargs_obj = arguments[arguments.length-1];\n        if (ρσ_kwargs_obj === null || typeof ρσ_kwargs_obj !== \"object\" || ρσ_kwargs_obj [ρσ_kwargs_symbol] !== true) ρσ_kwargs_obj = {};\n        if (Object.prototype.hasOwnProperty.call(ρσ_kwargs_obj, \"value\")){\n            value = ρσ_kwargs_obj.value;\n        }\n        var ans, iterator, r;\n        ans = ρσ_dict();\n        iterator = iter(iterable);\n        r = iterator.next();\n        while (!r.done) {\n            ans.set(r.value, value);\n            r = iterator.next();\n        }\n        return ans;\n    };\n    if (!ρσ_anonfunc.__defaults__) Object.defineProperties(ρσ_anonfunc, {\n        __defaults__ : {value: {value:null}},\n        __handles_kwarg_interpolation__ : {value: true},\n        __argnames__ : {value: [\"iterable\", \"value\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_dict.prototype.pop = (function() {\n    var ρσ_anonfunc = function (key, defval) {\n        var ans;\n        ans = this.jsmap.get(key);\n        if (ans === undefined && !this.jsmap.has(key)) {\n            if (defval === undefined) {\n                throw new KeyError(key);\n            }\n            return defval;\n        }\n        this.jsmap.delete(key);\n        return ans;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"key\", \"defval\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_dict.prototype.popitem = function () {\n    var r;\n    r = this.jsmap.entries().next();\n    if (r.done) {\n        throw new KeyError(\"dict is empty\");\n    }\n    this.jsmap.delete(r.value[0]);\n    return r.value;\n};\nρσ_dict.prototype.update = function () {\n    var m, iterable, iterator, result, keys;\n    if (arguments.length === 0) {\n        return;\n    }\n    m = this.jsmap;\n    iterable = arguments[0];\n    if (Array.isArray(iterable)) {\n        for (var i = 0; i < iterable.length; i++) {\n            m.set(iterable[(typeof i === \"number\" && i < 0) ? iterable.length + i : i][0], iterable[(typeof i === \"number\" && i < 0) ? iterable.length + i : i][1]);\n        }\n    } else if (iterable instanceof ρσ_dict) {\n        iterator = iterable.items();\n        result = iterator.next();\n        while (!result.done) {\n            m.set(result.value[0], result.value[1]);\n            result = iterator.next();\n        }\n    } else if (typeof Map === \"function\" && iterable instanceof Map) {\n        iterator = iterable.entries();\n        result = iterator.next();\n        while (!result.done) {\n            m.set(result.value[0], result.value[1]);\n            result = iterator.next();\n        }\n    } else if (typeof iterable[ρσ_iterator_symbol] === \"function\") {\n        iterator = iterable[ρσ_iterator_symbol]();\n        result = iterator.next();\n        while (!result.done) {\n            m.set(result.value[0], result.value[1]);\n            result = iterator.next();\n        }\n    } else {\n        keys = Object.keys(iterable);\n        for (var j=0; j < keys.length; j++) {\n            if (keys[(typeof j === \"number\" && j < 0) ? keys.length + j : j] !== ρσ_iterator_symbol) {\n                m.set(keys[(typeof j === \"number\" && j < 0) ? keys.length + j : j], iterable[ρσ_bound_index(keys[(typeof j === \"number\" && j < 0) ? keys.length + j : j], iterable)]);\n            }\n        }\n    }\n    if (arguments.length > 1) {\n        ρσ_dict.prototype.update.call(this, arguments[1]);\n    }\n};\nρσ_dict.prototype.toString = ρσ_dict.prototype.inspect = ρσ_dict.prototype.__str__ = ρσ_dict.prototype.__repr__ = function () {\n    var entries, iterator, r;\n    entries = [];\n    iterator = this.jsmap.entries();\n    r = iterator.next();\n    while (!r.done) {\n        entries.push(ρσ_repr(r.value[0]) + \": \" + ρσ_repr(r.value[1]));\n        r = iterator.next();\n    }\n    return \"{\" + entries.join(\", \") + \"}\";\n};\nρσ_dict.prototype.__eq__ = (function() {\n    var ρσ_anonfunc = function (other) {\n        var iterator, r, x;\n        if (!(other instanceof this.constructor)) {\n            return false;\n        }\n        if (other.size !== this.size) {\n            return false;\n        }\n        if (other.size === 0) {\n            return true;\n        }\n        iterator = other.items();\n        r = iterator.next();\n        while (!r.done) {\n            x = this.jsmap.get(r.value[0]);\n            if (x === undefined && !this.jsmap.has(r.value[0]) || x !== r.value[1]) {\n                return false;\n            }\n            r = iterator.next();\n        }\n        return true;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"other\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_dict.prototype.as_object = (function() {\n    var ρσ_anonfunc = function (other) {\n        var ans, iterator, r;\n        ans = {};\n        iterator = this.jsmap.entries();\n        r = iterator.next();\n        while (!r.done) {\n            ans[ρσ_bound_index(r.value[0], ans)] = r.value[1];\n            r = iterator.next();\n        }\n        return ans;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"other\"]}\n    });\n    return ρσ_anonfunc;\n})();\nfunction ρσ_dict_wrap(x) {\n    var ans;\n    ans = new ρσ_dict;\n    ans.jsmap = x;\n    return ans;\n};\nif (!ρσ_dict_wrap.__argnames__) Object.defineProperties(ρσ_dict_wrap, {\n    __argnames__ : {value: [\"x\"]}\n});\n\nvar dict = ρσ_dict, dict_wrap = ρσ_dict_wrap;var NameError;\nNameError = ReferenceError;\nfunction Exception() {\n    if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n    Exception.prototype.__init__.apply(this, arguments);\n}\nρσ_extends(Exception, Error);\nException.prototype.__init__ = function __init__(message) {\n    var self = this;\n    self.message = message;\n    self.stack = (new Error).stack;\n    self.name = self.constructor.name;\n};\nif (!Exception.prototype.__init__.__argnames__) Object.defineProperties(Exception.prototype.__init__, {\n    __argnames__ : {value: [\"message\"]}\n});\nException.__argnames__ = Exception.prototype.__init__.__argnames__;\nException.__handles_kwarg_interpolation__ = Exception.prototype.__init__.__handles_kwarg_interpolation__;\nException.prototype.__repr__ = function __repr__() {\n    var self = this;\n    return self.name + \": \" + self.message;\n};\nif (!Exception.prototype.__repr__.__argnames__) Object.defineProperties(Exception.prototype.__repr__, {\n    __argnames__ : {value: []}\n});\nException.prototype.__str__ = function __str__ () {\n    if(Error.prototype.__str__) return Error.prototype.__str__.call(this);\nreturn this.__repr__();\n};\nObject.defineProperty(Exception.prototype, \"__bases__\", {value: [Error]});\n\nfunction AttributeError() {\n    if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n    AttributeError.prototype.__init__.apply(this, arguments);\n}\nρσ_extends(AttributeError, Exception);\nAttributeError.prototype.__init__ = function __init__ () {\n    Exception.prototype.__init__ && Exception.prototype.__init__.apply(this, arguments);\n};\nAttributeError.prototype.__repr__ = function __repr__ () {\n    if(Exception.prototype.__repr__) return Exception.prototype.__repr__.call(this);\n    return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n};\nAttributeError.prototype.__str__ = function __str__ () {\n    if(Exception.prototype.__str__) return Exception.prototype.__str__.call(this);\nreturn this.__repr__();\n};\nObject.defineProperty(AttributeError.prototype, \"__bases__\", {value: [Exception]});\n\n\nfunction IndexError() {\n    if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n    IndexError.prototype.__init__.apply(this, arguments);\n}\nρσ_extends(IndexError, Exception);\nIndexError.prototype.__init__ = function __init__ () {\n    Exception.prototype.__init__ && Exception.prototype.__init__.apply(this, arguments);\n};\nIndexError.prototype.__repr__ = function __repr__ () {\n    if(Exception.prototype.__repr__) return Exception.prototype.__repr__.call(this);\n    return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n};\nIndexError.prototype.__str__ = function __str__ () {\n    if(Exception.prototype.__str__) return Exception.prototype.__str__.call(this);\nreturn this.__repr__();\n};\nObject.defineProperty(IndexError.prototype, \"__bases__\", {value: [Exception]});\n\n\nfunction KeyError() {\n    if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n    KeyError.prototype.__init__.apply(this, arguments);\n}\nρσ_extends(KeyError, Exception);\nKeyError.prototype.__init__ = function __init__ () {\n    Exception.prototype.__init__ && Exception.prototype.__init__.apply(this, arguments);\n};\nKeyError.prototype.__repr__ = function __repr__ () {\n    if(Exception.prototype.__repr__) return Exception.prototype.__repr__.call(this);\n    return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n};\nKeyError.prototype.__str__ = function __str__ () {\n    if(Exception.prototype.__str__) return Exception.prototype.__str__.call(this);\nreturn this.__repr__();\n};\nObject.defineProperty(KeyError.prototype, \"__bases__\", {value: [Exception]});\n\n\nfunction ValueError() {\n    if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n    ValueError.prototype.__init__.apply(this, arguments);\n}\nρσ_extends(ValueError, Exception);\nValueError.prototype.__init__ = function __init__ () {\n    Exception.prototype.__init__ && Exception.prototype.__init__.apply(this, arguments);\n};\nValueError.prototype.__repr__ = function __repr__ () {\n    if(Exception.prototype.__repr__) return Exception.prototype.__repr__.call(this);\n    return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n};\nValueError.prototype.__str__ = function __str__ () {\n    if(Exception.prototype.__str__) return Exception.prototype.__str__.call(this);\nreturn this.__repr__();\n};\nObject.defineProperty(ValueError.prototype, \"__bases__\", {value: [Exception]});\n\n\nfunction UnicodeDecodeError() {\n    if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n    UnicodeDecodeError.prototype.__init__.apply(this, arguments);\n}\nρσ_extends(UnicodeDecodeError, Exception);\nUnicodeDecodeError.prototype.__init__ = function __init__ () {\n    Exception.prototype.__init__ && Exception.prototype.__init__.apply(this, arguments);\n};\nUnicodeDecodeError.prototype.__repr__ = function __repr__ () {\n    if(Exception.prototype.__repr__) return Exception.prototype.__repr__.call(this);\n    return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n};\nUnicodeDecodeError.prototype.__str__ = function __str__ () {\n    if(Exception.prototype.__str__) return Exception.prototype.__str__.call(this);\nreturn this.__repr__();\n};\nObject.defineProperty(UnicodeDecodeError.prototype, \"__bases__\", {value: [Exception]});\n\n\nfunction AssertionError() {\n    if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n    AssertionError.prototype.__init__.apply(this, arguments);\n}\nρσ_extends(AssertionError, Exception);\nAssertionError.prototype.__init__ = function __init__ () {\n    Exception.prototype.__init__ && Exception.prototype.__init__.apply(this, arguments);\n};\nAssertionError.prototype.__repr__ = function __repr__ () {\n    if(Exception.prototype.__repr__) return Exception.prototype.__repr__.call(this);\n    return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n};\nAssertionError.prototype.__str__ = function __str__ () {\n    if(Exception.prototype.__str__) return Exception.prototype.__str__.call(this);\nreturn this.__repr__();\n};\nObject.defineProperty(AssertionError.prototype, \"__bases__\", {value: [Exception]});\n\n\nfunction ZeroDivisionError() {\n    if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n    ZeroDivisionError.prototype.__init__.apply(this, arguments);\n}\nρσ_extends(ZeroDivisionError, Exception);\nZeroDivisionError.prototype.__init__ = function __init__ () {\n    Exception.prototype.__init__ && Exception.prototype.__init__.apply(this, arguments);\n};\nZeroDivisionError.prototype.__repr__ = function __repr__ () {\n    if(Exception.prototype.__repr__) return Exception.prototype.__repr__.call(this);\n    return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n};\nZeroDivisionError.prototype.__str__ = function __str__ () {\n    if(Exception.prototype.__str__) return Exception.prototype.__str__.call(this);\nreturn this.__repr__();\n};\nObject.defineProperty(ZeroDivisionError.prototype, \"__bases__\", {value: [Exception]});\n\nvar ρσ_in, ρσ_desugar_kwargs, ρσ_exists;\nfunction ρσ_eslice(arr, step, start, end) {\n    var is_string;\n    if (typeof arr === \"string\" || arr instanceof String) {\n        is_string = true;\n        arr = arr.split(\"\");\n    }\n    if (step < 0) {\n        step = -step;\n        arr = arr.slice().reverse();\n        if (typeof start !== \"undefined\") {\n            start = arr.length - start - 1;\n        }\n        if (typeof end !== \"undefined\") {\n            end = arr.length - end - 1;\n        }\n    }\n    if (typeof start === \"undefined\") {\n        start = 0;\n    }\n    if (typeof end === \"undefined\") {\n        end = arr.length;\n    }\n    arr = arr.slice(start, end).filter((function() {\n        var ρσ_anonfunc = function (e, i) {\n            return i % step === 0;\n        };\n        if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n            __argnames__ : {value: [\"e\", \"i\"]}\n        });\n        return ρσ_anonfunc;\n    })());\n    if (is_string) {\n        arr = arr.join(\"\");\n    }\n    return arr;\n};\nif (!ρσ_eslice.__argnames__) Object.defineProperties(ρσ_eslice, {\n    __argnames__ : {value: [\"arr\", \"step\", \"start\", \"end\"]}\n});\n\nfunction ρσ_delslice(arr, step, start, end) {\n    var is_string, ρσ_unpack, indices;\n    if (typeof arr === \"string\" || arr instanceof String) {\n        is_string = true;\n        arr = arr.split(\"\");\n    }\n    if (step < 0) {\n        if (typeof start === \"undefined\") {\n            start = arr.length;\n        }\n        if (typeof end === \"undefined\") {\n            end = 0;\n        }\n        ρσ_unpack = [end, start, -step];\n        start = ρσ_unpack[0];\n        end = ρσ_unpack[1];\n        step = ρσ_unpack[2];\n    }\n    if (typeof start === \"undefined\") {\n        start = 0;\n    }\n    if (typeof end === \"undefined\") {\n        end = arr.length;\n    }\n    if (step === 1) {\n        arr.splice(start, end - start);\n    } else {\n        if (end > start) {\n            indices = [];\n            for (var i = start; i < end; i += step) {\n                indices.push(i);\n            }\n            for (var i = indices.length - 1; i >= 0; i--) {\n                arr.splice(indices[(typeof i === \"number\" && i < 0) ? indices.length + i : i], 1);\n            }\n        }\n    }\n    if (is_string) {\n        arr = arr.join(\"\");\n    }\n    return arr;\n};\nif (!ρσ_delslice.__argnames__) Object.defineProperties(ρσ_delslice, {\n    __argnames__ : {value: [\"arr\", \"step\", \"start\", \"end\"]}\n});\n\nfunction ρσ_flatten(arr) {\n    var ans, value;\n    ans = ρσ_list_decorate([]);\n    for (var i=0; i < arr.length; i++) {\n        value = arr[(typeof i === \"number\" && i < 0) ? arr.length + i : i];\n        if (Array.isArray(value)) {\n            ans = ans.concat(ρσ_flatten(value));\n        } else {\n            ans.push(value);\n        }\n    }\n    return ans;\n};\nif (!ρσ_flatten.__argnames__) Object.defineProperties(ρσ_flatten, {\n    __argnames__ : {value: [\"arr\"]}\n});\n\nfunction ρσ_unpack_asarray(num, iterable) {\n    var ans, iterator, result;\n    if (ρσ_arraylike(iterable)) {\n        return iterable;\n    }\n    ans = [];\n    if (typeof iterable[ρσ_iterator_symbol] === \"function\") {\n        iterator = (typeof Map === \"function\" && iterable instanceof Map) ? iterable.keys() : iterable[ρσ_iterator_symbol]();\n        result = iterator.next();\n        while (!result.done && ans.length < num) {\n            ans.push(result.value);\n            result = iterator.next();\n        }\n    }\n    return ans;\n};\nif (!ρσ_unpack_asarray.__argnames__) Object.defineProperties(ρσ_unpack_asarray, {\n    __argnames__ : {value: [\"num\", \"iterable\"]}\n});\n\nfunction ρσ_extends(child, parent) {\n    child.prototype = Object.create(parent.prototype);\n    child.prototype.constructor = child;\n};\nif (!ρσ_extends.__argnames__) Object.defineProperties(ρσ_extends, {\n    __argnames__ : {value: [\"child\", \"parent\"]}\n});\n\nρσ_in = function () {\n    if (typeof Map === \"function\" && typeof Set === \"function\") {\n        return (function() {\n            var ρσ_anonfunc = function (val, arr) {\n                if (typeof arr === \"string\") {\n                    return arr.indexOf(val) !== -1;\n                }\n                if (typeof arr.__contains__ === \"function\") {\n                    return arr.__contains__(val);\n                }\n                if (arr instanceof Map || arr instanceof Set) {\n                    return arr.has(val);\n                }\n                if (ρσ_arraylike(arr)) {\n                    return ρσ_list_contains.call(arr, val);\n                }\n                return Object.prototype.hasOwnProperty.call(arr, val);\n            };\n            if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                __argnames__ : {value: [\"val\", \"arr\"]}\n            });\n            return ρσ_anonfunc;\n        })();\n    }\n    return (function() {\n        var ρσ_anonfunc = function (val, arr) {\n            if (typeof arr === \"string\") {\n                return arr.indexOf(val) !== -1;\n            }\n            if (typeof arr.__contains__ === \"function\") {\n                return arr.__contains__(val);\n            }\n            if (ρσ_arraylike(arr)) {\n                return ρσ_list_contains.call(arr, val);\n            }\n            return Object.prototype.hasOwnProperty.call(arr, val);\n        };\n        if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n            __argnames__ : {value: [\"val\", \"arr\"]}\n        });\n        return ρσ_anonfunc;\n    })();\n}();\nfunction ρσ_Iterable(iterable) {\n    var iterator, ans, result;\n    if (ρσ_arraylike(iterable)) {\n        return iterable;\n    }\n    if (typeof iterable[ρσ_iterator_symbol] === \"function\") {\n        iterator = (typeof Map === \"function\" && iterable instanceof Map) ? iterable.keys() : iterable[ρσ_iterator_symbol]();\n        ans = ρσ_list_decorate([]);\n        result = iterator.next();\n        while (!result.done) {\n            ans.push(result.value);\n            result = iterator.next();\n        }\n        return ans;\n    }\n    return Object.keys(iterable);\n};\nif (!ρσ_Iterable.__argnames__) Object.defineProperties(ρσ_Iterable, {\n    __argnames__ : {value: [\"iterable\"]}\n});\n\nρσ_desugar_kwargs = function () {\n    if (typeof Object.assign === \"function\") {\n        return function () {\n            var ans;\n            ans = Object.create(null);\n            ans[ρσ_kwargs_symbol] = true;\n            for (var i = 0; i < arguments.length; i++) {\n                Object.assign(ans, arguments[(typeof i === \"number\" && i < 0) ? arguments.length + i : i]);\n            }\n            return ans;\n        };\n    }\n    return function () {\n        var ans, keys;\n        ans = Object.create(null);\n        ans[ρσ_kwargs_symbol] = true;\n        for (var i = 0; i < arguments.length; i++) {\n            keys = Object.keys(arguments[(typeof i === \"number\" && i < 0) ? arguments.length + i : i]);\n            for (var j = 0; j < keys.length; j++) {\n                ans[ρσ_bound_index(keys[(typeof j === \"number\" && j < 0) ? keys.length + j : j], ans)] = (ρσ_expr_temp = arguments[(typeof i === \"number\" && i < 0) ? arguments.length + i : i])[ρσ_bound_index(keys[(typeof j === \"number\" && j < 0) ? keys.length + j : j], ρσ_expr_temp)];\n            }\n        }\n        return ans;\n    };\n}();\nfunction ρσ_interpolate_kwargs(f, supplied_args) {\n    var has_prop, kwobj, args, prop;\n    if (!f.__argnames__) {\n        return f.apply(this, supplied_args);\n    }\n    has_prop = Object.prototype.hasOwnProperty;\n    kwobj = supplied_args.pop();\n    if (f.__handles_kwarg_interpolation__) {\n        args = new Array(Math.max(supplied_args.length, f.__argnames__.length) + 1);\n        args[args.length-1] = kwobj;\n        for (var i = 0; i < args.length - 1; i++) {\n            if (i < f.__argnames__.length) {\n                prop = (ρσ_expr_temp = f.__argnames__)[(typeof i === \"number\" && i < 0) ? ρσ_expr_temp.length + i : i];\n                if (has_prop.call(kwobj, prop)) {\n                    args[(typeof i === \"number\" && i < 0) ? args.length + i : i] = kwobj[(typeof prop === \"number\" && prop < 0) ? kwobj.length + prop : prop];\n                    delete kwobj[prop];\n                } else if (i < supplied_args.length) {\n                    args[(typeof i === \"number\" && i < 0) ? args.length + i : i] = supplied_args[(typeof i === \"number\" && i < 0) ? supplied_args.length + i : i];\n                }\n            } else {\n                args[(typeof i === \"number\" && i < 0) ? args.length + i : i] = supplied_args[(typeof i === \"number\" && i < 0) ? supplied_args.length + i : i];\n            }\n        }\n        return f.apply(this, args);\n    }\n    for (var i = 0; i < f.__argnames__.length; i++) {\n        prop = (ρσ_expr_temp = f.__argnames__)[(typeof i === \"number\" && i < 0) ? ρσ_expr_temp.length + i : i];\n        if (has_prop.call(kwobj, prop)) {\n            supplied_args[(typeof i === \"number\" && i < 0) ? supplied_args.length + i : i] = kwobj[(typeof prop === \"number\" && prop < 0) ? kwobj.length + prop : prop];\n        }\n    }\n    return f.apply(this, supplied_args);\n};\nif (!ρσ_interpolate_kwargs.__argnames__) Object.defineProperties(ρσ_interpolate_kwargs, {\n    __argnames__ : {value: [\"f\", \"supplied_args\"]}\n});\n\nfunction ρσ_interpolate_kwargs_constructor(apply, f, supplied_args) {\n    if (apply) {\n        f.apply(this, supplied_args);\n    } else {\n        ρσ_interpolate_kwargs.call(this, f, supplied_args);\n    }\n    return this;\n};\nif (!ρσ_interpolate_kwargs_constructor.__argnames__) Object.defineProperties(ρσ_interpolate_kwargs_constructor, {\n    __argnames__ : {value: [\"apply\", \"f\", \"supplied_args\"]}\n});\n\nfunction ρσ_getitem(obj, key) {\n    if (obj.__getitem__) {\n        return obj.__getitem__(key);\n    }\n    if (typeof key === \"number\" && key < 0) {\n        key += obj.length;\n    }\n    return obj[(typeof key === \"number\" && key < 0) ? obj.length + key : key];\n};\nif (!ρσ_getitem.__argnames__) Object.defineProperties(ρσ_getitem, {\n    __argnames__ : {value: [\"obj\", \"key\"]}\n});\n\nfunction ρσ_setitem(obj, key, val) {\n    if (obj.__setitem__) {\n        obj.__setitem__(key, val);\n    } else {\n        if (typeof key === \"number\" && key < 0) {\n            key += obj.length;\n        }\n        obj[(typeof key === \"number\" && key < 0) ? obj.length + key : key] = val;\n    }\n};\nif (!ρσ_setitem.__argnames__) Object.defineProperties(ρσ_setitem, {\n    __argnames__ : {value: [\"obj\", \"key\", \"val\"]}\n});\n\nfunction ρσ_delitem(obj, key) {\n    if (obj.__delitem__) {\n        obj.__delitem__(key);\n    } else if (typeof obj.splice === \"function\") {\n        obj.splice(key, 1);\n    } else {\n        if (typeof key === \"number\" && key < 0) {\n            key += obj.length;\n        }\n        delete obj[key];\n    }\n};\nif (!ρσ_delitem.__argnames__) Object.defineProperties(ρσ_delitem, {\n    __argnames__ : {value: [\"obj\", \"key\"]}\n});\n\nfunction ρσ_bound_index(idx, arr) {\n    if (typeof idx === \"number\" && idx < 0) {\n        idx += arr.length;\n    }\n    return idx;\n};\nif (!ρσ_bound_index.__argnames__) Object.defineProperties(ρσ_bound_index, {\n    __argnames__ : {value: [\"idx\", \"arr\"]}\n});\n\nfunction ρσ_splice(arr, val, start, end) {\n    start = start || 0;\n    if (start < 0) {\n        start += arr.length;\n    }\n    if (end === undefined) {\n        end = arr.length;\n    }\n    if (end < 0) {\n        end += arr.length;\n    }\n    Array.prototype.splice.apply(arr, [start, end - start].concat(val));\n};\nif (!ρσ_splice.__argnames__) Object.defineProperties(ρσ_splice, {\n    __argnames__ : {value: [\"arr\", \"val\", \"start\", \"end\"]}\n});\n\nρσ_exists = (function(){\n    var ρσ_d = {};\n    ρσ_d[\"n\"] = (function() {\n        var ρσ_anonfunc = function (expr) {\n            return expr !== undefined && expr !== null;\n        };\n        if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n            __argnames__ : {value: [\"expr\"]}\n        });\n        return ρσ_anonfunc;\n    })();\n    ρσ_d[\"d\"] = (function() {\n        var ρσ_anonfunc = function (expr) {\n            if (expr === undefined || expr === null) {\n                return Object.create(null);\n            }\n            return expr;\n        };\n        if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n            __argnames__ : {value: [\"expr\"]}\n        });\n        return ρσ_anonfunc;\n    })();\n    ρσ_d[\"c\"] = (function() {\n        var ρσ_anonfunc = function (expr) {\n            if (typeof expr === \"function\") {\n                return expr;\n            }\n            return function () {\n                return undefined;\n            };\n        };\n        if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n            __argnames__ : {value: [\"expr\"]}\n        });\n        return ρσ_anonfunc;\n    })();\n    ρσ_d[\"g\"] = (function() {\n        var ρσ_anonfunc = function (expr) {\n            if (expr === undefined || expr === null || typeof expr.__getitem__ !== \"function\") {\n                return (function(){\n                    var ρσ_d = {};\n                    ρσ_d[\"__getitem__\"] = function () {\n                        return undefined;\n                    };\n                    return ρσ_d;\n                }).call(this);\n            }\n        };\n        if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n            __argnames__ : {value: [\"expr\"]}\n        });\n        return ρσ_anonfunc;\n    })();\n    ρσ_d[\"e\"] = (function() {\n        var ρσ_anonfunc = function (expr, alt) {\n            return (expr === undefined || expr === null) ? alt : expr;\n        };\n        if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n            __argnames__ : {value: [\"expr\", \"alt\"]}\n        });\n        return ρσ_anonfunc;\n    })();\n    return ρσ_d;\n}).call(this);\nfunction ρσ_mixin() {\n    var seen, resolved_props, p, target, props, name;\n    seen = Object.create(null);\n    seen.__argnames__ = seen.__handles_kwarg_interpolation__ = seen.__init__ = seen.__annotations__ = seen.__doc__ = seen.__bind_methods__ = seen.__bases__ = seen.constructor = seen.__class__ = true;\n    resolved_props = {};\n    p = target = arguments[0].prototype;\n    while (p && p !== Object.prototype) {\n        props = Object.getOwnPropertyNames(p);\n        for (var i = 0; i < props.length; i++) {\n            seen[ρσ_bound_index(props[(typeof i === \"number\" && i < 0) ? props.length + i : i], seen)] = true;\n        }\n        p = Object.getPrototypeOf(p);\n    }\n    for (var c = 1; c < arguments.length; c++) {\n        p = arguments[(typeof c === \"number\" && c < 0) ? arguments.length + c : c].prototype;\n        while (p && p !== Object.prototype) {\n            props = Object.getOwnPropertyNames(p);\n            for (var i = 0; i < props.length; i++) {\n                name = props[(typeof i === \"number\" && i < 0) ? props.length + i : i];\n                if (seen[(typeof name === \"number\" && name < 0) ? seen.length + name : name]) {\n                    continue;\n                }\n                seen[(typeof name === \"number\" && name < 0) ? seen.length + name : name] = true;\n                resolved_props[(typeof name === \"number\" && name < 0) ? resolved_props.length + name : name] = Object.getOwnPropertyDescriptor(p, name);\n            }\n            p = Object.getPrototypeOf(p);\n        }\n    }\n    Object.defineProperties(target, resolved_props);\n};\n\nfunction ρσ_instanceof() {\n    var obj, bases, q, cls, p;\n    obj = arguments[0];\n    bases = \"\";\n    if (obj && obj.constructor && obj.constructor.prototype) {\n        bases = obj.constructor.prototype.__bases__ || \"\";\n    }\n    for (var i = 1; i < arguments.length; i++) {\n        q = arguments[(typeof i === \"number\" && i < 0) ? arguments.length + i : i];\n        if (obj instanceof q) {\n            return true;\n        }\n        if ((q === Array || q === ρσ_list_constructor) && Array.isArray(obj)) {\n            return true;\n        }\n        if (q === ρσ_str && (typeof obj === \"string\" || obj instanceof String)) {\n            return true;\n        }\n        if (bases.length > 1) {\n            for (var c = 1; c < bases.length; c++) {\n                cls = bases[(typeof c === \"number\" && c < 0) ? bases.length + c : c];\n                while (cls) {\n                    if (q === cls) {\n                        return true;\n                    }\n                    p = Object.getPrototypeOf(cls.prototype);\n                    if (!p) {\n                        break;\n                    }\n                    cls = p.constructor;\n                }\n            }\n        }\n    }\n    return false;\n};\nfunction sum(iterable, start) {\n    var ans, iterator, r;\n    if (Array.isArray(iterable)) {\n        return iterable.reduce((function() {\n            var ρσ_anonfunc = function (prev, cur) {\n                return prev + cur;\n            };\n            if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                __argnames__ : {value: [\"prev\", \"cur\"]}\n            });\n            return ρσ_anonfunc;\n        })(), start || 0);\n    }\n    ans = start || 0;\n    iterator = iter(iterable);\n    r = iterator.next();\n    while (!r.done) {\n        ans += r.value;\n        r = iterator.next();\n    }\n    return ans;\n};\nif (!sum.__argnames__) Object.defineProperties(sum, {\n    __argnames__ : {value: [\"iterable\", \"start\"]}\n});\n\nfunction map() {\n    var iterators, func, args, ans;\n    iterators = new Array(arguments.length - 1);\n    func = arguments[0];\n    args = new Array(arguments.length - 1);\n    for (var i = 1; i < arguments.length; i++) {\n        iterators[ρσ_bound_index(i - 1, iterators)] = iter(arguments[(typeof i === \"number\" && i < 0) ? arguments.length + i : i]);\n    }\n    ans = {'_func':func, '_iterators':iterators, '_args':args};\n    ans[ρσ_iterator_symbol] = function () {\n        return this;\n    };\n    ans[\"next\"] = function () {\n        var r;\n        for (var i = 0; i < this._iterators.length; i++) {\n            r = (ρσ_expr_temp = this._iterators)[(typeof i === \"number\" && i < 0) ? ρσ_expr_temp.length + i : i].next();\n            if (r.done) {\n                return {'done':true};\n            }\n            (ρσ_expr_temp = this._args)[(typeof i === \"number\" && i < 0) ? ρσ_expr_temp.length + i : i] = r.value;\n        }\n        return {'done':false, 'value':this._func.apply(undefined, this._args)};\n    };\n    return ans;\n};\n\nfunction filter(func_or_none, iterable) {\n    var func, ans;\n    func = (func_or_none === null) ? ρσ_bool : func_or_none;\n    ans = {'_func':func, '_iterator':ρσ_iter(iterable)};\n    ans[ρσ_iterator_symbol] = function () {\n        return this;\n    };\n    ans[\"next\"] = function () {\n        var r;\n        r = this._iterator.next();\n        while (!r.done) {\n            if (this._func(r.value)) {\n                return r;\n            }\n            r = this._iterator.next();\n        }\n        return {'done':true};\n    };\n    return ans;\n};\nif (!filter.__argnames__) Object.defineProperties(filter, {\n    __argnames__ : {value: [\"func_or_none\", \"iterable\"]}\n});\n\nfunction zip() {\n    var iterators, ans;\n    iterators = new Array(arguments.length);\n    for (var i = 0; i < arguments.length; i++) {\n        iterators[(typeof i === \"number\" && i < 0) ? iterators.length + i : i] = iter(arguments[(typeof i === \"number\" && i < 0) ? arguments.length + i : i]);\n    }\n    ans = {'_iterators':iterators};\n    ans[ρσ_iterator_symbol] = function () {\n        return this;\n    };\n    ans[\"next\"] = function () {\n        var args, r;\n        args = new Array(this._iterators.length);\n        for (var i = 0; i < this._iterators.length; i++) {\n            r = (ρσ_expr_temp = this._iterators)[(typeof i === \"number\" && i < 0) ? ρσ_expr_temp.length + i : i].next();\n            if (r.done) {\n                return {'done':true};\n            }\n            args[(typeof i === \"number\" && i < 0) ? args.length + i : i] = r.value;\n        }\n        return {'done':false, 'value':args};\n    };\n    return ans;\n};\n\nfunction any(iterable) {\n    var i;\n    var ρσ_Iter0 = ρσ_Iterable(iterable);\n    for (var ρσ_Index0 = 0; ρσ_Index0 < ρσ_Iter0.length; ρσ_Index0++) {\n        i = ρσ_Iter0[ρσ_Index0];\n        if (i) {\n            return true;\n        }\n    }\n    return false;\n};\nif (!any.__argnames__) Object.defineProperties(any, {\n    __argnames__ : {value: [\"iterable\"]}\n});\n\nfunction all(iterable) {\n    var i;\n    var ρσ_Iter1 = ρσ_Iterable(iterable);\n    for (var ρσ_Index1 = 0; ρσ_Index1 < ρσ_Iter1.length; ρσ_Index1++) {\n        i = ρσ_Iter1[ρσ_Index1];\n        if (!i) {\n            return false;\n        }\n    }\n    return true;\n};\nif (!all.__argnames__) Object.defineProperties(all, {\n    __argnames__ : {value: [\"iterable\"]}\n});\nvar define_str_func, ρσ_unpack, ρσ_orig_split, ρσ_orig_replace;\nfunction ρσ_repr_js_builtin(x, as_array) {\n    var ans, b, keys, key;\n    ans = [];\n    b = \"{}\";\n    if (as_array) {\n        b = \"[]\";\n        for (var i = 0; i < x.length; i++) {\n            ans.push(ρσ_repr(x[(typeof i === \"number\" && i < 0) ? x.length + i : i]));\n        }\n    } else {\n        keys = Object.keys(x);\n        for (var k = 0; k < keys.length; k++) {\n            key = keys[(typeof k === \"number\" && k < 0) ? keys.length + k : k];\n            ans.push(JSON.stringify(key) + \":\" + ρσ_repr(x[(typeof key === \"number\" && key < 0) ? x.length + key : key]));\n        }\n    }\n    return b[0] + ans.join(\", \") + b[1];\n};\nif (!ρσ_repr_js_builtin.__argnames__) Object.defineProperties(ρσ_repr_js_builtin, {\n    __argnames__ : {value: [\"x\", \"as_array\"]}\n});\n\nfunction ρσ_html_element_to_string(elem) {\n    var attrs, val, attr, ans;\n    attrs = [];\n    var ρσ_Iter0 = ρσ_Iterable(elem.attributes);\n    for (var ρσ_Index0 = 0; ρσ_Index0 < ρσ_Iter0.length; ρσ_Index0++) {\n        attr = ρσ_Iter0[ρσ_Index0];\n        if (attr.specified) {\n            val = attr.value;\n            if (val.length > 10) {\n                val = val.slice(0, 15) + \"...\";\n            }\n            val = JSON.stringify(val);\n            attrs.push(\"\" + ρσ_str.format(\"{}\", attr.name) + \"=\" + ρσ_str.format(\"{}\", val) + \"\");\n        }\n    }\n    attrs = (attrs.length) ? \" \" + attrs.join(\" \") : \"\";\n    ans = \"<\" + ρσ_str.format(\"{}\", elem.tagName) + \"\" + ρσ_str.format(\"{}\", attrs) + \">\";\n    return ans;\n};\nif (!ρσ_html_element_to_string.__argnames__) Object.defineProperties(ρσ_html_element_to_string, {\n    __argnames__ : {value: [\"elem\"]}\n});\n\nfunction ρσ_repr(x) {\n    var ans, name;\n    if (x === null) {\n        return \"None\";\n    }\n    if (x === undefined) {\n        return \"undefined\";\n    }\n    ans = x;\n    if (typeof x.__repr__ === \"function\") {\n        ans = x.__repr__();\n    } else if (x === true || x === false) {\n        ans = (x) ? \"True\" : \"False\";\n    } else if (Array.isArray(x)) {\n        ans = ρσ_repr_js_builtin(x, true);\n    } else if (typeof x === \"function\") {\n        ans = x.toString();\n    } else if (typeof x === \"object\" && !x.toString) {\n        ans = ρσ_repr_js_builtin(x);\n    } else {\n        name = Object.prototype.toString.call(x).slice(8, -1);\n        if (ρσ_not_equals(\"Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array\".indexOf(name), -1)) {\n            return name + \"([\" + x.map((function() {\n                var ρσ_anonfunc = function (i) {\n                    return str.format(\"0x{:02x}\", i);\n                };\n                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                    __argnames__ : {value: [\"i\"]}\n                });\n                return ρσ_anonfunc;\n            })()).join(\", \") + \"])\";\n        }\n        if (typeof HTMLElement !== \"undefined\" && x instanceof HTMLElement) {\n            ans = ρσ_html_element_to_string(x);\n        } else {\n            ans = (typeof x.toString === \"function\") ? x.toString() : x;\n        }\n        if (ans === \"[object Object]\") {\n            return ρσ_repr_js_builtin(x);\n        }\n        try {\n            ans = JSON.stringify(x);\n        } catch (ρσ_Exception) {\n            ρσ_last_exception = ρσ_Exception;\n            {\n            } \n        }\n    }\n    return ans + \"\";\n};\nif (!ρσ_repr.__argnames__) Object.defineProperties(ρσ_repr, {\n    __argnames__ : {value: [\"x\"]}\n});\n\nfunction ρσ_str(x) {\n    var ans, name;\n    if (x === null) {\n        return \"None\";\n    }\n    if (x === undefined) {\n        return \"undefined\";\n    }\n    ans = x;\n    if (typeof x.__str__ === \"function\") {\n        ans = x.__str__();\n    } else if (typeof x.__repr__ === \"function\") {\n        ans = x.__repr__();\n    } else if (x === true || x === false) {\n        ans = (x) ? \"True\" : \"False\";\n    } else if (Array.isArray(x)) {\n        ans = ρσ_repr_js_builtin(x, true);\n    } else if (typeof x.toString === \"function\") {\n        name = Object.prototype.toString.call(x).slice(8, -1);\n        if (ρσ_not_equals(\"Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array\".indexOf(name), -1)) {\n            return name + \"([\" + x.map((function() {\n                var ρσ_anonfunc = function (i) {\n                    return str.format(\"0x{:02x}\", i);\n                };\n                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                    __argnames__ : {value: [\"i\"]}\n                });\n                return ρσ_anonfunc;\n            })()).join(\", \") + \"])\";\n        }\n        if (typeof HTMLElement !== \"undefined\" && x instanceof HTMLElement) {\n            ans = ρσ_html_element_to_string(x);\n        } else {\n            ans = x.toString();\n        }\n        if (ans === \"[object Object]\") {\n            ans = ρσ_repr_js_builtin(x);\n        }\n    } else if (typeof x === \"object\" && !x.toString) {\n        ans = ρσ_repr_js_builtin(x);\n    }\n    return ans + \"\";\n};\nif (!ρσ_str.__argnames__) Object.defineProperties(ρσ_str, {\n    __argnames__ : {value: [\"x\"]}\n});\n\ndefine_str_func = (function() {\n    var ρσ_anonfunc = function (name, func) {\n        var f;\n        (ρσ_expr_temp = ρσ_str.prototype)[(typeof name === \"number\" && name < 0) ? ρσ_expr_temp.length + name : name] = func;\n        ρσ_str[(typeof name === \"number\" && name < 0) ? ρσ_str.length + name : name] = f = func.call.bind(func);\n        if (func.__argnames__) {\n            Object.defineProperty(f, \"__argnames__\", (function(){\n                var ρσ_d = {};\n                ρσ_d[\"value\"] = ['string'].concat(func.__argnames__);\n                return ρσ_d;\n            }).call(this));\n        }\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"name\", \"func\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_unpack = [String.prototype.split.call.bind(String.prototype.split), String.prototype.replace.call.bind(String.prototype.replace)];\nρσ_orig_split = ρσ_unpack[0];\nρσ_orig_replace = ρσ_unpack[1];\ndefine_str_func(\"format\", function () {\n    var template, args, kwargs, explicit, implicit, idx, split, ans, pos, in_brace, markup, ch;\n    template = this;\n    if (template === undefined) {\n        throw new TypeError(\"Template is required\");\n    }\n    args = Array.prototype.slice.call(arguments);\n    kwargs = {};\n    if (args[args.length-1] && args[args.length-1][ρσ_kwargs_symbol] !== undefined) {\n        kwargs = args[args.length-1];\n        args = args.slice(0, -1);\n    }\n    explicit = implicit = false;\n    idx = 0;\n    split = ρσ_orig_split;\n    if (ρσ_str.format._template_resolve_pat === undefined) {\n        ρσ_str.format._template_resolve_pat = /[.\\[]/;\n    }\n    function resolve(arg, object) {\n        var ρσ_unpack, first, key, rest, ans;\n        if (!arg) {\n            return object;\n        }\n        ρσ_unpack = [arg[0], arg.slice(1)];\n        first = ρσ_unpack[0];\n        arg = ρσ_unpack[1];\n        key = split(arg, ρσ_str.format._template_resolve_pat, 1)[0];\n        rest = arg.slice(key.length);\n        ans = (first === \"[\") ? object[ρσ_bound_index(key.slice(0, -1), object)] : getattr(object, key);\n        if (ans === undefined) {\n            throw new KeyError((first === \"[\") ? key.slice(0, -1) : key);\n        }\n        return resolve(rest, ans);\n    };\n    if (!resolve.__argnames__) Object.defineProperties(resolve, {\n        __argnames__ : {value: [\"arg\", \"object\"]}\n    });\n\n    function resolve_format_spec(format_spec) {\n        if (ρσ_str.format._template_resolve_fs_pat === undefined) {\n            ρσ_str.format._template_resolve_fs_pat = /[{]([a-zA-Z0-9_]+)[}]/g;\n        }\n        return format_spec.replace(ρσ_str.format._template_resolve_fs_pat, (function() {\n            var ρσ_anonfunc = function (match, key) {\n                if (!Object.prototype.hasOwnProperty.call(kwargs, key)) {\n                    return \"\";\n                }\n                return \"\" + kwargs[(typeof key === \"number\" && key < 0) ? kwargs.length + key : key];\n            };\n            if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                __argnames__ : {value: [\"match\", \"key\"]}\n            });\n            return ρσ_anonfunc;\n        })());\n    };\n    if (!resolve_format_spec.__argnames__) Object.defineProperties(resolve_format_spec, {\n        __argnames__ : {value: [\"format_spec\"]}\n    });\n\n    function apply_formatting(value, format_spec) {\n        var ρσ_unpack, fill, align, sign, fhash, zeropad, width, comma, precision, ftype, is_numeric, is_int, lftype, code, exp, nval, is_positive, left, right;\n        if (format_spec.indexOf(\"{\") !== -1) {\n            format_spec = resolve_format_spec(format_spec);\n        }\n        if (ρσ_str.format._template_format_pat === undefined) {\n            ρσ_str.format._template_format_pat = /([^{}](?=[<>=^]))?([<>=^])?([-+\\x20])?(\\#)?(0)?(\\d+)?(,)?(?:\\.(\\d+))?([bcdeEfFgGnosxX%])?/;\n        }\n        try {\n            ρσ_unpack = format_spec.match(ρσ_str.format._template_format_pat).slice(1);\nρσ_unpack = ρσ_unpack_asarray(9, ρσ_unpack);\n            fill = ρσ_unpack[0];\n            align = ρσ_unpack[1];\n            sign = ρσ_unpack[2];\n            fhash = ρσ_unpack[3];\n            zeropad = ρσ_unpack[4];\n            width = ρσ_unpack[5];\n            comma = ρσ_unpack[6];\n            precision = ρσ_unpack[7];\n            ftype = ρσ_unpack[8];\n        } catch (ρσ_Exception) {\n            ρσ_last_exception = ρσ_Exception;\n            if (ρσ_Exception instanceof TypeError) {\n                return value;\n            } else {\n                throw ρσ_Exception;\n            }\n        }\n        if (zeropad) {\n            fill = fill || \"0\";\n            align = align || \"=\";\n        } else {\n            fill = fill || \" \";\n            align = align || \">\";\n        }\n        is_numeric = Number(value) === value;\n        is_int = is_numeric && value % 1 === 0;\n        precision = parseInt(precision, 10);\n        lftype = (ftype || \"\").toLowerCase();\n        if (ftype === \"n\") {\n            is_numeric = true;\n            if (is_int) {\n                if (comma) {\n                    throw new ValueError(\"Cannot specify ',' with 'n'\");\n                }\n                value = parseInt(value, 10).toLocaleString();\n            } else {\n                value = parseFloat(value).toLocaleString();\n            }\n        } else if (['b', 'c', 'd', 'o', 'x'].indexOf(lftype) !== -1) {\n            value = parseInt(value, 10);\n            is_numeric = true;\n            if (!isNaN(value)) {\n                if (ftype === \"b\") {\n                    value = (value >>> 0).toString(2);\n                    if (fhash) {\n                        value = \"0b\" + value;\n                    }\n                } else if (ftype === \"c\") {\n                    if (value > 65535) {\n                        code = value - 65536;\n                        value = String.fromCharCode(55296 + (code >> 10), 56320 + (code & 1023));\n                    } else {\n                        value = String.fromCharCode(value);\n                    }\n                } else if (ftype === \"d\") {\n                    if (comma) {\n                        value = value.toLocaleString(\"en-US\");\n                    } else {\n                        value = value.toString(10);\n                    }\n                } else if (ftype === \"o\") {\n                    value = value.toString(8);\n                    if (fhash) {\n                        value = \"0o\" + value;\n                    }\n                } else if (lftype === \"x\") {\n                    value = value.toString(16);\n                    value = (ftype === \"x\") ? value.toLowerCase() : value.toUpperCase();\n                    if (fhash) {\n                        value = \"0x\" + value;\n                    }\n                }\n            }\n        } else if (['e','f','g','%'].indexOf(lftype) !== -1) {\n            is_numeric = true;\n            value = parseFloat(value);\n            if (lftype === \"e\") {\n                value = value.toExponential((isNaN(precision)) ? 6 : precision);\n                value = (ftype === \"E\") ? value.toUpperCase() : value.toLowerCase();\n            } else if (lftype === \"f\") {\n                value = value.toFixed((isNaN(precision)) ? 6 : precision);\n                value = (ftype === \"F\") ? value.toUpperCase() : value.toLowerCase();\n            } else if (ftype === \"%\") {\n                value *= 100;\n                value = value.toFixed((isNaN(precision)) ? 6 : precision) + \"%\";\n            } else if (lftype === \"g\") {\n                if (isNaN(precision)) {\n                    precision = 6;\n                }\n                precision = max(1, precision);\n                exp = parseInt(split(value.toExponential(precision - 1).toLowerCase(), \"e\")[1], 10);\n                if (-4 <= exp && exp < precision) {\n                    value = value.toFixed(precision - 1 - exp);\n                } else {\n                    value = value.toExponential(precision - 1);\n                }\n                value = value.replace(/0+$/g, \"\");\n                if (value[value.length-1] === \".\") {\n                    value = value.slice(0, -1);\n                }\n                if (ftype === \"G\") {\n                    value = value.toUpperCase();\n                }\n            }\n        } else {\n            value += \"\";\n            if (!isNaN(precision)) {\n                value = value.slice(0, precision);\n            }\n        }\n        value += \"\";\n        if (is_numeric && sign) {\n            nval = Number(value);\n            is_positive = !isNaN(nval) && nval >= 0;\n            if (is_positive && (sign === \" \" || sign === \"+\")) {\n                value = sign + value;\n            }\n        }\n        function repeat(char, num) {\n            return (new Array(num+1)).join(char);\n        };\n        if (!repeat.__argnames__) Object.defineProperties(repeat, {\n            __argnames__ : {value: [\"char\", \"num\"]}\n        });\n\n        if (is_numeric && width && width[0] === \"0\") {\n            width = width.slice(1);\n            ρσ_unpack = [\"0\", \"=\"];\n            fill = ρσ_unpack[0];\n            align = ρσ_unpack[1];\n        }\n        width = parseInt(width || \"-1\", 10);\n        if (isNaN(width)) {\n            throw new ValueError(\"Invalid width specification: \" + width);\n        }\n        if (fill && value.length < width) {\n            if (align === \"<\") {\n                value = value + repeat(fill, width - value.length);\n            } else if (align === \">\") {\n                value = repeat(fill, width - value.length) + value;\n            } else if (align === \"^\") {\n                left = Math.floor((width - value.length) / 2);\n                right = width - left - value.length;\n                value = repeat(fill, left) + value + repeat(fill, right);\n            } else if (align === \"=\") {\n                if (ρσ_in(value[0], \"+- \")) {\n                    value = value[0] + repeat(fill, width - value.length) + value.slice(1);\n                } else {\n                    value = repeat(fill, width - value.length) + value;\n                }\n            } else {\n                throw new ValueError(\"Unrecognized alignment: \" + align);\n            }\n        }\n        return value;\n    };\n    if (!apply_formatting.__argnames__) Object.defineProperties(apply_formatting, {\n        __argnames__ : {value: [\"value\", \"format_spec\"]}\n    });\n\n    function parse_markup(markup) {\n        var key, transformer, format_spec, pos, state, ch;\n        key = transformer = format_spec = \"\";\n        pos = 0;\n        state = 0;\n        while (pos < markup.length) {\n            ch = markup[(typeof pos === \"number\" && pos < 0) ? markup.length + pos : pos];\n            if (state === 0) {\n                if (ch === \"!\") {\n                    state = 1;\n                } else if (ch === \":\") {\n                    state = 2;\n                } else {\n                    key += ch;\n                }\n            } else if (state === 1) {\n                if (ch === \":\") {\n                    state = 2;\n                } else {\n                    transformer += ch;\n                }\n            } else {\n                format_spec += ch;\n            }\n            pos += 1;\n        }\n        return [key, transformer, format_spec];\n    };\n    if (!parse_markup.__argnames__) Object.defineProperties(parse_markup, {\n        __argnames__ : {value: [\"markup\"]}\n    });\n\n    function render_markup(markup) {\n        var ρσ_unpack, key, transformer, format_spec, lkey, nvalue, object, ans;\n        ρσ_unpack = parse_markup(markup);\nρσ_unpack = ρσ_unpack_asarray(3, ρσ_unpack);\n        key = ρσ_unpack[0];\n        transformer = ρσ_unpack[1];\n        format_spec = ρσ_unpack[2];\n        if (transformer && ['a', 'r', 's'].indexOf(transformer) === -1) {\n            throw new ValueError(\"Unknown conversion specifier: \" + transformer);\n        }\n        lkey = key.length && split(key, /[.\\[]/, 1)[0];\n        if (lkey) {\n            explicit = true;\n            if (implicit) {\n                throw new ValueError(\"cannot switch from automatic field numbering to manual field specification\");\n            }\n            nvalue = parseInt(lkey);\n            object = (isNaN(nvalue)) ? kwargs[(typeof lkey === \"number\" && lkey < 0) ? kwargs.length + lkey : lkey] : args[(typeof nvalue === \"number\" && nvalue < 0) ? args.length + nvalue : nvalue];\n            if (object === undefined) {\n                if (isNaN(nvalue)) {\n                    throw new KeyError(lkey);\n                }\n                throw new IndexError(lkey);\n            }\n            object = resolve(key.slice(lkey.length), object);\n        } else {\n            implicit = true;\n            if (explicit) {\n                throw new ValueError(\"cannot switch from manual field specification to automatic field numbering\");\n            }\n            if (idx >= args.length) {\n                throw new IndexError(\"Not enough arguments to match template: \" + template);\n            }\n            object = args[(typeof idx === \"number\" && idx < 0) ? args.length + idx : idx];\n            idx += 1;\n        }\n        if (typeof object === \"function\") {\n            object = object();\n        }\n        ans = \"\" + object;\n        if (format_spec) {\n            ans = apply_formatting(ans, format_spec);\n        }\n        return ans;\n    };\n    if (!render_markup.__argnames__) Object.defineProperties(render_markup, {\n        __argnames__ : {value: [\"markup\"]}\n    });\n\n    ans = \"\";\n    pos = 0;\n    in_brace = 0;\n    markup = \"\";\n    while (pos < template.length) {\n        ch = template[(typeof pos === \"number\" && pos < 0) ? template.length + pos : pos];\n        if (in_brace) {\n            if (ch === \"{\") {\n                in_brace += 1;\n                markup += \"{\";\n            } else if (ch === \"}\") {\n                in_brace -= 1;\n                if (in_brace > 0) {\n                    markup += \"}\";\n                } else {\n                    ans += render_markup(markup);\n                }\n            } else {\n                markup += ch;\n            }\n        } else {\n            if (ch === \"{\") {\n                if (template[ρσ_bound_index(pos + 1, template)] === \"{\") {\n                    pos += 1;\n                    ans += \"{\";\n                } else {\n                    in_brace = 1;\n                    markup = \"\";\n                }\n            } else {\n                ans += ch;\n                if (ch === \"}\" && template[ρσ_bound_index(pos + 1, template)] === \"}\") {\n                    pos += 1;\n                }\n            }\n        }\n        pos += 1;\n    }\n    if (in_brace) {\n        throw new ValueError(\"expected '}' before end of string\");\n    }\n    return ans;\n});\ndefine_str_func(\"capitalize\", function () {\n    var string;\n    string = this;\n    if (string) {\n        string = string[0].toUpperCase() + string.slice(1).toLowerCase();\n    }\n    return string;\n});\ndefine_str_func(\"center\", (function() {\n    var ρσ_anonfunc = function (width, fill) {\n        var left, right;\n        left = Math.floor((width - this.length) / 2);\n        right = width - left - this.length;\n        fill = fill || \" \";\n        return new Array(left+1).join(fill) + this + new Array(right+1).join(fill);\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"width\", \"fill\"]}\n    });\n    return ρσ_anonfunc;\n})());\ndefine_str_func(\"count\", (function() {\n    var ρσ_anonfunc = function (needle, start, end) {\n        var string, ρσ_unpack, pos, step, ans;\n        string = this;\n        start = start || 0;\n        end = end || string.length;\n        if (start < 0 || end < 0) {\n            string = string.slice(start, end);\n            ρσ_unpack = [0, string.length];\n            start = ρσ_unpack[0];\n            end = ρσ_unpack[1];\n        }\n        pos = start;\n        step = needle.length;\n        if (!step) {\n            return 0;\n        }\n        ans = 0;\n        while (pos !== -1) {\n            pos = string.indexOf(needle, pos);\n            if (pos !== -1) {\n                ans += 1;\n                pos += step;\n            }\n        }\n        return ans;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"needle\", \"start\", \"end\"]}\n    });\n    return ρσ_anonfunc;\n})());\ndefine_str_func(\"endswith\", (function() {\n    var ρσ_anonfunc = function (suffixes, start, end) {\n        var string, q;\n        string = this;\n        start = start || 0;\n        if (typeof suffixes === \"string\") {\n            suffixes = [suffixes];\n        }\n        if (end !== undefined) {\n            string = string.slice(0, end);\n        }\n        for (var i = 0; i < suffixes.length; i++) {\n            q = suffixes[(typeof i === \"number\" && i < 0) ? suffixes.length + i : i];\n            if (string.indexOf(q, Math.max(start, string.length - q.length)) !== -1) {\n                return true;\n            }\n        }\n        return false;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"suffixes\", \"start\", \"end\"]}\n    });\n    return ρσ_anonfunc;\n})());\ndefine_str_func(\"startswith\", (function() {\n    var ρσ_anonfunc = function (prefixes, start, end) {\n        var prefix;\n        start = start || 0;\n        if (typeof prefixes === \"string\") {\n            prefixes = [prefixes];\n        }\n        for (var i = 0; i < prefixes.length; i++) {\n            prefix = prefixes[(typeof i === \"number\" && i < 0) ? prefixes.length + i : i];\n            end = (end === undefined) ? this.length : end;\n            if (end - start >= prefix.length && prefix === this.slice(start, start + prefix.length)) {\n                return true;\n            }\n        }\n        return false;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"prefixes\", \"start\", \"end\"]}\n    });\n    return ρσ_anonfunc;\n})());\ndefine_str_func(\"find\", (function() {\n    var ρσ_anonfunc = function (needle, start, end) {\n        var ans;\n        while (start < 0) {\n            start += this.length;\n        }\n        ans = this.indexOf(needle, start);\n        if (end !== undefined && ans !== -1) {\n            while (end < 0) {\n                end += this.length;\n            }\n            if (ans >= end - needle.length) {\n                return -1;\n            }\n        }\n        return ans;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"needle\", \"start\", \"end\"]}\n    });\n    return ρσ_anonfunc;\n})());\ndefine_str_func(\"rfind\", (function() {\n    var ρσ_anonfunc = function (needle, start, end) {\n        var ans;\n        while (end < 0) {\n            end += this.length;\n        }\n        ans = this.lastIndexOf(needle, end - 1);\n        if (start !== undefined && ans !== -1) {\n            while (start < 0) {\n                start += this.length;\n            }\n            if (ans < start) {\n                return -1;\n            }\n        }\n        return ans;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"needle\", \"start\", \"end\"]}\n    });\n    return ρσ_anonfunc;\n})());\ndefine_str_func(\"index\", (function() {\n    var ρσ_anonfunc = function (needle, start, end) {\n        var ans;\n        ans = ρσ_str.prototype.find.apply(this, arguments);\n        if (ans === -1) {\n            throw new ValueError(\"substring not found\");\n        }\n        return ans;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"needle\", \"start\", \"end\"]}\n    });\n    return ρσ_anonfunc;\n})());\ndefine_str_func(\"rindex\", (function() {\n    var ρσ_anonfunc = function (needle, start, end) {\n        var ans;\n        ans = ρσ_str.prototype.rfind.apply(this, arguments);\n        if (ans === -1) {\n            throw new ValueError(\"substring not found\");\n        }\n        return ans;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"needle\", \"start\", \"end\"]}\n    });\n    return ρσ_anonfunc;\n})());\ndefine_str_func(\"islower\", function () {\n    return this.length > 0 && this.toLowerCase() === this.toString();\n});\ndefine_str_func(\"isupper\", function () {\n    return this.length > 0 && this.toUpperCase() === this.toString();\n});\ndefine_str_func(\"isspace\", function () {\n    return this.length > 0 && /^\\s+$/.test(this);\n});\ndefine_str_func(\"join\", (function() {\n    var ρσ_anonfunc = function (iterable) {\n        var ans, r;\n        if (Array.isArray(iterable)) {\n            return iterable.join(this);\n        }\n        ans = \"\";\n        r = iterable.next();\n        while (!r.done) {\n            if (ans) {\n                ans += this;\n            }\n            ans += r.value;\n            r = iterable.next();\n        }\n        return ans;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"iterable\"]}\n    });\n    return ρσ_anonfunc;\n})());\ndefine_str_func(\"ljust\", (function() {\n    var ρσ_anonfunc = function (width, fill) {\n        var string;\n        string = this;\n        if (width > string.length) {\n            fill = fill || \" \";\n            string += new Array(width - string.length + 1).join(fill);\n        }\n        return string;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"width\", \"fill\"]}\n    });\n    return ρσ_anonfunc;\n})());\ndefine_str_func(\"rjust\", (function() {\n    var ρσ_anonfunc = function (width, fill) {\n        var string;\n        string = this;\n        if (width > string.length) {\n            fill = fill || \" \";\n            string = new Array(width - string.length + 1).join(fill) + string;\n        }\n        return string;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"width\", \"fill\"]}\n    });\n    return ρσ_anonfunc;\n})());\ndefine_str_func(\"lower\", function () {\n    return this.toLowerCase();\n});\ndefine_str_func(\"upper\", function () {\n    return this.toUpperCase();\n});\ndefine_str_func(\"lstrip\", (function() {\n    var ρσ_anonfunc = function (chars) {\n        var string, pos;\n        string = this;\n        pos = 0;\n        chars = chars || ρσ_str.whitespace;\n        while (chars.indexOf(string[(typeof pos === \"number\" && pos < 0) ? string.length + pos : pos]) !== -1) {\n            pos += 1;\n        }\n        if (pos) {\n            string = string.slice(pos);\n        }\n        return string;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"chars\"]}\n    });\n    return ρσ_anonfunc;\n})());\ndefine_str_func(\"rstrip\", (function() {\n    var ρσ_anonfunc = function (chars) {\n        var string, pos;\n        string = this;\n        pos = string.length - 1;\n        chars = chars || ρσ_str.whitespace;\n        while (chars.indexOf(string[(typeof pos === \"number\" && pos < 0) ? string.length + pos : pos]) !== -1) {\n            pos -= 1;\n        }\n        if (pos < string.length - 1) {\n            string = string.slice(0, pos + 1);\n        }\n        return string;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"chars\"]}\n    });\n    return ρσ_anonfunc;\n})());\ndefine_str_func(\"strip\", (function() {\n    var ρσ_anonfunc = function (chars) {\n        return ρσ_str.prototype.lstrip.call(ρσ_str.prototype.rstrip.call(this, chars), chars);\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"chars\"]}\n    });\n    return ρσ_anonfunc;\n})());\ndefine_str_func(\"partition\", (function() {\n    var ρσ_anonfunc = function (sep) {\n        var idx;\n        idx = this.indexOf(sep);\n        if (idx === -1) {\n            return [this, \"\", \"\"];\n        }\n        return [this.slice(0, idx), sep, this.slice(idx + sep.length)];\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"sep\"]}\n    });\n    return ρσ_anonfunc;\n})());\ndefine_str_func(\"rpartition\", (function() {\n    var ρσ_anonfunc = function (sep) {\n        var idx;\n        idx = this.lastIndexOf(sep);\n        if (idx === -1) {\n            return [\"\", \"\", this];\n        }\n        return [this.slice(0, idx), sep, this.slice(idx + sep.length)];\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"sep\"]}\n    });\n    return ρσ_anonfunc;\n})());\ndefine_str_func(\"replace\", (function() {\n    var ρσ_anonfunc = function (old, repl, count) {\n        var string, pos, idx;\n        string = this;\n        if (count === 1) {\n            return ρσ_orig_replace(string, old, repl);\n        }\n        if (count < 1) {\n            return string;\n        }\n        count = count || Number.MAX_VALUE;\n        pos = 0;\n        while (count > 0) {\n            count -= 1;\n            idx = string.indexOf(old, pos);\n            if (idx === -1) {\n                break;\n            }\n            pos = idx + repl.length;\n            string = string.slice(0, idx) + repl + string.slice(idx + old.length);\n        }\n        return string;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"old\", \"repl\", \"count\"]}\n    });\n    return ρσ_anonfunc;\n})());\ndefine_str_func(\"split\", (function() {\n    var ρσ_anonfunc = function (sep, maxsplit) {\n        var split, ans, extra, parts;\n        if (maxsplit === 0) {\n            return ρσ_list_decorate([ this ]);\n        }\n        split = ρσ_orig_split;\n        if (sep === undefined || sep === null) {\n            if (maxsplit > 0) {\n                ans = split(this, /(\\s+)/);\n                extra = \"\";\n                parts = [];\n                for (var i = 0; i < ans.length; i++) {\n                    if (parts.length >= maxsplit + 1) {\n                        extra += ans[(typeof i === \"number\" && i < 0) ? ans.length + i : i];\n                    } else if (i % 2 === 0) {\n                        parts.push(ans[(typeof i === \"number\" && i < 0) ? ans.length + i : i]);\n                    }\n                }\n                parts[parts.length-1] += extra;\n                ans = parts;\n            } else {\n                ans = split(this, /\\s+/);\n            }\n        } else {\n            if (sep === \"\") {\n                throw new ValueError(\"empty separator\");\n            }\n            ans = split(this, sep);\n            if (maxsplit > 0 && ans.length > maxsplit) {\n                extra = ans.slice(maxsplit).join(sep);\n                ans = ans.slice(0, maxsplit);\n                ans.push(extra);\n            }\n        }\n        return ρσ_list_decorate(ans);\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"sep\", \"maxsplit\"]}\n    });\n    return ρσ_anonfunc;\n})());\ndefine_str_func(\"rsplit\", (function() {\n    var ρσ_anonfunc = function (sep, maxsplit) {\n        var split, ans, is_space, pos, current, spc, ch, end, idx;\n        if (!maxsplit) {\n            return ρσ_str.prototype.split.call(this, sep);\n        }\n        split = ρσ_orig_split;\n        if (sep === undefined || sep === null) {\n            if (maxsplit > 0) {\n                ans = [];\n                is_space = /\\s/;\n                pos = this.length - 1;\n                current = \"\";\n                while (pos > -1 && maxsplit > 0) {\n                    spc = false;\n                    ch = (ρσ_expr_temp = this)[(typeof pos === \"number\" && pos < 0) ? ρσ_expr_temp.length + pos : pos];\n                    while (pos > -1 && is_space.test(ch)) {\n                        spc = true;\n                        ch = this[--pos];\n                    }\n                    if (spc) {\n                        if (current) {\n                            ans.push(current);\n                            maxsplit -= 1;\n                        }\n                        current = ch;\n                    } else {\n                        current += ch;\n                    }\n                    pos -= 1;\n                }\n                ans.push(this.slice(0, pos + 1) + current);\n                ans.reverse();\n            } else {\n                ans = split(this, /\\s+/);\n            }\n        } else {\n            if (sep === \"\") {\n                throw new ValueError(\"empty separator\");\n            }\n            ans = [];\n            pos = end = this.length;\n            while (pos > -1 && maxsplit > 0) {\n                maxsplit -= 1;\n                idx = this.lastIndexOf(sep, pos);\n                if (idx === -1) {\n                    break;\n                }\n                ans.push(this.slice(idx + sep.length, end));\n                pos = idx - 1;\n                end = idx;\n            }\n            ans.push(this.slice(0, end));\n            ans.reverse();\n        }\n        return ρσ_list_decorate(ans);\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"sep\", \"maxsplit\"]}\n    });\n    return ρσ_anonfunc;\n})());\ndefine_str_func(\"splitlines\", (function() {\n    var ρσ_anonfunc = function (keepends) {\n        var split, parts, ans;\n        split = ρσ_orig_split;\n        if (keepends) {\n            parts = split(this, /((?:\\r?\\n)|\\r)/);\n            ans = [];\n            for (var i = 0; i < parts.length; i++) {\n                if (i % 2 === 0) {\n                    ans.push(parts[(typeof i === \"number\" && i < 0) ? parts.length + i : i]);\n                } else {\n                    ans[ans.length-1] += parts[(typeof i === \"number\" && i < 0) ? parts.length + i : i];\n                }\n            }\n        } else {\n            ans = split(this, /(?:\\r?\\n)|\\r/);\n        }\n        return ρσ_list_decorate(ans);\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"keepends\"]}\n    });\n    return ρσ_anonfunc;\n})());\ndefine_str_func(\"swapcase\", function () {\n    var ans, a, b;\n    ans = new Array(this.length);\n    for (var i = 0; i < ans.length; i++) {\n        a = (ρσ_expr_temp = this)[(typeof i === \"number\" && i < 0) ? ρσ_expr_temp.length + i : i];\n        b = a.toLowerCase();\n        if (a === b) {\n            b = a.toUpperCase();\n        }\n        ans[(typeof i === \"number\" && i < 0) ? ans.length + i : i] = b;\n    }\n    return ans.join(\"\");\n});\ndefine_str_func(\"zfill\", (function() {\n    var ρσ_anonfunc = function (width) {\n        var string;\n        string = this;\n        if (width > string.length) {\n            string = new Array(width - string.length + 1).join(\"0\") + string;\n        }\n        return string;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"width\"]}\n    });\n    return ρσ_anonfunc;\n})());\nρσ_str.uchrs = (function() {\n    var ρσ_anonfunc = function (string, with_positions) {\n        return (function(){\n            var ρσ_d = {};\n            ρσ_d[\"_string\"] = string;\n            ρσ_d[\"_pos\"] = 0;\n            ρσ_d[ρσ_iterator_symbol] = function () {\n                return this;\n            };\n            ρσ_d[\"next\"] = function () {\n                var length, pos, value, ans, extra;\n                length = this._string.length;\n                if (this._pos >= length) {\n                    return (function(){\n                        var ρσ_d = {};\n                        ρσ_d[\"done\"] = true;\n                        return ρσ_d;\n                    }).call(this);\n                }\n                pos = this._pos;\n                value = this._string.charCodeAt(this._pos++);\n                ans = \"\\ufffd\";\n                if (55296 <= value && value <= 56319) {\n                    if (this._pos < length) {\n                        extra = this._string.charCodeAt(this._pos++);\n                        if ((extra & 56320) === 56320) {\n                            ans = String.fromCharCode(value, extra);\n                        }\n                    }\n                } else if ((value & 56320) !== 56320) {\n                    ans = String.fromCharCode(value);\n                }\n                if (with_positions) {\n                    return (function(){\n                        var ρσ_d = {};\n                        ρσ_d[\"done\"] = false;\n                        ρσ_d[\"value\"] = ρσ_list_decorate([ pos, ans ]);\n                        return ρσ_d;\n                    }).call(this);\n                } else {\n                    return (function(){\n                        var ρσ_d = {};\n                        ρσ_d[\"done\"] = false;\n                        ρσ_d[\"value\"] = ans;\n                        return ρσ_d;\n                    }).call(this);\n                }\n            };\n            return ρσ_d;\n        }).call(this);\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"string\", \"with_positions\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_str.uslice = (function() {\n    var ρσ_anonfunc = function (string, start, end) {\n        var items, iterator, r;\n        items = [];\n        iterator = ρσ_str.uchrs(string);\n        r = iterator.next();\n        while (!r.done) {\n            items.push(r.value);\n            r = iterator.next();\n        }\n        return items.slice(start || 0, (end === undefined) ? items.length : end).join(\"\");\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"string\", \"start\", \"end\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_str.ulen = (function() {\n    var ρσ_anonfunc = function (string) {\n        var iterator, r, ans;\n        iterator = ρσ_str.uchrs(string);\n        r = iterator.next();\n        ans = 0;\n        while (!r.done) {\n            r = iterator.next();\n            ans += 1;\n        }\n        return ans;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"string\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_str.ascii_lowercase = \"abcdefghijklmnopqrstuvwxyz\";\nρσ_str.ascii_uppercase = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\nρσ_str.ascii_letters = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\nρσ_str.digits = \"0123456789\";\nρσ_str.punctuation = \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\";\nρσ_str.printable = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~ \\t\\n\\r\\u000b\\f\";\nρσ_str.whitespace = \" \\t\\n\\r\\u000b\\f\";\ndefine_str_func = undefined;\nvar str = ρσ_str, repr = ρσ_repr;;\n    var ρσ_modules = {};\n    ρσ_modules.utils = {};\n    ρσ_modules.errors = {};\n    ρσ_modules.unicode_aliases = {};\n    ρσ_modules.ast = {};\n    ρσ_modules.string_interpolation = {};\n    ρσ_modules.tokenizer = {};\n    ρσ_modules.parse = {};\n    ρσ_modules.output = {};\n    ρσ_modules[\"output.stream\"] = {};\n    ρσ_modules[\"output.statements\"] = {};\n    ρσ_modules[\"output.exceptions\"] = {};\n    ρσ_modules[\"output.utils\"] = {};\n    ρσ_modules[\"output.loops\"] = {};\n    ρσ_modules[\"output.operators\"] = {};\n    ρσ_modules[\"output.functions\"] = {};\n    ρσ_modules[\"output.classes\"] = {};\n    ρσ_modules[\"output.literals\"] = {};\n    ρσ_modules[\"output.modules\"] = {};\n    ρσ_modules[\"output.codegen\"] = {};\n\n    (function(){\n        var __name__ = \"utils\";\n        var has_prop, MAP;\n        has_prop = Object.prototype.hasOwnProperty.call.bind(Object.prototype.hasOwnProperty);\n        function array_to_hash(a) {\n            var ret, i;\n            ret = Object.create(null);\n            var ρσ_Iter0 = ρσ_Iterable(range(len(a)));\n            for (var ρσ_Index0 = 0; ρσ_Index0 < ρσ_Iter0.length; ρσ_Index0++) {\n                i = ρσ_Iter0[ρσ_Index0];\n                ret[ρσ_bound_index(a[(typeof i === \"number\" && i < 0) ? a.length + i : i], ret)] = true;\n            }\n            return ret;\n        };\n        if (!array_to_hash.__argnames__) Object.defineProperties(array_to_hash, {\n            __argnames__ : {value: [\"a\"]}\n        });\n\n        function slice(a, start) {\n            return Array.prototype.slice.call(a, start || 0);\n        };\n        if (!slice.__argnames__) Object.defineProperties(slice, {\n            __argnames__ : {value: [\"a\", \"start\"]}\n        });\n\n        function characters(str_) {\n            return str_.split(\"\");\n        };\n        if (!characters.__argnames__) Object.defineProperties(characters, {\n            __argnames__ : {value: [\"str_\"]}\n        });\n\n        function member(name, array) {\n            var i;\n            for (var ρσ_Index1 = array.length - 1; ρσ_Index1 > -1; ρσ_Index1-=1) {\n                i = ρσ_Index1;\n                if (array[(typeof i === \"number\" && i < 0) ? array.length + i : i] === name) {\n                    return true;\n                }\n            }\n            return false;\n        };\n        if (!member.__argnames__) Object.defineProperties(member, {\n            __argnames__ : {value: [\"name\", \"array\"]}\n        });\n\n        function repeat_string(str_, i) {\n            var d;\n            if (i <= 0) {\n                return \"\";\n            }\n            if (i === 1) {\n                return str_;\n            }\n            d = repeat_string(str_, i >> 1);\n            d += d;\n            if (i & 1) {\n                d += str_;\n            }\n            return d;\n        };\n        if (!repeat_string.__argnames__) Object.defineProperties(repeat_string, {\n            __argnames__ : {value: [\"str_\", \"i\"]}\n        });\n\n        function DefaultsError() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            DefaultsError.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(DefaultsError, ValueError);\n        DefaultsError.prototype.__init__ = function __init__(name, defs) {\n            var self = this;\n            ValueError.prototype.__init__.call(self, name + \" is not a supported option. Supported options are: \" + str(Object.keys(defs)));\n        };\n        if (!DefaultsError.prototype.__init__.__argnames__) Object.defineProperties(DefaultsError.prototype.__init__, {\n            __argnames__ : {value: [\"name\", \"defs\"]}\n        });\n        DefaultsError.__argnames__ = DefaultsError.prototype.__init__.__argnames__;\n        DefaultsError.__handles_kwarg_interpolation__ = DefaultsError.prototype.__init__.__handles_kwarg_interpolation__;\n        DefaultsError.prototype.__repr__ = function __repr__ () {\n            if(ValueError.prototype.__repr__) return ValueError.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        DefaultsError.prototype.__str__ = function __str__ () {\n            if(ValueError.prototype.__str__) return ValueError.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(DefaultsError.prototype, \"__bases__\", {value: [ValueError]});\n\n        function defaults(args, defs, croak) {\n            var ret, i;\n            if (args === true) {\n                args = Object.create(null);\n            }\n            ret = args || Object.create(null);\n            if (croak) {\n                var ρσ_Iter2 = ρσ_Iterable(ret);\n                for (var ρσ_Index2 = 0; ρσ_Index2 < ρσ_Iter2.length; ρσ_Index2++) {\n                    i = ρσ_Iter2[ρσ_Index2];\n                    if (!has_prop(defs, i)) {\n                        throw new DefaultsError(i, defs);\n                    }\n                }\n            }\n            var ρσ_Iter3 = ρσ_Iterable(defs);\n            for (var ρσ_Index3 = 0; ρσ_Index3 < ρσ_Iter3.length; ρσ_Index3++) {\n                i = ρσ_Iter3[ρσ_Index3];\n                ret[(typeof i === \"number\" && i < 0) ? ret.length + i : i] = (args && has_prop(args, i)) ? args[(typeof i === \"number\" && i < 0) ? args.length + i : i] : defs[(typeof i === \"number\" && i < 0) ? defs.length + i : i];\n            }\n            return ret;\n        };\n        if (!defaults.__argnames__) Object.defineProperties(defaults, {\n            __argnames__ : {value: [\"args\", \"defs\", \"croak\"]}\n        });\n\n        function merge(obj, ext) {\n            var i;\n            var ρσ_Iter4 = ρσ_Iterable(ext);\n            for (var ρσ_Index4 = 0; ρσ_Index4 < ρσ_Iter4.length; ρσ_Index4++) {\n                i = ρσ_Iter4[ρσ_Index4];\n                obj[(typeof i === \"number\" && i < 0) ? obj.length + i : i] = ext[(typeof i === \"number\" && i < 0) ? ext.length + i : i];\n            }\n            return obj;\n        };\n        if (!merge.__argnames__) Object.defineProperties(merge, {\n            __argnames__ : {value: [\"obj\", \"ext\"]}\n        });\n\n        function noop() {\n        };\n\n        MAP = function () {\n            var skip;\n            function MAP(a, f, backwards) {\n                var ret, top, i;\n                ret = ρσ_list_decorate([]);\n                top = ρσ_list_decorate([]);\n                function doit() {\n                    var val, is_last;\n                    val = f(a[(typeof i === \"number\" && i < 0) ? a.length + i : i], i);\n                    is_last = ρσ_instanceof(val, Last);\n                    if (is_last) {\n                        val = val.v;\n                    }\n                    if (ρσ_instanceof(val, AtTop)) {\n                        val = val.v;\n                        if (ρσ_instanceof(val, Splice)) {\n                            top.push.apply(top, (backwards) ? val.v.slice().reverse() : val.v);\n                        } else {\n                            top.push(val);\n                        }\n                    } else if (val !== skip) {\n                        if (ρσ_instanceof(val, Splice)) {\n                            ret.push.apply(ret, (backwards) ? val.v.slice().reverse() : val.v);\n                        } else {\n                            ret.push(val);\n                        }\n                    }\n                    return is_last;\n                };\n\n                if (Array.isArray(a)) {\n                    if (backwards) {\n                        for (var ρσ_Index5 = a.length - 1; ρσ_Index5 > -1; ρσ_Index5-=1) {\n                            i = ρσ_Index5;\n                            if (doit()) {\n                                break;\n                            }\n                        }\n                        ret.reverse();\n                        top.reverse();\n                    } else {\n                        var ρσ_Iter6 = ρσ_Iterable(range(len(a)));\n                        for (var ρσ_Index6 = 0; ρσ_Index6 < ρσ_Iter6.length; ρσ_Index6++) {\n                            i = ρσ_Iter6[ρσ_Index6];\n                            if (doit()) {\n                                break;\n                            }\n                        }\n                    }\n                } else {\n                    var ρσ_Iter7 = ρσ_Iterable(a);\n                    for (var ρσ_Index7 = 0; ρσ_Index7 < ρσ_Iter7.length; ρσ_Index7++) {\n                        i = ρσ_Iter7[ρσ_Index7];\n                        if (doit()) {\n                            break;\n                        }\n                    }\n                }\n                return top.concat(ret);\n            };\n            if (!MAP.__argnames__) Object.defineProperties(MAP, {\n                __argnames__ : {value: [\"a\", \"f\", \"backwards\"]}\n            });\n\n            MAP.at_top = (function() {\n                var ρσ_anonfunc = function (val) {\n                    return new AtTop(val);\n                };\n                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                    __argnames__ : {value: [\"val\"]}\n                });\n                return ρσ_anonfunc;\n            })();\n            MAP.splice = (function() {\n                var ρσ_anonfunc = function (val) {\n                    return new Splice(val);\n                };\n                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                    __argnames__ : {value: [\"val\"]}\n                });\n                return ρσ_anonfunc;\n            })();\n            MAP.last = (function() {\n                var ρσ_anonfunc = function (val) {\n                    return new Last(val);\n                };\n                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                    __argnames__ : {value: [\"val\"]}\n                });\n                return ρσ_anonfunc;\n            })();\n            skip = MAP.skip = Object.create(null);\n            function AtTop(val) {\n                this.v = val;\n            };\n            if (!AtTop.__argnames__) Object.defineProperties(AtTop, {\n                __argnames__ : {value: [\"val\"]}\n            });\n\n            function Splice(val) {\n                this.v = val;\n            };\n            if (!Splice.__argnames__) Object.defineProperties(Splice, {\n                __argnames__ : {value: [\"val\"]}\n            });\n\n            function Last(val) {\n                this.v = val;\n            };\n            if (!Last.__argnames__) Object.defineProperties(Last, {\n                __argnames__ : {value: [\"val\"]}\n            });\n\n            return MAP;\n        }.call(this);\n        function push_uniq(array, el) {\n            if (array.indexOf(el) < 0) {\n                array.push(el);\n            }\n        };\n        if (!push_uniq.__argnames__) Object.defineProperties(push_uniq, {\n            __argnames__ : {value: [\"array\", \"el\"]}\n        });\n\n        function string_template(text, props) {\n            return text.replace(/\\{(.+?)\\}/g, (function() {\n                var ρσ_anonfunc = function (str_, p) {\n                    return props[(typeof p === \"number\" && p < 0) ? props.length + p : p];\n                };\n                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                    __argnames__ : {value: [\"str_\", \"p\"]}\n                });\n                return ρσ_anonfunc;\n            })());\n        };\n        if (!string_template.__argnames__) Object.defineProperties(string_template, {\n            __argnames__ : {value: [\"text\", \"props\"]}\n        });\n\n        function remove(array, el) {\n            var i;\n            for (var ρσ_Index8 = array.length - 1; ρσ_Index8 > -1; ρσ_Index8-=1) {\n                i = ρσ_Index8;\n                if (array[(typeof i === \"number\" && i < 0) ? array.length + i : i] === el) {\n                    array.splice(i, 1);\n                }\n            }\n        };\n        if (!remove.__argnames__) Object.defineProperties(remove, {\n            __argnames__ : {value: [\"array\", \"el\"]}\n        });\n\n        function mergeSort(array, cmp) {\n            if (array.length < 2) {\n                return array.slice();\n            }\n            function merge(a, b) {\n                var r, ai, bi, i;\n                r = ρσ_list_decorate([]);\n                ai = 0;\n                bi = 0;\n                i = 0;\n                while (ai < a.length && bi < b.length) {\n                    if (cmp(a[(typeof ai === \"number\" && ai < 0) ? a.length + ai : ai], b[(typeof bi === \"number\" && bi < 0) ? b.length + bi : bi]) <= 0) {\n                        r[(typeof i === \"number\" && i < 0) ? r.length + i : i] = a[(typeof ai === \"number\" && ai < 0) ? a.length + ai : ai];\n                        ai += 1;\n                    } else {\n                        r[(typeof i === \"number\" && i < 0) ? r.length + i : i] = b[(typeof bi === \"number\" && bi < 0) ? b.length + bi : bi];\n                        bi += 1;\n                    }\n                    i += 1;\n                }\n                if (ai < a.length) {\n                    r.push.apply(r, a.slice(ai));\n                }\n                if (bi < b.length) {\n                    r.push.apply(r, b.slice(bi));\n                }\n                return r;\n            };\n            if (!merge.__argnames__) Object.defineProperties(merge, {\n                __argnames__ : {value: [\"a\", \"b\"]}\n            });\n\n            function _ms(a) {\n                var m, left, right;\n                if (a.length <= 1) {\n                    return a;\n                }\n                m = Math.floor(a.length / 2);\n                left = a.slice(0, m);\n                right = a.slice(m);\n                left = _ms(left);\n                right = _ms(right);\n                return merge(left, right);\n            };\n            if (!_ms.__argnames__) Object.defineProperties(_ms, {\n                __argnames__ : {value: [\"a\"]}\n            });\n\n            return _ms(array);\n        };\n        if (!mergeSort.__argnames__) Object.defineProperties(mergeSort, {\n            __argnames__ : {value: [\"array\", \"cmp\"]}\n        });\n\n        function set_difference(a, b) {\n            return a.filter((function() {\n                var ρσ_anonfunc = function (el) {\n                    return b.indexOf(el) < 0;\n                };\n                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                    __argnames__ : {value: [\"el\"]}\n                });\n                return ρσ_anonfunc;\n            })());\n        };\n        if (!set_difference.__argnames__) Object.defineProperties(set_difference, {\n            __argnames__ : {value: [\"a\", \"b\"]}\n        });\n\n        function set_intersection(a, b) {\n            return a.filter((function() {\n                var ρσ_anonfunc = function (el) {\n                    return b.indexOf(el) >= 0;\n                };\n                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                    __argnames__ : {value: [\"el\"]}\n                });\n                return ρσ_anonfunc;\n            })());\n        };\n        if (!set_intersection.__argnames__) Object.defineProperties(set_intersection, {\n            __argnames__ : {value: [\"a\", \"b\"]}\n        });\n\n        function make_predicate(words) {\n            var a, k;\n            if (typeof words === \"string\") {\n                words = words.split(\" \");\n            }\n            a = Object.create(null);\n            var ρσ_Iter9 = ρσ_Iterable(words);\n            for (var ρσ_Index9 = 0; ρσ_Index9 < ρσ_Iter9.length; ρσ_Index9++) {\n                k = ρσ_Iter9[ρσ_Index9];\n                a[(typeof k === \"number\" && k < 0) ? a.length + k : k] = true;\n            }\n            return a;\n        };\n        if (!make_predicate.__argnames__) Object.defineProperties(make_predicate, {\n            __argnames__ : {value: [\"words\"]}\n        });\n\n        function cache_file_name(src, cache_dir) {\n            if (cache_dir) {\n                src = str.replace(src, \"\\\\\", \"/\");\n                return cache_dir + \"/\" + str.lstrip(str.replace(src, \"/\", \"-\") + \".json\", \"-\");\n            }\n            return src + \"-cached\";\n        };\n        if (!cache_file_name.__argnames__) Object.defineProperties(cache_file_name, {\n            __argnames__ : {value: [\"src\", \"cache_dir\"]}\n        });\n\n        ρσ_modules.utils.has_prop = has_prop;\n        ρσ_modules.utils.MAP = MAP;\n        ρσ_modules.utils.array_to_hash = array_to_hash;\n        ρσ_modules.utils.slice = slice;\n        ρσ_modules.utils.characters = characters;\n        ρσ_modules.utils.member = member;\n        ρσ_modules.utils.repeat_string = repeat_string;\n        ρσ_modules.utils.DefaultsError = DefaultsError;\n        ρσ_modules.utils.defaults = defaults;\n        ρσ_modules.utils.merge = merge;\n        ρσ_modules.utils.noop = noop;\n        ρσ_modules.utils.push_uniq = push_uniq;\n        ρσ_modules.utils.string_template = string_template;\n        ρσ_modules.utils.remove = remove;\n        ρσ_modules.utils.mergeSort = mergeSort;\n        ρσ_modules.utils.set_difference = set_difference;\n        ρσ_modules.utils.set_intersection = set_intersection;\n        ρσ_modules.utils.make_predicate = make_predicate;\n        ρσ_modules.utils.cache_file_name = cache_file_name;\n    })();\n\n    (function(){\n        var __name__ = \"errors\";\n        function SyntaxError() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            SyntaxError.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(SyntaxError, Error);\n        SyntaxError.prototype.__init__ = function __init__(message, filename, line, col, pos, is_eof) {\n            var self = this;\n            self.stack = (new Error).stack;\n            self.message = message;\n            self.line = line;\n            self.col = col;\n            self.pos = pos;\n            self.is_eof = is_eof;\n            self.filename = filename;\n            self.lineNumber = line;\n            self.fileName = filename;\n        };\n        if (!SyntaxError.prototype.__init__.__argnames__) Object.defineProperties(SyntaxError.prototype.__init__, {\n            __argnames__ : {value: [\"message\", \"filename\", \"line\", \"col\", \"pos\", \"is_eof\"]}\n        });\n        SyntaxError.__argnames__ = SyntaxError.prototype.__init__.__argnames__;\n        SyntaxError.__handles_kwarg_interpolation__ = SyntaxError.prototype.__init__.__handles_kwarg_interpolation__;\n        SyntaxError.prototype.toString = function toString() {\n            var self = this;\n            var ans;\n            ans = self.message + \" (line: \" + self.line + \", col: \" + self.col + \", pos: \" + self.pos + \")\";\n            if (self.filename) {\n                ans = self.filename + \":\" + ans;\n            }\n            if (self.stack) {\n                ans += \"\\n\\n\" + self.stack;\n            }\n            return ans;\n        };\n        if (!SyntaxError.prototype.toString.__argnames__) Object.defineProperties(SyntaxError.prototype.toString, {\n            __argnames__ : {value: []}\n        });\n        SyntaxError.prototype.__repr__ = function __repr__ () {\n            if(Error.prototype.__repr__) return Error.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        SyntaxError.prototype.__str__ = function __str__ () {\n            if(Error.prototype.__str__) return Error.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(SyntaxError.prototype, \"__bases__\", {value: [Error]});\n\n        function ImportError() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            ImportError.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(ImportError, SyntaxError);\n        ImportError.prototype.__init__ = function __init__ () {\n            SyntaxError.prototype.__init__ && SyntaxError.prototype.__init__.apply(this, arguments);\n        };\n        ImportError.prototype.__repr__ = function __repr__ () {\n            if(SyntaxError.prototype.__repr__) return SyntaxError.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        ImportError.prototype.__str__ = function __str__ () {\n            if(SyntaxError.prototype.__str__) return SyntaxError.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(ImportError.prototype, \"__bases__\", {value: [SyntaxError]});\n        \n\n        ρσ_modules.errors.SyntaxError = SyntaxError;\n        ρσ_modules.errors.ImportError = ImportError;\n    })();\n\n    (function(){\n        var __name__ = \"unicode_aliases\";\n        var DB, ALIAS_MAP;\n        DB = \"\\n# NameAliases-8.0.0.txt\\n# Date: 2014-11-19, 01:30:00 GMT [KW, LI]\\n#\\n# This file is a normative contributory data file in the\\n# Unicode Character Database.\\n#\\n# Copyright (c) 2005-2014 Unicode, Inc.\\n# For terms of use, see http://www.unicode.org/terms_of_use.html\\n#\\n# This file defines the formal name aliases for Unicode characters.\\n#\\n# For informative aliases, see NamesList.txt\\n#\\n# The formal name aliases are divided into five types, each with a distinct label.\\n#\\n# Type Labels:\\n#\\n# 1. correction\\n#      Corrections for serious problems in the character names\\n# 2. control\\n#      ISO 6429 names for C0 and C1 control functions, and other\\n#      commonly occurring names for control codes\\n# 3. alternate\\n#      A few widely used alternate names for format characters\\n# 4. figment\\n#      Several documented labels for C1 control code points which\\n#      were never actually approved in any standard\\n# 5. abbreviation\\n#      Commonly occurring abbreviations (or acronyms) for control codes,\\n#      format characters, spaces, and variation selectors\\n#\\n# The formal name aliases are part of the Unicode character namespace, which\\n# includes the character names and the names of named character sequences.\\n# The inclusion of ISO 6429 names and other commonly occurring names and\\n# abbreviations for control codes and format characters as formal name aliases\\n# is to help avoid name collisions between Unicode character names and the\\n# labels which commonly appear in text and/or in implementations such as regex, for\\n# control codes (which for historical reasons have no Unicode character name)\\n# or for format characters.\\n#\\n# For documentation, see NamesList.html and http://www.unicode.org/reports/tr44/\\n#\\n# FORMAT\\n#\\n# Each line has three fields, as described here:\\n#\\n# First field:  Code point\\n# Second field: Alias\\n# Third field:  Type\\n#\\n# The type labels used are defined above. As for property values, comparisons\\n# of type labels should ignore case.\\n#\\n# The type labels can be mapped to other strings for display, if desired.\\n#\\n# In case multiple aliases are assigned, additional aliases\\n# are provided on separate lines. Parsers of this data file should\\n# take note that the same code point can (and does) occur more than once.\\n#\\n# Note that currently the only instances of multiple aliases of the same\\n# type for a single code point are either of type \\\"control\\\" or \\\"abbreviation\\\".\\n# An alias of type \\\"abbreviation\\\" can, in principle, be added for any code\\n# point, although currently aliases of type \\\"correction\\\" do not have\\n# any additional aliases of type \\\"abbreviation\\\". Such relationships\\n# are not enforced by stability policies.\\n#\\n#-----------------------------------------------------------------\\n\\n0000;NULL;control\\n0000;NUL;abbreviation\\n0001;START OF HEADING;control\\n0001;SOH;abbreviation\\n0002;START OF TEXT;control\\n0002;STX;abbreviation\\n0003;END OF TEXT;control\\n0003;ETX;abbreviation\\n0004;END OF TRANSMISSION;control\\n0004;EOT;abbreviation\\n0005;ENQUIRY;control\\n0005;ENQ;abbreviation\\n0006;ACKNOWLEDGE;control\\n0006;ACK;abbreviation\\n\\n# Note that no formal name alias for the ISO 6429 \\\"BELL\\\" is\\n# provided for U+0007, because of the existing name collision\\n# with U+1F514 BELL.\\n\\n0007;ALERT;control\\n0007;BEL;abbreviation\\n\\n0008;BACKSPACE;control\\n0008;BS;abbreviation\\n0009;CHARACTER TABULATION;control\\n0009;HORIZONTAL TABULATION;control\\n0009;HT;abbreviation\\n0009;TAB;abbreviation\\n000A;LINE FEED;control\\n000A;NEW LINE;control\\n000A;END OF LINE;control\\n000A;LF;abbreviation\\n000A;NL;abbreviation\\n000A;EOL;abbreviation\\n000B;LINE TABULATION;control\\n000B;VERTICAL TABULATION;control\\n000B;VT;abbreviation\\n000C;FORM FEED;control\\n000C;FF;abbreviation\\n000D;CARRIAGE RETURN;control\\n000D;CR;abbreviation\\n000E;SHIFT OUT;control\\n000E;LOCKING-SHIFT ONE;control\\n000E;SO;abbreviation\\n000F;SHIFT IN;control\\n000F;LOCKING-SHIFT ZERO;control\\n000F;SI;abbreviation\\n0010;DATA LINK ESCAPE;control\\n0010;DLE;abbreviation\\n0011;DEVICE CONTROL ONE;control\\n0011;DC1;abbreviation\\n0012;DEVICE CONTROL TWO;control\\n0012;DC2;abbreviation\\n0013;DEVICE CONTROL THREE;control\\n0013;DC3;abbreviation\\n0014;DEVICE CONTROL FOUR;control\\n0014;DC4;abbreviation\\n0015;NEGATIVE ACKNOWLEDGE;control\\n0015;NAK;abbreviation\\n0016;SYNCHRONOUS IDLE;control\\n0016;SYN;abbreviation\\n0017;END OF TRANSMISSION BLOCK;control\\n0017;ETB;abbreviation\\n0018;CANCEL;control\\n0018;CAN;abbreviation\\n0019;END OF MEDIUM;control\\n0019;EOM;abbreviation\\n001A;SUBSTITUTE;control\\n001A;SUB;abbreviation\\n001B;ESCAPE;control\\n001B;ESC;abbreviation\\n001C;INFORMATION SEPARATOR FOUR;control\\n001C;FILE SEPARATOR;control\\n001C;FS;abbreviation\\n001D;INFORMATION SEPARATOR THREE;control\\n001D;GROUP SEPARATOR;control\\n001D;GS;abbreviation\\n001E;INFORMATION SEPARATOR TWO;control\\n001E;RECORD SEPARATOR;control\\n001E;RS;abbreviation\\n001F;INFORMATION SEPARATOR ONE;control\\n001F;UNIT SEPARATOR;control\\n001F;US;abbreviation\\n0020;SP;abbreviation\\n007F;DELETE;control\\n007F;DEL;abbreviation\\n\\n# PADDING CHARACTER and HIGH OCTET PRESET represent\\n# architectural concepts initially proposed for early\\n# drafts of ISO/IEC 10646-1. They were never actually\\n# approved or standardized: hence their designation\\n# here as the \\\"figment\\\" type. Formal name aliases\\n# (and corresponding abbreviations) for these code\\n# points are included here because these names leaked\\n# out from the draft documents and were published in\\n# at least one RFC whose names for code points was\\n# implemented in Perl regex expressions.\\n\\n0080;PADDING CHARACTER;figment\\n0080;PAD;abbreviation\\n0081;HIGH OCTET PRESET;figment\\n0081;HOP;abbreviation\\n\\n0082;BREAK PERMITTED HERE;control\\n0082;BPH;abbreviation\\n0083;NO BREAK HERE;control\\n0083;NBH;abbreviation\\n0084;INDEX;control\\n0084;IND;abbreviation\\n0085;NEXT LINE;control\\n0085;NEL;abbreviation\\n0086;START OF SELECTED AREA;control\\n0086;SSA;abbreviation\\n0087;END OF SELECTED AREA;control\\n0087;ESA;abbreviation\\n0088;CHARACTER TABULATION SET;control\\n0088;HORIZONTAL TABULATION SET;control\\n0088;HTS;abbreviation\\n0089;CHARACTER TABULATION WITH JUSTIFICATION;control\\n0089;HORIZONTAL TABULATION WITH JUSTIFICATION;control\\n0089;HTJ;abbreviation\\n008A;LINE TABULATION SET;control\\n008A;VERTICAL TABULATION SET;control\\n008A;VTS;abbreviation\\n008B;PARTIAL LINE FORWARD;control\\n008B;PARTIAL LINE DOWN;control\\n008B;PLD;abbreviation\\n008C;PARTIAL LINE BACKWARD;control\\n008C;PARTIAL LINE UP;control\\n008C;PLU;abbreviation\\n008D;REVERSE LINE FEED;control\\n008D;REVERSE INDEX;control\\n008D;RI;abbreviation\\n008E;SINGLE SHIFT TWO;control\\n008E;SINGLE-SHIFT-2;control\\n008E;SS2;abbreviation\\n008F;SINGLE SHIFT THREE;control\\n008F;SINGLE-SHIFT-3;control\\n008F;SS3;abbreviation\\n0090;DEVICE CONTROL STRING;control\\n0090;DCS;abbreviation\\n0091;PRIVATE USE ONE;control\\n0091;PRIVATE USE-1;control\\n0091;PU1;abbreviation\\n0092;PRIVATE USE TWO;control\\n0092;PRIVATE USE-2;control\\n0092;PU2;abbreviation\\n0093;SET TRANSMIT STATE;control\\n0093;STS;abbreviation\\n0094;CANCEL CHARACTER;control\\n0094;CCH;abbreviation\\n0095;MESSAGE WAITING;control\\n0095;MW;abbreviation\\n0096;START OF GUARDED AREA;control\\n0096;START OF PROTECTED AREA;control\\n0096;SPA;abbreviation\\n0097;END OF GUARDED AREA;control\\n0097;END OF PROTECTED AREA;control\\n0097;EPA;abbreviation\\n0098;START OF STRING;control\\n0098;SOS;abbreviation\\n\\n# SINGLE GRAPHIC CHARACTER INTRODUCER is another\\n# architectural concept from early drafts of ISO/IEC 10646-1\\n# which was never approved and standardized.\\n\\n0099;SINGLE GRAPHIC CHARACTER INTRODUCER;figment\\n0099;SGC;abbreviation\\n\\n009A;SINGLE CHARACTER INTRODUCER;control\\n009A;SCI;abbreviation\\n009B;CONTROL SEQUENCE INTRODUCER;control\\n009B;CSI;abbreviation\\n009C;STRING TERMINATOR;control\\n009C;ST;abbreviation\\n009D;OPERATING SYSTEM COMMAND;control\\n009D;OSC;abbreviation\\n009E;PRIVACY MESSAGE;control\\n009E;PM;abbreviation\\n009F;APPLICATION PROGRAM COMMAND;control\\n009F;APC;abbreviation\\n00A0;NBSP;abbreviation\\n00AD;SHY;abbreviation\\n01A2;LATIN CAPITAL LETTER GHA;correction\\n01A3;LATIN SMALL LETTER GHA;correction\\n034F;CGJ;abbreviation\\n061C;ALM;abbreviation\\n0709;SYRIAC SUBLINEAR COLON SKEWED LEFT;correction\\n0CDE;KANNADA LETTER LLLA;correction\\n0E9D;LAO LETTER FO FON;correction\\n0E9F;LAO LETTER FO FAY;correction\\n0EA3;LAO LETTER RO;correction\\n0EA5;LAO LETTER LO;correction\\n0FD0;TIBETAN MARK BKA- SHOG GI MGO RGYAN;correction\\n180B;FVS1;abbreviation\\n180C;FVS2;abbreviation\\n180D;FVS3;abbreviation\\n180E;MVS;abbreviation\\n200B;ZWSP;abbreviation\\n200C;ZWNJ;abbreviation\\n200D;ZWJ;abbreviation\\n200E;LRM;abbreviation\\n200F;RLM;abbreviation\\n202A;LRE;abbreviation\\n202B;RLE;abbreviation\\n202C;PDF;abbreviation\\n202D;LRO;abbreviation\\n202E;RLO;abbreviation\\n202F;NNBSP;abbreviation\\n205F;MMSP;abbreviation\\n2060;WJ;abbreviation\\n2066;LRI;abbreviation\\n2067;RLI;abbreviation\\n2068;FSI;abbreviation\\n2069;PDI;abbreviation\\n2118;WEIERSTRASS ELLIPTIC FUNCTION;correction\\n2448;MICR ON US SYMBOL;correction\\n2449;MICR DASH SYMBOL;correction\\n2B7A;LEFTWARDS TRIANGLE-HEADED ARROW WITH DOUBLE VERTICAL STROKE;correction\\n2B7C;RIGHTWARDS TRIANGLE-HEADED ARROW WITH DOUBLE VERTICAL STROKE;correction\\nA015;YI SYLLABLE ITERATION MARK;correction\\nFE18;PRESENTATION FORM FOR VERTICAL RIGHT WHITE LENTICULAR BRACKET;correction\\nFE00;VS1;abbreviation\\nFE01;VS2;abbreviation\\nFE02;VS3;abbreviation\\nFE03;VS4;abbreviation\\nFE04;VS5;abbreviation\\nFE05;VS6;abbreviation\\nFE06;VS7;abbreviation\\nFE07;VS8;abbreviation\\nFE08;VS9;abbreviation\\nFE09;VS10;abbreviation\\nFE0A;VS11;abbreviation\\nFE0B;VS12;abbreviation\\nFE0C;VS13;abbreviation\\nFE0D;VS14;abbreviation\\nFE0E;VS15;abbreviation\\nFE0F;VS16;abbreviation\\nFEFF;BYTE ORDER MARK;alternate\\nFEFF;BOM;abbreviation\\nFEFF;ZWNBSP;abbreviation\\n122D4;CUNEIFORM SIGN NU11 TENU;correction\\n122D5;CUNEIFORM SIGN NU11 OVER NU11 BUR OVER BUR;correction\\n1D0C5;BYZANTINE MUSICAL SYMBOL FTHORA SKLIRON CHROMA VASIS;correction\\nE0100;VS17;abbreviation\\nE0101;VS18;abbreviation\\nE0102;VS19;abbreviation\\nE0103;VS20;abbreviation\\nE0104;VS21;abbreviation\\nE0105;VS22;abbreviation\\nE0106;VS23;abbreviation\\nE0107;VS24;abbreviation\\nE0108;VS25;abbreviation\\nE0109;VS26;abbreviation\\nE010A;VS27;abbreviation\\nE010B;VS28;abbreviation\\nE010C;VS29;abbreviation\\nE010D;VS30;abbreviation\\nE010E;VS31;abbreviation\\nE010F;VS32;abbreviation\\nE0110;VS33;abbreviation\\nE0111;VS34;abbreviation\\nE0112;VS35;abbreviation\\nE0113;VS36;abbreviation\\nE0114;VS37;abbreviation\\nE0115;VS38;abbreviation\\nE0116;VS39;abbreviation\\nE0117;VS40;abbreviation\\nE0118;VS41;abbreviation\\nE0119;VS42;abbreviation\\nE011A;VS43;abbreviation\\nE011B;VS44;abbreviation\\nE011C;VS45;abbreviation\\nE011D;VS46;abbreviation\\nE011E;VS47;abbreviation\\nE011F;VS48;abbreviation\\nE0120;VS49;abbreviation\\nE0121;VS50;abbreviation\\nE0122;VS51;abbreviation\\nE0123;VS52;abbreviation\\nE0124;VS53;abbreviation\\nE0125;VS54;abbreviation\\nE0126;VS55;abbreviation\\nE0127;VS56;abbreviation\\nE0128;VS57;abbreviation\\nE0129;VS58;abbreviation\\nE012A;VS59;abbreviation\\nE012B;VS60;abbreviation\\nE012C;VS61;abbreviation\\nE012D;VS62;abbreviation\\nE012E;VS63;abbreviation\\nE012F;VS64;abbreviation\\nE0130;VS65;abbreviation\\nE0131;VS66;abbreviation\\nE0132;VS67;abbreviation\\nE0133;VS68;abbreviation\\nE0134;VS69;abbreviation\\nE0135;VS70;abbreviation\\nE0136;VS71;abbreviation\\nE0137;VS72;abbreviation\\nE0138;VS73;abbreviation\\nE0139;VS74;abbreviation\\nE013A;VS75;abbreviation\\nE013B;VS76;abbreviation\\nE013C;VS77;abbreviation\\nE013D;VS78;abbreviation\\nE013E;VS79;abbreviation\\nE013F;VS80;abbreviation\\nE0140;VS81;abbreviation\\nE0141;VS82;abbreviation\\nE0142;VS83;abbreviation\\nE0143;VS84;abbreviation\\nE0144;VS85;abbreviation\\nE0145;VS86;abbreviation\\nE0146;VS87;abbreviation\\nE0147;VS88;abbreviation\\nE0148;VS89;abbreviation\\nE0149;VS90;abbreviation\\nE014A;VS91;abbreviation\\nE014B;VS92;abbreviation\\nE014C;VS93;abbreviation\\nE014D;VS94;abbreviation\\nE014E;VS95;abbreviation\\nE014F;VS96;abbreviation\\nE0150;VS97;abbreviation\\nE0151;VS98;abbreviation\\nE0152;VS99;abbreviation\\nE0153;VS100;abbreviation\\nE0154;VS101;abbreviation\\nE0155;VS102;abbreviation\\nE0156;VS103;abbreviation\\nE0157;VS104;abbreviation\\nE0158;VS105;abbreviation\\nE0159;VS106;abbreviation\\nE015A;VS107;abbreviation\\nE015B;VS108;abbreviation\\nE015C;VS109;abbreviation\\nE015D;VS110;abbreviation\\nE015E;VS111;abbreviation\\nE015F;VS112;abbreviation\\nE0160;VS113;abbreviation\\nE0161;VS114;abbreviation\\nE0162;VS115;abbreviation\\nE0163;VS116;abbreviation\\nE0164;VS117;abbreviation\\nE0165;VS118;abbreviation\\nE0166;VS119;abbreviation\\nE0167;VS120;abbreviation\\nE0168;VS121;abbreviation\\nE0169;VS122;abbreviation\\nE016A;VS123;abbreviation\\nE016B;VS124;abbreviation\\nE016C;VS125;abbreviation\\nE016D;VS126;abbreviation\\nE016E;VS127;abbreviation\\nE016F;VS128;abbreviation\\nE0170;VS129;abbreviation\\nE0171;VS130;abbreviation\\nE0172;VS131;abbreviation\\nE0173;VS132;abbreviation\\nE0174;VS133;abbreviation\\nE0175;VS134;abbreviation\\nE0176;VS135;abbreviation\\nE0177;VS136;abbreviation\\nE0178;VS137;abbreviation\\nE0179;VS138;abbreviation\\nE017A;VS139;abbreviation\\nE017B;VS140;abbreviation\\nE017C;VS141;abbreviation\\nE017D;VS142;abbreviation\\nE017E;VS143;abbreviation\\nE017F;VS144;abbreviation\\nE0180;VS145;abbreviation\\nE0181;VS146;abbreviation\\nE0182;VS147;abbreviation\\nE0183;VS148;abbreviation\\nE0184;VS149;abbreviation\\nE0185;VS150;abbreviation\\nE0186;VS151;abbreviation\\nE0187;VS152;abbreviation\\nE0188;VS153;abbreviation\\nE0189;VS154;abbreviation\\nE018A;VS155;abbreviation\\nE018B;VS156;abbreviation\\nE018C;VS157;abbreviation\\nE018D;VS158;abbreviation\\nE018E;VS159;abbreviation\\nE018F;VS160;abbreviation\\nE0190;VS161;abbreviation\\nE0191;VS162;abbreviation\\nE0192;VS163;abbreviation\\nE0193;VS164;abbreviation\\nE0194;VS165;abbreviation\\nE0195;VS166;abbreviation\\nE0196;VS167;abbreviation\\nE0197;VS168;abbreviation\\nE0198;VS169;abbreviation\\nE0199;VS170;abbreviation\\nE019A;VS171;abbreviation\\nE019B;VS172;abbreviation\\nE019C;VS173;abbreviation\\nE019D;VS174;abbreviation\\nE019E;VS175;abbreviation\\nE019F;VS176;abbreviation\\nE01A0;VS177;abbreviation\\nE01A1;VS178;abbreviation\\nE01A2;VS179;abbreviation\\nE01A3;VS180;abbreviation\\nE01A4;VS181;abbreviation\\nE01A5;VS182;abbreviation\\nE01A6;VS183;abbreviation\\nE01A7;VS184;abbreviation\\nE01A8;VS185;abbreviation\\nE01A9;VS186;abbreviation\\nE01AA;VS187;abbreviation\\nE01AB;VS188;abbreviation\\nE01AC;VS189;abbreviation\\nE01AD;VS190;abbreviation\\nE01AE;VS191;abbreviation\\nE01AF;VS192;abbreviation\\nE01B0;VS193;abbreviation\\nE01B1;VS194;abbreviation\\nE01B2;VS195;abbreviation\\nE01B3;VS196;abbreviation\\nE01B4;VS197;abbreviation\\nE01B5;VS198;abbreviation\\nE01B6;VS199;abbreviation\\nE01B7;VS200;abbreviation\\nE01B8;VS201;abbreviation\\nE01B9;VS202;abbreviation\\nE01BA;VS203;abbreviation\\nE01BB;VS204;abbreviation\\nE01BC;VS205;abbreviation\\nE01BD;VS206;abbreviation\\nE01BE;VS207;abbreviation\\nE01BF;VS208;abbreviation\\nE01C0;VS209;abbreviation\\nE01C1;VS210;abbreviation\\nE01C2;VS211;abbreviation\\nE01C3;VS212;abbreviation\\nE01C4;VS213;abbreviation\\nE01C5;VS214;abbreviation\\nE01C6;VS215;abbreviation\\nE01C7;VS216;abbreviation\\nE01C8;VS217;abbreviation\\nE01C9;VS218;abbreviation\\nE01CA;VS219;abbreviation\\nE01CB;VS220;abbreviation\\nE01CC;VS221;abbreviation\\nE01CD;VS222;abbreviation\\nE01CE;VS223;abbreviation\\nE01CF;VS224;abbreviation\\nE01D0;VS225;abbreviation\\nE01D1;VS226;abbreviation\\nE01D2;VS227;abbreviation\\nE01D3;VS228;abbreviation\\nE01D4;VS229;abbreviation\\nE01D5;VS230;abbreviation\\nE01D6;VS231;abbreviation\\nE01D7;VS232;abbreviation\\nE01D8;VS233;abbreviation\\nE01D9;VS234;abbreviation\\nE01DA;VS235;abbreviation\\nE01DB;VS236;abbreviation\\nE01DC;VS237;abbreviation\\nE01DD;VS238;abbreviation\\nE01DE;VS239;abbreviation\\nE01DF;VS240;abbreviation\\nE01E0;VS241;abbreviation\\nE01E1;VS242;abbreviation\\nE01E2;VS243;abbreviation\\nE01E3;VS244;abbreviation\\nE01E4;VS245;abbreviation\\nE01E5;VS246;abbreviation\\nE01E6;VS247;abbreviation\\nE01E7;VS248;abbreviation\\nE01E8;VS249;abbreviation\\nE01E9;VS250;abbreviation\\nE01EA;VS251;abbreviation\\nE01EB;VS252;abbreviation\\nE01EC;VS253;abbreviation\\nE01ED;VS254;abbreviation\\nE01EE;VS255;abbreviation\\nE01EF;VS256;abbreviation\\n\\n# EOF\\n\";\n        ALIAS_MAP = function () {\n            var ans, line, parts, code_point;\n            ans = {};\n            var ρσ_Iter10 = ρσ_Iterable(DB.split(\"\\n\"));\n            for (var ρσ_Index10 = 0; ρσ_Index10 < ρσ_Iter10.length; ρσ_Index10++) {\n                line = ρσ_Iter10[ρσ_Index10];\n                line = line.trim();\n                if (!line || line[0] === \"#\") {\n                    continue;\n                }\n                parts = line.split(\";\");\n                if (parts.length >= 2) {\n                    code_point = parseInt(parts[0], 16);\n                    if (code_point !== undefined && parts[1]) {\n                        ans[ρσ_bound_index(parts[1].toLowerCase(), ans)] = code_point;\n                    }\n                }\n            }\n            return ans;\n        }();\n        ρσ_modules.unicode_aliases.DB = DB;\n        ρσ_modules.unicode_aliases.ALIAS_MAP = ALIAS_MAP;\n    })();\n\n    (function(){\n        var __name__ = \"ast\";\n        var noop = ρσ_modules.utils.noop;\n\n        function is_node_type(node, typ) {\n            return node instanceof typ;\n        };\n        if (!is_node_type.__argnames__) Object.defineProperties(is_node_type, {\n            __argnames__ : {value: [\"node\", \"typ\"]}\n        });\n\n        function AST() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST.prototype.__init__.apply(this, arguments);\n        }\n        AST.prototype.__init__ = function __init__(initializer) {\n            var self = this;\n            var obj;\n            if (initializer) {\n                obj = self;\n                while (true) {\n                    obj = Object.getPrototypeOf(obj);\n                    if (obj === null) {\n                        break;\n                    }\n                    for (var i in obj.properties) {\n                        self[i] = initializer[i];\n                    }\n                }\n            }\n        };\n        if (!AST.prototype.__init__.__argnames__) Object.defineProperties(AST.prototype.__init__, {\n            __argnames__ : {value: [\"initializer\"]}\n        });\n        AST.__argnames__ = AST.prototype.__init__.__argnames__;\n        AST.__handles_kwarg_interpolation__ = AST.prototype.__init__.__handles_kwarg_interpolation__;\n        AST.prototype.clone = function clone() {\n            var self = this;\n            return new self.constructor(self);\n        };\n        if (!AST.prototype.clone.__argnames__) Object.defineProperties(AST.prototype.clone, {\n            __argnames__ : {value: []}\n        });\n        AST.prototype.__repr__ = function __repr__ () {\n                        return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST.prototype.__str__ = function __str__ () {\n            return this.__repr__();\n        };\n        Object.defineProperty(AST.prototype, \"__bases__\", {value: []});\n        AST.prototype.properties = Object.create(null);\n\n        function AST_Token() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_Token.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_Token, AST);\n        AST_Token.prototype.__init__ = function __init__ () {\n            AST.prototype.__init__ && AST.prototype.__init__.apply(this, arguments);\n        };\n        AST_Token.prototype.__repr__ = function __repr__ () {\n            if(AST.prototype.__repr__) return AST.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_Token.prototype.__str__ = function __str__ () {\n            if(AST.prototype.__str__) return AST.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Token.prototype, \"__bases__\", {value: [AST]});\n        AST_Token.prototype.properties = (function(){\n            var ρσ_d = Object.create(null);\n            ρσ_d[\"type\"] = \"The type of the token\";\n            ρσ_d[\"value\"] = \"The value of the token\";\n            ρσ_d[\"line\"] = \"The line number at which the token occurs\";\n            ρσ_d[\"col\"] = \"The column number at which the token occurs\";\n            ρσ_d[\"pos\"] = \"\";\n            ρσ_d[\"endpos\"] = \"\";\n            ρσ_d[\"nlb\"] = \"True iff there was a newline before this token\";\n            ρσ_d[\"comments_before\"] = \"True iff there were comments before this token\";\n            ρσ_d[\"file\"] = \"The filename in which this token occurs\";\n            return ρσ_d;\n        }).call(this);\n\n        function AST_Node() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_Node.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_Node, AST);\n        AST_Node.prototype.__init__ = function __init__ () {\n            AST.prototype.__init__ && AST.prototype.__init__.apply(this, arguments);\n        };\n        AST_Node.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self);\n        };\n        if (!AST_Node.prototype._walk.__argnames__) Object.defineProperties(AST_Node.prototype._walk, {\n            __argnames__ : {value: [\"visitor\"]}\n        });\n        AST_Node.prototype.walk = function walk(visitor) {\n            var self = this;\n            return self._walk(visitor);\n        };\n        if (!AST_Node.prototype.walk.__argnames__) Object.defineProperties(AST_Node.prototype.walk, {\n            __argnames__ : {value: [\"visitor\"]}\n        });\n        AST_Node.prototype._dump = function _dump() {\n            var self = this;\n            var depth = (arguments[0] === undefined || ( 0 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === \"object\" && arguments[arguments.length-1] [ρσ_kwargs_symbol] === true)) ? _dump.__defaults__.depth : arguments[0];\n            var omit = (arguments[1] === undefined || ( 1 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === \"object\" && arguments[arguments.length-1] [ρσ_kwargs_symbol] === true)) ? _dump.__defaults__.omit : arguments[1];\n            var offset = (arguments[2] === undefined || ( 2 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === \"object\" && arguments[arguments.length-1] [ρσ_kwargs_symbol] === true)) ? _dump.__defaults__.offset : arguments[2];\n            var include_name = (arguments[3] === undefined || ( 3 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === \"object\" && arguments[arguments.length-1] [ρσ_kwargs_symbol] === true)) ? _dump.__defaults__.include_name : arguments[3];\n            var ρσ_kwargs_obj = arguments[arguments.length-1];\n            if (ρσ_kwargs_obj === null || typeof ρσ_kwargs_obj !== \"object\" || ρσ_kwargs_obj [ρσ_kwargs_symbol] !== true) ρσ_kwargs_obj = {};\n            if (Object.prototype.hasOwnProperty.call(ρσ_kwargs_obj, \"depth\")){\n                depth = ρσ_kwargs_obj.depth;\n            }\n            if (Object.prototype.hasOwnProperty.call(ρσ_kwargs_obj, \"omit\")){\n                omit = ρσ_kwargs_obj.omit;\n            }\n            if (Object.prototype.hasOwnProperty.call(ρσ_kwargs_obj, \"offset\")){\n                offset = ρσ_kwargs_obj.offset;\n            }\n            if (Object.prototype.hasOwnProperty.call(ρσ_kwargs_obj, \"include_name\")){\n                include_name = ρσ_kwargs_obj.include_name;\n            }\n            var p, reset, yellow, blue, green, red, magenta, pad, element, tname, property, key;\n            p = console.log;\n            reset = \"\\u001b[0m\";\n            yellow = \"\\u001b[33m\";\n            blue = \"\\u001b[34m\";\n            green = \"\\u001b[32m\";\n            red = \"\\u001b[31m\";\n            magenta = \"\\u001b[35m\";\n            pad = new Array(offset + 1).join(\"  \");\n            if (include_name) {\n                p(pad + yellow + self.constructor.name.slice(4) + reset);\n            }\n            var ρσ_Iter11 = ρσ_Iterable(self);\n            for (var ρσ_Index11 = 0; ρσ_Index11 < ρσ_Iter11.length; ρσ_Index11++) {\n                key = ρσ_Iter11[ρσ_Index11];\n                if (ρσ_in(key, omit)) {\n                    continue;\n                }\n                if (Array.isArray(self[(typeof key === \"number\" && key < 0) ? self.length + key : key])) {\n                    if (self[(typeof key === \"number\" && key < 0) ? self.length + key : key].length) {\n                        p(pad + \" \" + blue + key + \": \" + reset + \"[\");\n                        if (depth > 1) {\n                            var ρσ_Iter12 = ρσ_Iterable(self[(typeof key === \"number\" && key < 0) ? self.length + key : key]);\n                            for (var ρσ_Index12 = 0; ρσ_Index12 < ρσ_Iter12.length; ρσ_Index12++) {\n                                element = ρσ_Iter12[ρσ_Index12];\n                                element._dump(depth - 1, omit, offset + 1, true);\n                            }\n                        } else {\n                            var ρσ_Iter13 = ρσ_Iterable(self[(typeof key === \"number\" && key < 0) ? self.length + key : key]);\n                            for (var ρσ_Index13 = 0; ρσ_Index13 < ρσ_Iter13.length; ρσ_Index13++) {\n                                element = ρσ_Iter13[ρσ_Index13];\n                                p(pad + \"   \" + yellow + element.constructor.name.slice(4) + reset);\n                            }\n                        }\n                        p(pad + \" ]\");\n                    } else {\n                        p(pad + \" \" + blue + key + \": \" + reset + \"[]\");\n                    }\n                } else if (self[(typeof key === \"number\" && key < 0) ? self.length + key : key]) {\n                    if (is_node_type(self[(typeof key === \"number\" && key < 0) ? self.length + key : key], AST)) {\n                        tname = self[(typeof key === \"number\" && key < 0) ? self.length + key : key].constructor.name.slice(4);\n                        if (tname === \"Token\") {\n                            p(pad + \" \" + blue + key + \": \" + magenta + tname + reset);\n                            var ρσ_Iter14 = ρσ_Iterable(self[(typeof key === \"number\" && key < 0) ? self.length + key : key]);\n                            for (var ρσ_Index14 = 0; ρσ_Index14 < ρσ_Iter14.length; ρσ_Index14++) {\n                                property = ρσ_Iter14[ρσ_Index14];\n                                p(pad + \"   \" + blue + property + \": \" + reset + (ρσ_expr_temp = self[(typeof key === \"number\" && key < 0) ? self.length + key : key])[(typeof property === \"number\" && property < 0) ? ρσ_expr_temp.length + property : property]);\n                            }\n                        } else {\n                            p(pad + \" \" + blue + key + \": \" + yellow + tname + reset);\n                            if (depth > 1) {\n                                self[(typeof key === \"number\" && key < 0) ? self.length + key : key]._dump(depth - 1, omit, offset + 1, false);\n                            }\n                        }\n                    } else if (typeof self[(typeof key === \"number\" && key < 0) ? self.length + key : key] === \"string\") {\n                        p(pad + \" \" + blue + key + \": \" + green + \"\\\"\" + self[(typeof key === \"number\" && key < 0) ? self.length + key : key] + \"\\\"\" + reset);\n                    } else if (typeof self[(typeof key === \"number\" && key < 0) ? self.length + key : key] === \"number\") {\n                        p(pad + \" \" + blue + key + \": \" + green + self[(typeof key === \"number\" && key < 0) ? self.length + key : key] + reset);\n                    } else {\n                        p(pad + \" \" + blue + key + \": \" + red + self[(typeof key === \"number\" && key < 0) ? self.length + key : key] + reset);\n                    }\n                } else {\n                    p(pad + \" \" + blue + key + \": \" + reset + self[(typeof key === \"number\" && key < 0) ? self.length + key : key]);\n                }\n            }\n        };\n        if (!AST_Node.prototype._dump.__defaults__) Object.defineProperties(AST_Node.prototype._dump, {\n            __defaults__ : {value: {depth:100, omit:(function(){\n                var s = ρσ_set();\n                s.jsset.add(\"start\");\n                s.jsset.add(\"end\");\n                return s;\n            })(), offset:0, include_name:true}},\n            __handles_kwarg_interpolation__ : {value: true},\n            __argnames__ : {value: [\"depth\", \"omit\", \"offset\", \"include_name\"]}\n        });\n        AST_Node.prototype.dump = function dump() {\n            var self = this;\n            var depth = (arguments[0] === undefined || ( 0 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === \"object\" && arguments[arguments.length-1] [ρσ_kwargs_symbol] === true)) ? dump.__defaults__.depth : arguments[0];\n            var omit = (arguments[1] === undefined || ( 1 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === \"object\" && arguments[arguments.length-1] [ρσ_kwargs_symbol] === true)) ? dump.__defaults__.omit : arguments[1];\n            var ρσ_kwargs_obj = arguments[arguments.length-1];\n            if (ρσ_kwargs_obj === null || typeof ρσ_kwargs_obj !== \"object\" || ρσ_kwargs_obj [ρσ_kwargs_symbol] !== true) ρσ_kwargs_obj = {};\n            if (Object.prototype.hasOwnProperty.call(ρσ_kwargs_obj, \"depth\")){\n                depth = ρσ_kwargs_obj.depth;\n            }\n            if (Object.prototype.hasOwnProperty.call(ρσ_kwargs_obj, \"omit\")){\n                omit = ρσ_kwargs_obj.omit;\n            }\n            return self._dump(depth, omit, 0, true);\n        };\n        if (!AST_Node.prototype.dump.__defaults__) Object.defineProperties(AST_Node.prototype.dump, {\n            __defaults__ : {value: {depth:2, omit:Object.create(null)}},\n            __handles_kwarg_interpolation__ : {value: true},\n            __argnames__ : {value: [\"depth\", \"omit\"]}\n        });\n        AST_Node.prototype.__repr__ = function __repr__ () {\n            if(AST.prototype.__repr__) return AST.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_Node.prototype.__str__ = function __str__ () {\n            if(AST.prototype.__str__) return AST.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Node.prototype, \"__bases__\", {value: [AST]});\n        AST_Node.prototype.properties = (function(){\n            var ρσ_d = Object.create(null);\n            ρσ_d[\"start\"] = \"[AST_Token] The first token of this node\";\n            ρσ_d[\"end\"] = \"[AST_Token] The last token of this node\";\n            return ρσ_d;\n        }).call(this);\n\n        function AST_Statement() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_Statement.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_Statement, AST_Node);\n        AST_Statement.prototype.__init__ = function __init__ () {\n            AST_Node.prototype.__init__ && AST_Node.prototype.__init__.apply(this, arguments);\n        };\n        AST_Statement.prototype.__repr__ = function __repr__ () {\n            if(AST_Node.prototype.__repr__) return AST_Node.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_Statement.prototype.__str__ = function __str__ () {\n            if(AST_Node.prototype.__str__) return AST_Node.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Statement.prototype, \"__bases__\", {value: [AST_Node]});\n\n        function AST_Debugger() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_Debugger.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_Debugger, AST_Statement);\n        AST_Debugger.prototype.__init__ = function __init__ () {\n            AST_Statement.prototype.__init__ && AST_Statement.prototype.__init__.apply(this, arguments);\n        };\n        AST_Debugger.prototype.__repr__ = function __repr__ () {\n            if(AST_Statement.prototype.__repr__) return AST_Statement.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_Debugger.prototype.__str__ = function __str__ () {\n            if(AST_Statement.prototype.__str__) return AST_Statement.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Debugger.prototype, \"__bases__\", {value: [AST_Statement]});\n\n        function AST_Directive() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_Directive.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_Directive, AST_Statement);\n        AST_Directive.prototype.__init__ = function __init__ () {\n            AST_Statement.prototype.__init__ && AST_Statement.prototype.__init__.apply(this, arguments);\n        };\n        AST_Directive.prototype.__repr__ = function __repr__ () {\n            if(AST_Statement.prototype.__repr__) return AST_Statement.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_Directive.prototype.__str__ = function __str__ () {\n            if(AST_Statement.prototype.__str__) return AST_Statement.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Directive.prototype, \"__bases__\", {value: [AST_Statement]});\n        AST_Directive.prototype.properties = (function(){\n            var ρσ_d = Object.create(null);\n            ρσ_d[\"value\"] = \"[string] The value of this directive as a plain string (it's not an AST_String!)\";\n            ρσ_d[\"scope\"] = \"[AST_Scope/S] The scope that this directive affects\";\n            return ρσ_d;\n        }).call(this);\n\n        function AST_SimpleStatement() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_SimpleStatement.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_SimpleStatement, AST_Statement);\n        AST_SimpleStatement.prototype.__init__ = function __init__ () {\n            AST_Statement.prototype.__init__ && AST_Statement.prototype.__init__.apply(this, arguments);\n        };\n        AST_SimpleStatement.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                self.body._walk(visitor);\n            });\n        };\n        if (!AST_SimpleStatement.prototype._walk.__argnames__) Object.defineProperties(AST_SimpleStatement.prototype._walk, {\n            __argnames__ : {value: [\"visitor\"]}\n        });\n        AST_SimpleStatement.prototype.__repr__ = function __repr__ () {\n            if(AST_Statement.prototype.__repr__) return AST_Statement.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_SimpleStatement.prototype.__str__ = function __str__ () {\n            if(AST_Statement.prototype.__str__) return AST_Statement.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_SimpleStatement.prototype, \"__bases__\", {value: [AST_Statement]});\n        AST_SimpleStatement.prototype.properties = (function(){\n            var ρσ_d = Object.create(null);\n            ρσ_d[\"body\"] = \"[AST_Node] an expression node (should not be instanceof AST_Statement)\";\n            return ρσ_d;\n        }).call(this);\n\n        function AST_Assert() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_Assert.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_Assert, AST_Statement);\n        AST_Assert.prototype.__init__ = function __init__ () {\n            AST_Statement.prototype.__init__ && AST_Statement.prototype.__init__.apply(this, arguments);\n        };\n        AST_Assert.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                self.condition._walk(visitor);\n                if (self.message) {\n                    self.message._walk(visitor);\n                }\n            });\n        };\n        if (!AST_Assert.prototype._walk.__argnames__) Object.defineProperties(AST_Assert.prototype._walk, {\n            __argnames__ : {value: [\"visitor\"]}\n        });\n        AST_Assert.prototype.__repr__ = function __repr__ () {\n            if(AST_Statement.prototype.__repr__) return AST_Statement.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_Assert.prototype.__str__ = function __str__ () {\n            if(AST_Statement.prototype.__str__) return AST_Statement.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Assert.prototype, \"__bases__\", {value: [AST_Statement]});\n        AST_Assert.prototype.properties = (function(){\n            var ρσ_d = Object.create(null);\n            ρσ_d[\"condition\"] = \"[AST_Node] the expression that should be tested\";\n            ρσ_d[\"message\"] = \"[AST_Node*] the expression that is the error message or None\";\n            return ρσ_d;\n        }).call(this);\n\n        function walk_body(node, visitor) {\n            var stat;\n            if (is_node_type(node.body, AST_Statement)) {\n                node.body._walk(visitor);\n            } else if (node.body) {\n                var ρσ_Iter15 = ρσ_Iterable(node.body);\n                for (var ρσ_Index15 = 0; ρσ_Index15 < ρσ_Iter15.length; ρσ_Index15++) {\n                    stat = ρσ_Iter15[ρσ_Index15];\n                    stat._walk(visitor);\n                }\n            }\n        };\n        if (!walk_body.__argnames__) Object.defineProperties(walk_body, {\n            __argnames__ : {value: [\"node\", \"visitor\"]}\n        });\n\n        function AST_Block() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_Block.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_Block, AST_Statement);\n        AST_Block.prototype.__init__ = function __init__ () {\n            AST_Statement.prototype.__init__ && AST_Statement.prototype.__init__.apply(this, arguments);\n        };\n        AST_Block.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                walk_body(self, visitor);\n            });\n        };\n        if (!AST_Block.prototype._walk.__argnames__) Object.defineProperties(AST_Block.prototype._walk, {\n            __argnames__ : {value: [\"visitor\"]}\n        });\n        AST_Block.prototype.__repr__ = function __repr__ () {\n            if(AST_Statement.prototype.__repr__) return AST_Statement.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_Block.prototype.__str__ = function __str__ () {\n            if(AST_Statement.prototype.__str__) return AST_Statement.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Block.prototype, \"__bases__\", {value: [AST_Statement]});\n        AST_Block.prototype.properties = (function(){\n            var ρσ_d = Object.create(null);\n            ρσ_d[\"body\"] = \"[AST_Statement*] an array of statements\";\n            return ρσ_d;\n        }).call(this);\n\n        function AST_BlockStatement() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_BlockStatement.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_BlockStatement, AST_Block);\n        AST_BlockStatement.prototype.__init__ = function __init__ () {\n            AST_Block.prototype.__init__ && AST_Block.prototype.__init__.apply(this, arguments);\n        };\n        AST_BlockStatement.prototype.__repr__ = function __repr__ () {\n            if(AST_Block.prototype.__repr__) return AST_Block.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_BlockStatement.prototype.__str__ = function __str__ () {\n            if(AST_Block.prototype.__str__) return AST_Block.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_BlockStatement.prototype, \"__bases__\", {value: [AST_Block]});\n\n        function AST_EmptyStatement() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_EmptyStatement.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_EmptyStatement, AST_Statement);\n        AST_EmptyStatement.prototype.__init__ = function __init__ () {\n            AST_Statement.prototype.__init__ && AST_Statement.prototype.__init__.apply(this, arguments);\n        };\n        AST_EmptyStatement.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self);\n        };\n        if (!AST_EmptyStatement.prototype._walk.__argnames__) Object.defineProperties(AST_EmptyStatement.prototype._walk, {\n            __argnames__ : {value: [\"visitor\"]}\n        });\n        AST_EmptyStatement.prototype.__repr__ = function __repr__ () {\n            if(AST_Statement.prototype.__repr__) return AST_Statement.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_EmptyStatement.prototype.__str__ = function __str__ () {\n            if(AST_Statement.prototype.__str__) return AST_Statement.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_EmptyStatement.prototype, \"__bases__\", {value: [AST_Statement]});\n        AST_EmptyStatement.prototype.properties = (function(){\n            var ρσ_d = Object.create(null);\n            ρσ_d[\"stype\"] = \"[string] the type of empty statement. Is ; for semicolons\";\n            return ρσ_d;\n        }).call(this);\n\n        function AST_StatementWithBody() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_StatementWithBody.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_StatementWithBody, AST_Statement);\n        AST_StatementWithBody.prototype.__init__ = function __init__ () {\n            AST_Statement.prototype.__init__ && AST_Statement.prototype.__init__.apply(this, arguments);\n        };\n        AST_StatementWithBody.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                self.body._walk(visitor);\n            });\n        };\n        if (!AST_StatementWithBody.prototype._walk.__argnames__) Object.defineProperties(AST_StatementWithBody.prototype._walk, {\n            __argnames__ : {value: [\"visitor\"]}\n        });\n        AST_StatementWithBody.prototype.__repr__ = function __repr__ () {\n            if(AST_Statement.prototype.__repr__) return AST_Statement.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_StatementWithBody.prototype.__str__ = function __str__ () {\n            if(AST_Statement.prototype.__str__) return AST_Statement.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_StatementWithBody.prototype, \"__bases__\", {value: [AST_Statement]});\n        AST_StatementWithBody.prototype.properties = (function(){\n            var ρσ_d = Object.create(null);\n            ρσ_d[\"body\"] = \"[AST_Statement] the body; this should always be present, even if it's an AST_EmptyStatement\";\n            return ρσ_d;\n        }).call(this);\n\n        function AST_DWLoop() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_DWLoop.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_DWLoop, AST_StatementWithBody);\n        AST_DWLoop.prototype.__init__ = function __init__ () {\n            AST_StatementWithBody.prototype.__init__ && AST_StatementWithBody.prototype.__init__.apply(this, arguments);\n        };\n        AST_DWLoop.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                self.condition._walk(visitor);\n                self.body._walk(visitor);\n            });\n        };\n        if (!AST_DWLoop.prototype._walk.__argnames__) Object.defineProperties(AST_DWLoop.prototype._walk, {\n            __argnames__ : {value: [\"visitor\"]}\n        });\n        AST_DWLoop.prototype.__repr__ = function __repr__ () {\n            if(AST_StatementWithBody.prototype.__repr__) return AST_StatementWithBody.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_DWLoop.prototype.__str__ = function __str__ () {\n            if(AST_StatementWithBody.prototype.__str__) return AST_StatementWithBody.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_DWLoop.prototype, \"__bases__\", {value: [AST_StatementWithBody]});\n        AST_DWLoop.prototype.properties = (function(){\n            var ρσ_d = Object.create(null);\n            ρσ_d[\"condition\"] = \"[AST_Node] the loop condition.  Should not be instanceof AST_Statement\";\n            return ρσ_d;\n        }).call(this);\n\n        function AST_Do() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_Do.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_Do, AST_DWLoop);\n        AST_Do.prototype.__init__ = function __init__ () {\n            AST_DWLoop.prototype.__init__ && AST_DWLoop.prototype.__init__.apply(this, arguments);\n        };\n        AST_Do.prototype.__repr__ = function __repr__ () {\n            if(AST_DWLoop.prototype.__repr__) return AST_DWLoop.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_Do.prototype.__str__ = function __str__ () {\n            if(AST_DWLoop.prototype.__str__) return AST_DWLoop.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Do.prototype, \"__bases__\", {value: [AST_DWLoop]});\n\n        function AST_While() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_While.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_While, AST_DWLoop);\n        AST_While.prototype.__init__ = function __init__ () {\n            AST_DWLoop.prototype.__init__ && AST_DWLoop.prototype.__init__.apply(this, arguments);\n        };\n        AST_While.prototype.__repr__ = function __repr__ () {\n            if(AST_DWLoop.prototype.__repr__) return AST_DWLoop.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_While.prototype.__str__ = function __str__ () {\n            if(AST_DWLoop.prototype.__str__) return AST_DWLoop.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_While.prototype, \"__bases__\", {value: [AST_DWLoop]});\n\n        function AST_ForIn() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_ForIn.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_ForIn, AST_StatementWithBody);\n        AST_ForIn.prototype.__init__ = function __init__ () {\n            AST_StatementWithBody.prototype.__init__ && AST_StatementWithBody.prototype.__init__.apply(this, arguments);\n        };\n        AST_ForIn.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                self.init._walk(visitor);\n                if (self.name) self.name._walk(visitor);\n                self.object._walk(visitor);\n                if (self.body) {\n                    self.body._walk(visitor);\n                }\n            });\n        };\n        if (!AST_ForIn.prototype._walk.__argnames__) Object.defineProperties(AST_ForIn.prototype._walk, {\n            __argnames__ : {value: [\"visitor\"]}\n        });\n        AST_ForIn.prototype.__repr__ = function __repr__ () {\n            if(AST_StatementWithBody.prototype.__repr__) return AST_StatementWithBody.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_ForIn.prototype.__str__ = function __str__ () {\n            if(AST_StatementWithBody.prototype.__str__) return AST_StatementWithBody.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_ForIn.prototype, \"__bases__\", {value: [AST_StatementWithBody]});\n        AST_ForIn.prototype.properties = (function(){\n            var ρσ_d = Object.create(null);\n            ρσ_d[\"init\"] = \"[AST_Node] the `for/in` initialization code\";\n            ρσ_d[\"name\"] = \"[AST_SymbolRef?] the loop variable, only if `init` is AST_Var\";\n            ρσ_d[\"object\"] = \"[AST_Node] the object that we're looping through\";\n            return ρσ_d;\n        }).call(this);\n\n        function AST_ForJS() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_ForJS.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_ForJS, AST_StatementWithBody);\n        AST_ForJS.prototype.__init__ = function __init__ () {\n            AST_StatementWithBody.prototype.__init__ && AST_StatementWithBody.prototype.__init__.apply(this, arguments);\n        };\n        AST_ForJS.prototype.__repr__ = function __repr__ () {\n            if(AST_StatementWithBody.prototype.__repr__) return AST_StatementWithBody.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_ForJS.prototype.__str__ = function __str__ () {\n            if(AST_StatementWithBody.prototype.__str__) return AST_StatementWithBody.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_ForJS.prototype, \"__bases__\", {value: [AST_StatementWithBody]});\n        AST_ForJS.prototype.properties = (function(){\n            var ρσ_d = Object.create(null);\n            ρσ_d[\"condition\"] = \"[AST_Verbatim] raw JavaScript conditional\";\n            return ρσ_d;\n        }).call(this);\n\n        function AST_ListComprehension() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_ListComprehension.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_ListComprehension, AST_ForIn);\n        AST_ListComprehension.prototype.__init__ = function __init__ () {\n            AST_ForIn.prototype.__init__ && AST_ForIn.prototype.__init__.apply(this, arguments);\n        };\n        AST_ListComprehension.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                self.init._walk(visitor);\n                self.object._walk(visitor);\n                self.statement._walk(visitor);\n                if (self.condition) self.condition._walk(visitor);\n            });\n        };\n        if (!AST_ListComprehension.prototype._walk.__argnames__) Object.defineProperties(AST_ListComprehension.prototype._walk, {\n            __argnames__ : {value: [\"visitor\"]}\n        });\n        AST_ListComprehension.prototype.__repr__ = function __repr__ () {\n            if(AST_ForIn.prototype.__repr__) return AST_ForIn.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_ListComprehension.prototype.__str__ = function __str__ () {\n            if(AST_ForIn.prototype.__str__) return AST_ForIn.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_ListComprehension.prototype, \"__bases__\", {value: [AST_ForIn]});\n        AST_ListComprehension.prototype.properties = (function(){\n            var ρσ_d = Object.create(null);\n            ρσ_d[\"condition\"] = \"[AST_Node] the `if` condition\";\n            ρσ_d[\"statement\"] = \"[AST_Node] statement to perform on each element before returning it\";\n            return ρσ_d;\n        }).call(this);\n\n        function AST_SetComprehension() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_SetComprehension.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_SetComprehension, AST_ListComprehension);\n        AST_SetComprehension.prototype.__init__ = function __init__ () {\n            AST_ListComprehension.prototype.__init__ && AST_ListComprehension.prototype.__init__.apply(this, arguments);\n        };\n        AST_SetComprehension.prototype.__repr__ = function __repr__ () {\n            if(AST_ListComprehension.prototype.__repr__) return AST_ListComprehension.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_SetComprehension.prototype.__str__ = function __str__ () {\n            if(AST_ListComprehension.prototype.__str__) return AST_ListComprehension.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_SetComprehension.prototype, \"__bases__\", {value: [AST_ListComprehension]});\n\n        function AST_DictComprehension() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_DictComprehension.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_DictComprehension, AST_ListComprehension);\n        AST_DictComprehension.prototype.__init__ = function __init__ () {\n            AST_ListComprehension.prototype.__init__ && AST_ListComprehension.prototype.__init__.apply(this, arguments);\n        };\n        AST_DictComprehension.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                self.init._walk(visitor);\n                self.object._walk(visitor);\n                self.statement._walk(visitor);\n                self.value_statement._walk(visitor);\n                if (self.condition) self.condition._walk(visitor);\n            });\n        };\n        if (!AST_DictComprehension.prototype._walk.__argnames__) Object.defineProperties(AST_DictComprehension.prototype._walk, {\n            __argnames__ : {value: [\"visitor\"]}\n        });\n        AST_DictComprehension.prototype.__repr__ = function __repr__ () {\n            if(AST_ListComprehension.prototype.__repr__) return AST_ListComprehension.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_DictComprehension.prototype.__str__ = function __str__ () {\n            if(AST_ListComprehension.prototype.__str__) return AST_ListComprehension.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_DictComprehension.prototype, \"__bases__\", {value: [AST_ListComprehension]});\n        AST_DictComprehension.prototype.properties = (function(){\n            var ρσ_d = Object.create(null);\n            ρσ_d[\"value_statement\"] = \"[AST_Node] statement to perform on each value before returning it\";\n            ρσ_d[\"is_pydict\"] = \"[bool] True if this comprehension is for a python dict\";\n            ρσ_d[\"is_jshash\"] = \"[bool] True if this comprehension is for a js hash\";\n            return ρσ_d;\n        }).call(this);\n\n        function AST_GeneratorComprehension() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_GeneratorComprehension.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_GeneratorComprehension, AST_ListComprehension);\n        AST_GeneratorComprehension.prototype.__init__ = function __init__ () {\n            AST_ListComprehension.prototype.__init__ && AST_ListComprehension.prototype.__init__.apply(this, arguments);\n        };\n        AST_GeneratorComprehension.prototype.__repr__ = function __repr__ () {\n            if(AST_ListComprehension.prototype.__repr__) return AST_ListComprehension.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_GeneratorComprehension.prototype.__str__ = function __str__ () {\n            if(AST_ListComprehension.prototype.__str__) return AST_ListComprehension.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_GeneratorComprehension.prototype, \"__bases__\", {value: [AST_ListComprehension]});\n\n        function AST_With() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_With.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_With, AST_StatementWithBody);\n        AST_With.prototype.__init__ = function __init__ () {\n            AST_StatementWithBody.prototype.__init__ && AST_StatementWithBody.prototype.__init__.apply(this, arguments);\n        };\n        AST_With.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                var exp;\n                var ρσ_Iter16 = ρσ_Iterable(self.clauses);\n                for (var ρσ_Index16 = 0; ρσ_Index16 < ρσ_Iter16.length; ρσ_Index16++) {\n                    exp = ρσ_Iter16[ρσ_Index16];\n                    exp._walk(visitor);\n                }\n                self.body._walk(visitor);\n            });\n        };\n        if (!AST_With.prototype._walk.__argnames__) Object.defineProperties(AST_With.prototype._walk, {\n            __argnames__ : {value: [\"visitor\"]}\n        });\n        AST_With.prototype.__repr__ = function __repr__ () {\n            if(AST_StatementWithBody.prototype.__repr__) return AST_StatementWithBody.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_With.prototype.__str__ = function __str__ () {\n            if(AST_StatementWithBody.prototype.__str__) return AST_StatementWithBody.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_With.prototype, \"__bases__\", {value: [AST_StatementWithBody]});\n        AST_With.prototype.properties = (function(){\n            var ρσ_d = Object.create(null);\n            ρσ_d[\"clauses\"] = \"[AST_WithClause*] the `with` clauses (comma separated)\";\n            return ρσ_d;\n        }).call(this);\n\n        function AST_WithClause() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_WithClause.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_WithClause, AST_Node);\n        AST_WithClause.prototype.__init__ = function __init__ () {\n            AST_Node.prototype.__init__ && AST_Node.prototype.__init__.apply(this, arguments);\n        };\n        AST_WithClause.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                self.expression._walk(visitor);\n                if (self.alias) {\n                    self.alias._walk(visitor);\n                }\n            });\n        };\n        if (!AST_WithClause.prototype._walk.__argnames__) Object.defineProperties(AST_WithClause.prototype._walk, {\n            __argnames__ : {value: [\"visitor\"]}\n        });\n        AST_WithClause.prototype.__repr__ = function __repr__ () {\n            if(AST_Node.prototype.__repr__) return AST_Node.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_WithClause.prototype.__str__ = function __str__ () {\n            if(AST_Node.prototype.__str__) return AST_Node.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_WithClause.prototype, \"__bases__\", {value: [AST_Node]});\n        AST_WithClause.prototype.properties = (function(){\n            var ρσ_d = Object.create(null);\n            ρσ_d[\"expression\"] = \"[AST_Node] the expression\";\n            ρσ_d[\"alias\"] = \"[AST_SymbolAlias?] optional alias for this expression\";\n            return ρσ_d;\n        }).call(this);\n\n        function AST_Scope() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_Scope.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_Scope, AST_Block);\n        AST_Scope.prototype.__init__ = function __init__ () {\n            AST_Block.prototype.__init__ && AST_Block.prototype.__init__.apply(this, arguments);\n        };\n        AST_Scope.prototype.__repr__ = function __repr__ () {\n            if(AST_Block.prototype.__repr__) return AST_Block.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_Scope.prototype.__str__ = function __str__ () {\n            if(AST_Block.prototype.__str__) return AST_Block.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Scope.prototype, \"__bases__\", {value: [AST_Block]});\n        AST_Scope.prototype.properties = (function(){\n            var ρσ_d = Object.create(null);\n            ρσ_d[\"localvars\"] = \"[SymbolDef*] list of variables local to this scope\";\n            ρσ_d[\"docstrings\"] = \"[AST_String*] list of docstrings for this scope\";\n            return ρσ_d;\n        }).call(this);\n\n        function AST_Toplevel() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_Toplevel.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_Toplevel, AST_Scope);\n        AST_Toplevel.prototype.__init__ = function __init__ () {\n            AST_Scope.prototype.__init__ && AST_Scope.prototype.__init__.apply(this, arguments);\n        };\n        AST_Toplevel.prototype.__repr__ = function __repr__ () {\n            if(AST_Scope.prototype.__repr__) return AST_Scope.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_Toplevel.prototype.__str__ = function __str__ () {\n            if(AST_Scope.prototype.__str__) return AST_Scope.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Toplevel.prototype, \"__bases__\", {value: [AST_Scope]});\n        AST_Toplevel.prototype.properties = (function(){\n            var ρσ_d = Object.create(null);\n            ρσ_d[\"globals\"] = \"[Object/S] a map of name -> SymbolDef for all undeclared names\";\n            ρσ_d[\"baselib\"] = \"[Object/s] a collection of used parts of baselib\";\n            ρσ_d[\"imports\"] = \"[Object/S] a map of module_id->AST_Toplevel for all imported modules (this represents all imported modules across all source files)\";\n            ρσ_d[\"imported_module_ids\"] = \"[string*] a list of module ids that were imported by this module, specifically\";\n            ρσ_d[\"nonlocalvars\"] = \"[String*] a list of all non-local variable names (names that come from the global scope)\";\n            ρσ_d[\"shebang\"] = \"[string] If #! line is present, it will be stored here\";\n            ρσ_d[\"import_order\"] = \"[number] The global order in which this scope was imported\";\n            ρσ_d[\"module_id\"] = \"[string] The id of this module\";\n            ρσ_d[\"exports\"] = \"[SymbolDef*] list of names exported from this module\";\n            ρσ_d[\"classes\"] = \"[Object/S] a map of class names to AST_Class for classes defined in this module\";\n            ρσ_d[\"filename\"] = \"[string] The absolute path to the file from which this module was read\";\n            ρσ_d[\"srchash\"] = \"[string] SHA1 hash of source code, used for caching\";\n            return ρσ_d;\n        }).call(this);\n\n        function AST_Import() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_Import.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_Import, AST_Statement);\n        AST_Import.prototype.__init__ = function __init__ () {\n            AST_Statement.prototype.__init__ && AST_Statement.prototype.__init__.apply(this, arguments);\n        };\n        AST_Import.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                var arg;\n                if (self.alias) {\n                    self.alias._walk(visitor);\n                }\n                if (self.argnames) {\n                    var ρσ_Iter17 = ρσ_Iterable(self.argnames);\n                    for (var ρσ_Index17 = 0; ρσ_Index17 < ρσ_Iter17.length; ρσ_Index17++) {\n                        arg = ρσ_Iter17[ρσ_Index17];\n                        arg._walk(visitor);\n                    }\n                }\n            });\n        };\n        if (!AST_Import.prototype._walk.__argnames__) Object.defineProperties(AST_Import.prototype._walk, {\n            __argnames__ : {value: [\"visitor\"]}\n        });\n        AST_Import.prototype.__repr__ = function __repr__ () {\n            if(AST_Statement.prototype.__repr__) return AST_Statement.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_Import.prototype.__str__ = function __str__ () {\n            if(AST_Statement.prototype.__str__) return AST_Statement.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Import.prototype, \"__bases__\", {value: [AST_Statement]});\n        AST_Import.prototype.properties = (function(){\n            var ρσ_d = Object.create(null);\n            ρσ_d[\"module\"] = \"[AST_SymbolVar] name of the module we're importing\";\n            ρσ_d[\"key\"] = \"[string] The key by which this module is stored in the global modules mapping\";\n            ρσ_d[\"alias\"] = \"[AST_SymbolAlias] The name this module is imported as, can be None. For import x as y statements.\";\n            ρσ_d[\"argnames\"] = \"[AST_ImportedVar*] names of objects to be imported\";\n            ρσ_d[\"body\"] = \"[AST_TopLevel] parsed contents of the imported file\";\n            return ρσ_d;\n        }).call(this);\n\n        function AST_Imports() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_Imports.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_Imports, AST_Statement);\n        AST_Imports.prototype.__init__ = function __init__ () {\n            AST_Statement.prototype.__init__ && AST_Statement.prototype.__init__.apply(this, arguments);\n        };\n        AST_Imports.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                var imp;\n                var ρσ_Iter18 = ρσ_Iterable(self.imports);\n                for (var ρσ_Index18 = 0; ρσ_Index18 < ρσ_Iter18.length; ρσ_Index18++) {\n                    imp = ρσ_Iter18[ρσ_Index18];\n                    imp._walk(visitor);\n                }\n            });\n        };\n        if (!AST_Imports.prototype._walk.__argnames__) Object.defineProperties(AST_Imports.prototype._walk, {\n            __argnames__ : {value: [\"visitor\"]}\n        });\n        AST_Imports.prototype.__repr__ = function __repr__ () {\n            if(AST_Statement.prototype.__repr__) return AST_Statement.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_Imports.prototype.__str__ = function __str__ () {\n            if(AST_Statement.prototype.__str__) return AST_Statement.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Imports.prototype, \"__bases__\", {value: [AST_Statement]});\n        AST_Imports.prototype.properties = (function(){\n            var ρσ_d = Object.create(null);\n            ρσ_d[\"imports\"] = \"[AST_Import+] array of imports\";\n            return ρσ_d;\n        }).call(this);\n\n        function AST_Decorator() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_Decorator.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_Decorator, AST_Node);\n        AST_Decorator.prototype.__init__ = function __init__ () {\n            AST_Node.prototype.__init__ && AST_Node.prototype.__init__.apply(this, arguments);\n        };\n        AST_Decorator.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                if (self.expression) {\n                    self.expression.walk(visitor);\n                }\n            });\n        };\n        if (!AST_Decorator.prototype._walk.__argnames__) Object.defineProperties(AST_Decorator.prototype._walk, {\n            __argnames__ : {value: [\"visitor\"]}\n        });\n        AST_Decorator.prototype.__repr__ = function __repr__ () {\n            if(AST_Node.prototype.__repr__) return AST_Node.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_Decorator.prototype.__str__ = function __str__ () {\n            if(AST_Node.prototype.__str__) return AST_Node.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Decorator.prototype, \"__bases__\", {value: [AST_Node]});\n        AST_Decorator.prototype.properties = (function(){\n            var ρσ_d = Object.create(null);\n            ρσ_d[\"expression\"] = \"[AST_Node] the decorator expression\";\n            return ρσ_d;\n        }).call(this);\n\n        function AST_Lambda() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_Lambda.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_Lambda, AST_Scope);\n        AST_Lambda.prototype.__init__ = function __init__ () {\n            AST_Scope.prototype.__init__ && AST_Scope.prototype.__init__.apply(this, arguments);\n        };\n        AST_Lambda.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                var d, arg;\n                if (self.decorators) {\n                    var ρσ_Iter19 = ρσ_Iterable(self.decorators);\n                    for (var ρσ_Index19 = 0; ρσ_Index19 < ρσ_Iter19.length; ρσ_Index19++) {\n                        d = ρσ_Iter19[ρσ_Index19];\n                        d.walk(visitor);\n                    }\n                }\n                if (self.name) {\n                    self.name._walk(visitor);\n                }\n                var ρσ_Iter20 = ρσ_Iterable(self.argnames);\n                for (var ρσ_Index20 = 0; ρσ_Index20 < ρσ_Iter20.length; ρσ_Index20++) {\n                    arg = ρσ_Iter20[ρσ_Index20];\n                    arg._walk(visitor);\n                }\n                if (self.argnames.starargs) {\n                    self.argnames.starargs._walk(visitor);\n                }\n                if (self.argnames.kwargs) {\n                    self.argnames.kwargs._walk(visitor);\n                }\n                walk_body(self, visitor);\n            });\n        };\n        if (!AST_Lambda.prototype._walk.__argnames__) Object.defineProperties(AST_Lambda.prototype._walk, {\n            __argnames__ : {value: [\"visitor\"]}\n        });\n        AST_Lambda.prototype.__repr__ = function __repr__ () {\n            if(AST_Scope.prototype.__repr__) return AST_Scope.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_Lambda.prototype.__str__ = function __str__ () {\n            if(AST_Scope.prototype.__str__) return AST_Scope.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Lambda.prototype, \"__bases__\", {value: [AST_Scope]});\n        AST_Lambda.prototype.properties = (function(){\n            var ρσ_d = Object.create(null);\n            ρσ_d[\"name\"] = \"[AST_SymbolDeclaration?] the name of this function\";\n            ρσ_d[\"argnames\"] = \"[AST_SymbolFunarg*] array of function arguments\";\n            ρσ_d[\"decorators\"] = \"[AST_Decorator*] function decorators, if any\";\n            ρσ_d[\"is_generator\"] = \"[bool*] True iff this function is a generator\";\n            ρσ_d[\"is_expression\"] = \"[bool*] True iff this function is a function expression\";\n            ρσ_d[\"is_anonymous\"] = \"[bool*] True iff this function is an anonymous function\";\n            ρσ_d[\"return_annotation\"] = \"[AST_Node?] The return type annotation provided (if any)\";\n            return ρσ_d;\n        }).call(this);\n\n        function AST_Function() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_Function.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_Function, AST_Lambda);\n        AST_Function.prototype.__init__ = function __init__ () {\n            AST_Lambda.prototype.__init__ && AST_Lambda.prototype.__init__.apply(this, arguments);\n        };\n        AST_Function.prototype.__repr__ = function __repr__ () {\n            if(AST_Lambda.prototype.__repr__) return AST_Lambda.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_Function.prototype.__str__ = function __str__ () {\n            if(AST_Lambda.prototype.__str__) return AST_Lambda.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Function.prototype, \"__bases__\", {value: [AST_Lambda]});\n\n        function AST_Class() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_Class.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_Class, AST_Scope);\n        AST_Class.prototype.__init__ = function __init__ () {\n            AST_Scope.prototype.__init__ && AST_Scope.prototype.__init__.apply(this, arguments);\n        };\n        AST_Class.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                var d;\n                if (self.decorators) {\n                    var ρσ_Iter21 = ρσ_Iterable(self.decorators);\n                    for (var ρσ_Index21 = 0; ρσ_Index21 < ρσ_Iter21.length; ρσ_Index21++) {\n                        d = ρσ_Iter21[ρσ_Index21];\n                        d.walk(visitor);\n                    }\n                }\n                self.name._walk(visitor);\n                walk_body(self, visitor);\n                if (self.parent) self.parent._walk(visitor);\n            });\n        };\n        if (!AST_Class.prototype._walk.__argnames__) Object.defineProperties(AST_Class.prototype._walk, {\n            __argnames__ : {value: [\"visitor\"]}\n        });\n        AST_Class.prototype.__repr__ = function __repr__ () {\n            if(AST_Scope.prototype.__repr__) return AST_Scope.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_Class.prototype.__str__ = function __str__ () {\n            if(AST_Scope.prototype.__str__) return AST_Scope.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Class.prototype, \"__bases__\", {value: [AST_Scope]});\n        AST_Class.prototype.properties = (function(){\n            var ρσ_d = Object.create(null);\n            ρσ_d[\"name\"] = \"[AST_SymbolDeclaration?] the name of this class\";\n            ρσ_d[\"init\"] = \"[AST_Function] constructor for the class\";\n            ρσ_d[\"parent\"] = \"[AST_Symbol?] parent class this class inherits from\";\n            ρσ_d[\"bases\"] = \"[AST_Symbol*] list of base classes this class inherits from\";\n            ρσ_d[\"static\"] = \"[string*] list of static methods\";\n            ρσ_d[\"external\"] = \"[boolean] true if class is declared elsewhere, but will be within current scope at runtime\";\n            ρσ_d[\"bound\"] = \"[string*] list of methods that need to be bound to self\";\n            ρσ_d[\"decorators\"] = \"[AST_Decorator*] function decorators, if any\";\n            ρσ_d[\"module_id\"] = \"[string] The id of the module this class is defined in\";\n            ρσ_d[\"statements\"] = \"[AST_Node*] list of statements in the class scope (excluding method definitions)\";\n            ρσ_d[\"dynamic_properties\"] = \"[dict] map of dynamic property names to property descriptors of the form {getter:AST_Method, setter:AST_Method\";\n            ρσ_d[\"classvars\"] = \"[dict] map containing all class variables as keys, to be used to easily test for existence of a class variable\";\n            return ρσ_d;\n        }).call(this);\n\n        function AST_Method() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_Method.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_Method, AST_Lambda);\n        AST_Method.prototype.__init__ = function __init__ () {\n            AST_Lambda.prototype.__init__ && AST_Lambda.prototype.__init__.apply(this, arguments);\n        };\n        AST_Method.prototype.__repr__ = function __repr__ () {\n            if(AST_Lambda.prototype.__repr__) return AST_Lambda.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_Method.prototype.__str__ = function __str__ () {\n            if(AST_Lambda.prototype.__str__) return AST_Lambda.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Method.prototype, \"__bases__\", {value: [AST_Lambda]});\n        AST_Method.prototype.properties = (function(){\n            var ρσ_d = Object.create(null);\n            ρσ_d[\"static\"] = \"[boolean] true if method is static\";\n            ρσ_d[\"is_getter\"] = \"[boolean] true if method is a property getter\";\n            ρσ_d[\"is_setter\"] = \"[boolean] true if method is a property setter\";\n            return ρσ_d;\n        }).call(this);\n\n        function AST_Jump() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_Jump.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_Jump, AST_Statement);\n        AST_Jump.prototype.__init__ = function __init__ () {\n            AST_Statement.prototype.__init__ && AST_Statement.prototype.__init__.apply(this, arguments);\n        };\n        AST_Jump.prototype.__repr__ = function __repr__ () {\n            if(AST_Statement.prototype.__repr__) return AST_Statement.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_Jump.prototype.__str__ = function __str__ () {\n            if(AST_Statement.prototype.__str__) return AST_Statement.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Jump.prototype, \"__bases__\", {value: [AST_Statement]});\n\n        function AST_Exit() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_Exit.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_Exit, AST_Jump);\n        AST_Exit.prototype.__init__ = function __init__ () {\n            AST_Jump.prototype.__init__ && AST_Jump.prototype.__init__.apply(this, arguments);\n        };\n        AST_Exit.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                if (self.value) {\n                    self.value._walk(visitor);\n                }\n            });\n        };\n        if (!AST_Exit.prototype._walk.__argnames__) Object.defineProperties(AST_Exit.prototype._walk, {\n            __argnames__ : {value: [\"visitor\"]}\n        });\n        AST_Exit.prototype.__repr__ = function __repr__ () {\n            if(AST_Jump.prototype.__repr__) return AST_Jump.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_Exit.prototype.__str__ = function __str__ () {\n            if(AST_Jump.prototype.__str__) return AST_Jump.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Exit.prototype, \"__bases__\", {value: [AST_Jump]});\n        AST_Exit.prototype.properties = (function(){\n            var ρσ_d = Object.create(null);\n            ρσ_d[\"value\"] = \"[AST_Node?] the value returned or thrown by this statement; could be null for AST_Return\";\n            return ρσ_d;\n        }).call(this);\n\n        function AST_Return() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_Return.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_Return, AST_Exit);\n        AST_Return.prototype.__init__ = function __init__ () {\n            AST_Exit.prototype.__init__ && AST_Exit.prototype.__init__.apply(this, arguments);\n        };\n        AST_Return.prototype.__repr__ = function __repr__ () {\n            if(AST_Exit.prototype.__repr__) return AST_Exit.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_Return.prototype.__str__ = function __str__ () {\n            if(AST_Exit.prototype.__str__) return AST_Exit.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Return.prototype, \"__bases__\", {value: [AST_Exit]});\n\n        function AST_Yield() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_Yield.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_Yield, AST_Return);\n        AST_Yield.prototype.__init__ = function __init__ () {\n            AST_Return.prototype.__init__ && AST_Return.prototype.__init__.apply(this, arguments);\n        };\n        AST_Yield.prototype.__repr__ = function __repr__ () {\n            if(AST_Return.prototype.__repr__) return AST_Return.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_Yield.prototype.__str__ = function __str__ () {\n            if(AST_Return.prototype.__str__) return AST_Return.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Yield.prototype, \"__bases__\", {value: [AST_Return]});\n        AST_Yield.prototype.properties = (function(){\n            var ρσ_d = Object.create(null);\n            ρσ_d[\"is_yield_from\"] = \"[bool] True iff this is a yield from, False otherwise\";\n            return ρσ_d;\n        }).call(this);\n\n        function AST_Throw() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_Throw.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_Throw, AST_Exit);\n        AST_Throw.prototype.__init__ = function __init__ () {\n            AST_Exit.prototype.__init__ && AST_Exit.prototype.__init__.apply(this, arguments);\n        };\n        AST_Throw.prototype.__repr__ = function __repr__ () {\n            if(AST_Exit.prototype.__repr__) return AST_Exit.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_Throw.prototype.__str__ = function __str__ () {\n            if(AST_Exit.prototype.__str__) return AST_Exit.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Throw.prototype, \"__bases__\", {value: [AST_Exit]});\n\n        function AST_LoopControl() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_LoopControl.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_LoopControl, AST_Jump);\n        AST_LoopControl.prototype.__init__ = function __init__ () {\n            AST_Jump.prototype.__init__ && AST_Jump.prototype.__init__.apply(this, arguments);\n        };\n        AST_LoopControl.prototype.__repr__ = function __repr__ () {\n            if(AST_Jump.prototype.__repr__) return AST_Jump.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_LoopControl.prototype.__str__ = function __str__ () {\n            if(AST_Jump.prototype.__str__) return AST_Jump.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_LoopControl.prototype, \"__bases__\", {value: [AST_Jump]});\n\n        function AST_Break() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_Break.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_Break, AST_LoopControl);\n        AST_Break.prototype.__init__ = function __init__ () {\n            AST_LoopControl.prototype.__init__ && AST_LoopControl.prototype.__init__.apply(this, arguments);\n        };\n        AST_Break.prototype.__repr__ = function __repr__ () {\n            if(AST_LoopControl.prototype.__repr__) return AST_LoopControl.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_Break.prototype.__str__ = function __str__ () {\n            if(AST_LoopControl.prototype.__str__) return AST_LoopControl.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Break.prototype, \"__bases__\", {value: [AST_LoopControl]});\n\n        function AST_Continue() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_Continue.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_Continue, AST_LoopControl);\n        AST_Continue.prototype.__init__ = function __init__ () {\n            AST_LoopControl.prototype.__init__ && AST_LoopControl.prototype.__init__.apply(this, arguments);\n        };\n        AST_Continue.prototype.__repr__ = function __repr__ () {\n            if(AST_LoopControl.prototype.__repr__) return AST_LoopControl.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_Continue.prototype.__str__ = function __str__ () {\n            if(AST_LoopControl.prototype.__str__) return AST_LoopControl.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Continue.prototype, \"__bases__\", {value: [AST_LoopControl]});\n\n        function AST_If() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_If.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_If, AST_StatementWithBody);\n        AST_If.prototype.__init__ = function __init__ () {\n            AST_StatementWithBody.prototype.__init__ && AST_StatementWithBody.prototype.__init__.apply(this, arguments);\n        };\n        AST_If.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                self.condition._walk(visitor);\n                self.body._walk(visitor);\n                if (self.alternative) {\n                    self.alternative._walk(visitor);\n                }\n            });\n        };\n        if (!AST_If.prototype._walk.__argnames__) Object.defineProperties(AST_If.prototype._walk, {\n            __argnames__ : {value: [\"visitor\"]}\n        });\n        AST_If.prototype.__repr__ = function __repr__ () {\n            if(AST_StatementWithBody.prototype.__repr__) return AST_StatementWithBody.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_If.prototype.__str__ = function __str__ () {\n            if(AST_StatementWithBody.prototype.__str__) return AST_StatementWithBody.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_If.prototype, \"__bases__\", {value: [AST_StatementWithBody]});\n        AST_If.prototype.properties = (function(){\n            var ρσ_d = Object.create(null);\n            ρσ_d[\"condition\"] = \"[AST_Node] the `if` condition\";\n            ρσ_d[\"alternative\"] = \"[AST_Statement?] the `else` part, or null if not present\";\n            return ρσ_d;\n        }).call(this);\n\n        function AST_Try() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_Try.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_Try, AST_Block);\n        AST_Try.prototype.__init__ = function __init__ () {\n            AST_Block.prototype.__init__ && AST_Block.prototype.__init__.apply(this, arguments);\n        };\n        AST_Try.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                walk_body(self, visitor);\n                if (self.bcatch) {\n                    self.bcatch._walk(visitor);\n                }\n                if (self.bfinally) {\n                    self.bfinally._walk(visitor);\n                }\n            });\n        };\n        if (!AST_Try.prototype._walk.__argnames__) Object.defineProperties(AST_Try.prototype._walk, {\n            __argnames__ : {value: [\"visitor\"]}\n        });\n        AST_Try.prototype.__repr__ = function __repr__ () {\n            if(AST_Block.prototype.__repr__) return AST_Block.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_Try.prototype.__str__ = function __str__ () {\n            if(AST_Block.prototype.__str__) return AST_Block.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Try.prototype, \"__bases__\", {value: [AST_Block]});\n        AST_Try.prototype.properties = (function(){\n            var ρσ_d = Object.create(null);\n            ρσ_d[\"bcatch\"] = \"[AST_Catch?] the catch block, or null if not present\";\n            ρσ_d[\"bfinally\"] = \"[AST_Finally?] the finally block, or null if not present\";\n            return ρσ_d;\n        }).call(this);\n\n        function AST_Catch() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_Catch.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_Catch, AST_Block);\n        AST_Catch.prototype.__init__ = function __init__ () {\n            AST_Block.prototype.__init__ && AST_Block.prototype.__init__.apply(this, arguments);\n        };\n        AST_Catch.prototype.__repr__ = function __repr__ () {\n            if(AST_Block.prototype.__repr__) return AST_Block.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_Catch.prototype.__str__ = function __str__ () {\n            if(AST_Block.prototype.__str__) return AST_Block.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Catch.prototype, \"__bases__\", {value: [AST_Block]});\n\n        function AST_Except() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_Except.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_Except, AST_Block);\n        AST_Except.prototype.__init__ = function __init__ () {\n            AST_Block.prototype.__init__ && AST_Block.prototype.__init__.apply(this, arguments);\n        };\n        AST_Except.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(this, function () {\n                var e;\n                if (self.argname) {\n                    self.argname.walk(visitor);\n                }\n                if (self.errors) {\n                    var ρσ_Iter22 = ρσ_Iterable(self.errors);\n                    for (var ρσ_Index22 = 0; ρσ_Index22 < ρσ_Iter22.length; ρσ_Index22++) {\n                        e = ρσ_Iter22[ρσ_Index22];\n                        e.walk(visitor);\n                    }\n                }\n                walk_body(self, visitor);\n            });\n        };\n        if (!AST_Except.prototype._walk.__argnames__) Object.defineProperties(AST_Except.prototype._walk, {\n            __argnames__ : {value: [\"visitor\"]}\n        });\n        AST_Except.prototype.__repr__ = function __repr__ () {\n            if(AST_Block.prototype.__repr__) return AST_Block.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_Except.prototype.__str__ = function __str__ () {\n            if(AST_Block.prototype.__str__) return AST_Block.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Except.prototype, \"__bases__\", {value: [AST_Block]});\n        AST_Except.prototype.properties = (function(){\n            var ρσ_d = Object.create(null);\n            ρσ_d[\"argname\"] = \"[AST_SymbolCatch] symbol for the exception\";\n            ρσ_d[\"errors\"] = \"[AST_SymbolVar*] error classes to catch in this block\";\n            return ρσ_d;\n        }).call(this);\n\n        function AST_Finally() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_Finally.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_Finally, AST_Block);\n        AST_Finally.prototype.__init__ = function __init__ () {\n            AST_Block.prototype.__init__ && AST_Block.prototype.__init__.apply(this, arguments);\n        };\n        AST_Finally.prototype.__repr__ = function __repr__ () {\n            if(AST_Block.prototype.__repr__) return AST_Block.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_Finally.prototype.__str__ = function __str__ () {\n            if(AST_Block.prototype.__str__) return AST_Block.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Finally.prototype, \"__bases__\", {value: [AST_Block]});\n\n        function AST_Definitions() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_Definitions.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_Definitions, AST_Statement);\n        AST_Definitions.prototype.__init__ = function __init__ () {\n            AST_Statement.prototype.__init__ && AST_Statement.prototype.__init__.apply(this, arguments);\n        };\n        AST_Definitions.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                var def_;\n                var ρσ_Iter23 = ρσ_Iterable(self.definitions);\n                for (var ρσ_Index23 = 0; ρσ_Index23 < ρσ_Iter23.length; ρσ_Index23++) {\n                    def_ = ρσ_Iter23[ρσ_Index23];\n                    def_._walk(visitor);\n                }\n            });\n        };\n        if (!AST_Definitions.prototype._walk.__argnames__) Object.defineProperties(AST_Definitions.prototype._walk, {\n            __argnames__ : {value: [\"visitor\"]}\n        });\n        AST_Definitions.prototype.__repr__ = function __repr__ () {\n            if(AST_Statement.prototype.__repr__) return AST_Statement.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_Definitions.prototype.__str__ = function __str__ () {\n            if(AST_Statement.prototype.__str__) return AST_Statement.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Definitions.prototype, \"__bases__\", {value: [AST_Statement]});\n        AST_Definitions.prototype.properties = (function(){\n            var ρσ_d = Object.create(null);\n            ρσ_d[\"definitions\"] = \"[AST_VarDef*] array of variable definitions\";\n            return ρσ_d;\n        }).call(this);\n\n        function AST_Var() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_Var.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_Var, AST_Definitions);\n        AST_Var.prototype.__init__ = function __init__ () {\n            AST_Definitions.prototype.__init__ && AST_Definitions.prototype.__init__.apply(this, arguments);\n        };\n        AST_Var.prototype.__repr__ = function __repr__ () {\n            if(AST_Definitions.prototype.__repr__) return AST_Definitions.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_Var.prototype.__str__ = function __str__ () {\n            if(AST_Definitions.prototype.__str__) return AST_Definitions.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Var.prototype, \"__bases__\", {value: [AST_Definitions]});\n\n        function AST_VarDef() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_VarDef.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_VarDef, AST_Node);\n        AST_VarDef.prototype.__init__ = function __init__ () {\n            AST_Node.prototype.__init__ && AST_Node.prototype.__init__.apply(this, arguments);\n        };\n        AST_VarDef.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                self.name._walk(visitor);\n                if (self.value) {\n                    self.value._walk(visitor);\n                }\n            });\n        };\n        if (!AST_VarDef.prototype._walk.__argnames__) Object.defineProperties(AST_VarDef.prototype._walk, {\n            __argnames__ : {value: [\"visitor\"]}\n        });\n        AST_VarDef.prototype.__repr__ = function __repr__ () {\n            if(AST_Node.prototype.__repr__) return AST_Node.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_VarDef.prototype.__str__ = function __str__ () {\n            if(AST_Node.prototype.__str__) return AST_Node.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_VarDef.prototype, \"__bases__\", {value: [AST_Node]});\n        AST_VarDef.prototype.properties = (function(){\n            var ρσ_d = Object.create(null);\n            ρσ_d[\"name\"] = \"[AST_SymbolVar|AST_SymbolNonlocal] name of the variable\";\n            ρσ_d[\"value\"] = \"[AST_Node?] initializer, or null if there's no initializer\";\n            return ρσ_d;\n        }).call(this);\n\n        function AST_BaseCall() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_BaseCall.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_BaseCall, AST_Node);\n        AST_BaseCall.prototype.__init__ = function __init__ () {\n            AST_Node.prototype.__init__ && AST_Node.prototype.__init__.apply(this, arguments);\n        };\n        AST_BaseCall.prototype.__repr__ = function __repr__ () {\n            if(AST_Node.prototype.__repr__) return AST_Node.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_BaseCall.prototype.__str__ = function __str__ () {\n            if(AST_Node.prototype.__str__) return AST_Node.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_BaseCall.prototype, \"__bases__\", {value: [AST_Node]});\n        AST_BaseCall.prototype.properties = (function(){\n            var ρσ_d = Object.create(null);\n            ρσ_d[\"args\"] = \"[AST_Node*] array of arguments\";\n            return ρσ_d;\n        }).call(this);\n\n        function AST_Call() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_Call.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_Call, AST_BaseCall);\n        AST_Call.prototype.__init__ = function __init__ () {\n            AST_BaseCall.prototype.__init__ && AST_BaseCall.prototype.__init__.apply(this, arguments);\n        };\n        AST_Call.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                var arg;\n                self.expression._walk(visitor);\n                var ρσ_Iter24 = ρσ_Iterable(self.args);\n                for (var ρσ_Index24 = 0; ρσ_Index24 < ρσ_Iter24.length; ρσ_Index24++) {\n                    arg = ρσ_Iter24[ρσ_Index24];\n                    arg._walk(visitor);\n                }\n                if (self.args.kwargs) {\n                    var ρσ_Iter25 = ρσ_Iterable(self.args.kwargs);\n                    for (var ρσ_Index25 = 0; ρσ_Index25 < ρσ_Iter25.length; ρσ_Index25++) {\n                        arg = ρσ_Iter25[ρσ_Index25];\n                        arg[0]._walk(visitor);\n                        arg[1]._walk(visitor);\n                    }\n                }\n                if (self.args.kwarg_items) {\n                    var ρσ_Iter26 = ρσ_Iterable(self.args.kwarg_items);\n                    for (var ρσ_Index26 = 0; ρσ_Index26 < ρσ_Iter26.length; ρσ_Index26++) {\n                        arg = ρσ_Iter26[ρσ_Index26];\n                        arg._walk(visitor);\n                    }\n                }\n            });\n        };\n        if (!AST_Call.prototype._walk.__argnames__) Object.defineProperties(AST_Call.prototype._walk, {\n            __argnames__ : {value: [\"visitor\"]}\n        });\n        AST_Call.prototype.__repr__ = function __repr__ () {\n            if(AST_BaseCall.prototype.__repr__) return AST_BaseCall.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_Call.prototype.__str__ = function __str__ () {\n            if(AST_BaseCall.prototype.__str__) return AST_BaseCall.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Call.prototype, \"__bases__\", {value: [AST_BaseCall]});\n        AST_Call.prototype.properties = (function(){\n            var ρσ_d = Object.create(null);\n            ρσ_d[\"expression\"] = \"[AST_Node] expression to invoke as function\";\n            return ρσ_d;\n        }).call(this);\n\n        function AST_ClassCall() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_ClassCall.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_ClassCall, AST_BaseCall);\n        AST_ClassCall.prototype.__init__ = function __init__ () {\n            AST_BaseCall.prototype.__init__ && AST_BaseCall.prototype.__init__.apply(this, arguments);\n        };\n        AST_ClassCall.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                var arg;\n                if (self.expression) self.expression._walk(visitor);\n                var ρσ_Iter27 = ρσ_Iterable(self.args);\n                for (var ρσ_Index27 = 0; ρσ_Index27 < ρσ_Iter27.length; ρσ_Index27++) {\n                    arg = ρσ_Iter27[ρσ_Index27];\n                    arg._walk(visitor);\n                }\n                var ρσ_Iter28 = ρσ_Iterable(self.args.kwargs);\n                for (var ρσ_Index28 = 0; ρσ_Index28 < ρσ_Iter28.length; ρσ_Index28++) {\n                    arg = ρσ_Iter28[ρσ_Index28];\n                    arg[0]._walk(visitor);\n                    arg[1]._walk(visitor);\n                }\n                var ρσ_Iter29 = ρσ_Iterable(self.args.kwarg_items);\n                for (var ρσ_Index29 = 0; ρσ_Index29 < ρσ_Iter29.length; ρσ_Index29++) {\n                    arg = ρσ_Iter29[ρσ_Index29];\n                    arg._walk(visitor);\n                }\n            });\n        };\n        if (!AST_ClassCall.prototype._walk.__argnames__) Object.defineProperties(AST_ClassCall.prototype._walk, {\n            __argnames__ : {value: [\"visitor\"]}\n        });\n        AST_ClassCall.prototype.__repr__ = function __repr__ () {\n            if(AST_BaseCall.prototype.__repr__) return AST_BaseCall.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_ClassCall.prototype.__str__ = function __str__ () {\n            if(AST_BaseCall.prototype.__str__) return AST_BaseCall.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_ClassCall.prototype, \"__bases__\", {value: [AST_BaseCall]});\n        AST_ClassCall.prototype.properties = (function(){\n            var ρσ_d = Object.create(null);\n            ρσ_d[\"class\"] = \"[string] name of the class method belongs to\";\n            ρσ_d[\"method\"] = \"[string] class method being called\";\n            ρσ_d[\"static\"] = \"[boolean] defines whether the method is static\";\n            return ρσ_d;\n        }).call(this);\n\n        function AST_New() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_New.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_New, AST_Call);\n        AST_New.prototype.__init__ = function __init__ () {\n            AST_Call.prototype.__init__ && AST_Call.prototype.__init__.apply(this, arguments);\n        };\n        AST_New.prototype.__repr__ = function __repr__ () {\n            if(AST_Call.prototype.__repr__) return AST_Call.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_New.prototype.__str__ = function __str__ () {\n            if(AST_Call.prototype.__str__) return AST_Call.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_New.prototype, \"__bases__\", {value: [AST_Call]});\n\n        function AST_Seq() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_Seq.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_Seq, AST_Node);\n        AST_Seq.prototype.__init__ = function __init__ () {\n            AST_Node.prototype.__init__ && AST_Node.prototype.__init__.apply(this, arguments);\n        };\n        AST_Seq.prototype.to_array = function to_array() {\n            var self = this;\n            var p, a;\n            p = self;\n            a = ρσ_list_decorate([]);\n            while (p) {\n                a.push(p.car);\n                if (p.cdr && !is_node_type(p.cdr, AST_Seq)) {\n                    a.push(p.cdr);\n                    break;\n                }\n                p = p.cdr;\n            }\n            return a;\n        };\n        if (!AST_Seq.prototype.to_array.__argnames__) Object.defineProperties(AST_Seq.prototype.to_array, {\n            __argnames__ : {value: []}\n        });\n        AST_Seq.prototype.add = function add(node) {\n            var self = this;\n            var p, cell;\n            p = self;\n            while (p) {\n                if (!is_node_type(p.cdr, AST_Seq)) {\n                    cell = AST_Seq.prototype.cons.call(p.cdr, node);\n                    return p.cdr = cell;\n                }\n                p = p.cdr;\n            }\n        };\n        if (!AST_Seq.prototype.add.__argnames__) Object.defineProperties(AST_Seq.prototype.add, {\n            __argnames__ : {value: [\"node\"]}\n        });\n        AST_Seq.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                self.car._walk(visitor);\n                if (self.cdr) {\n                    self.cdr._walk(visitor);\n                }\n            });\n        };\n        if (!AST_Seq.prototype._walk.__argnames__) Object.defineProperties(AST_Seq.prototype._walk, {\n            __argnames__ : {value: [\"visitor\"]}\n        });\n        AST_Seq.prototype.cons = function cons(x, y) {\n            var self = this;\n            var seq;\n            seq = new AST_Seq(x);\n            seq.car = x;\n            seq.cdr = y;\n            return seq;\n        };\n        if (!AST_Seq.prototype.cons.__argnames__) Object.defineProperties(AST_Seq.prototype.cons, {\n            __argnames__ : {value: [\"x\", \"y\"]}\n        });\n        AST_Seq.prototype.from_array = function from_array(array) {\n            var self = this;\n            var ans, i, p;\n            if (array.length === 0) {\n                return null;\n            }\n            if (array.length === 1) {\n                return array[0].clone();\n            }\n            ans = null;\n            for (var ρσ_Index30 = array.length - 1; ρσ_Index30 > -1; ρσ_Index30-=1) {\n                i = ρσ_Index30;\n                ans = AST_Seq.prototype.cons.call(array[(typeof i === \"number\" && i < 0) ? array.length + i : i], ans);\n            }\n            p = ans;\n            while (p) {\n                if (p.cdr && !p.cdr.cdr) {\n                    p.cdr = p.cdr.car;\n                    break;\n                }\n                p = p.cdr;\n            }\n            return ans;\n        };\n        if (!AST_Seq.prototype.from_array.__argnames__) Object.defineProperties(AST_Seq.prototype.from_array, {\n            __argnames__ : {value: [\"array\"]}\n        });\n        AST_Seq.prototype.__repr__ = function __repr__ () {\n            if(AST_Node.prototype.__repr__) return AST_Node.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_Seq.prototype.__str__ = function __str__ () {\n            if(AST_Node.prototype.__str__) return AST_Node.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Seq.prototype, \"__bases__\", {value: [AST_Node]});\n        AST_Seq.prototype.properties = (function(){\n            var ρσ_d = Object.create(null);\n            ρσ_d[\"car\"] = \"[AST_Node] first element in sequence\";\n            ρσ_d[\"cdr\"] = \"[AST_Node] second element in sequence\";\n            return ρσ_d;\n        }).call(this);\n\n        function AST_PropAccess() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_PropAccess.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_PropAccess, AST_Node);\n        AST_PropAccess.prototype.__init__ = function __init__ () {\n            AST_Node.prototype.__init__ && AST_Node.prototype.__init__.apply(this, arguments);\n        };\n        AST_PropAccess.prototype.__repr__ = function __repr__ () {\n            if(AST_Node.prototype.__repr__) return AST_Node.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_PropAccess.prototype.__str__ = function __str__ () {\n            if(AST_Node.prototype.__str__) return AST_Node.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_PropAccess.prototype, \"__bases__\", {value: [AST_Node]});\n        AST_PropAccess.prototype.properties = (function(){\n            var ρσ_d = Object.create(null);\n            ρσ_d[\"expression\"] = \"[AST_Node] the “container” expression\";\n            ρσ_d[\"property\"] = \"[AST_Node|string] the property to access.  For AST_Dot this is always a plain string, while for AST_Sub it's an arbitrary AST_Node\";\n            return ρσ_d;\n        }).call(this);\n\n        function AST_Dot() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_Dot.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_Dot, AST_PropAccess);\n        AST_Dot.prototype.__init__ = function __init__ () {\n            AST_PropAccess.prototype.__init__ && AST_PropAccess.prototype.__init__.apply(this, arguments);\n        };\n        AST_Dot.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                self.expression._walk(visitor);\n            });\n        };\n        if (!AST_Dot.prototype._walk.__argnames__) Object.defineProperties(AST_Dot.prototype._walk, {\n            __argnames__ : {value: [\"visitor\"]}\n        });\n        AST_Dot.prototype.__repr__ = function __repr__ () {\n            if(AST_PropAccess.prototype.__repr__) return AST_PropAccess.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_Dot.prototype.__str__ = function __str__ () {\n            if(AST_PropAccess.prototype.__str__) return AST_PropAccess.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Dot.prototype, \"__bases__\", {value: [AST_PropAccess]});\n\n        function AST_Sub() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_Sub.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_Sub, AST_PropAccess);\n        AST_Sub.prototype.__init__ = function __init__ () {\n            AST_PropAccess.prototype.__init__ && AST_PropAccess.prototype.__init__.apply(this, arguments);\n        };\n        AST_Sub.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                self.expression._walk(visitor);\n                self.property._walk(visitor);\n            });\n        };\n        if (!AST_Sub.prototype._walk.__argnames__) Object.defineProperties(AST_Sub.prototype._walk, {\n            __argnames__ : {value: [\"visitor\"]}\n        });\n        AST_Sub.prototype.__repr__ = function __repr__ () {\n            if(AST_PropAccess.prototype.__repr__) return AST_PropAccess.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_Sub.prototype.__str__ = function __str__ () {\n            if(AST_PropAccess.prototype.__str__) return AST_PropAccess.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Sub.prototype, \"__bases__\", {value: [AST_PropAccess]});\n\n        function AST_ItemAccess() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_ItemAccess.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_ItemAccess, AST_PropAccess);\n        AST_ItemAccess.prototype.__init__ = function __init__ () {\n            AST_PropAccess.prototype.__init__ && AST_PropAccess.prototype.__init__.apply(this, arguments);\n        };\n        AST_ItemAccess.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                self.expression._walk(visitor);\n                self.property._walk(visitor);\n                if (self.assignment) {\n                    self.assignment._walk(visitor);\n                }\n            });\n        };\n        if (!AST_ItemAccess.prototype._walk.__argnames__) Object.defineProperties(AST_ItemAccess.prototype._walk, {\n            __argnames__ : {value: [\"visitor\"]}\n        });\n        AST_ItemAccess.prototype.__repr__ = function __repr__ () {\n            if(AST_PropAccess.prototype.__repr__) return AST_PropAccess.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_ItemAccess.prototype.__str__ = function __str__ () {\n            if(AST_PropAccess.prototype.__str__) return AST_PropAccess.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_ItemAccess.prototype, \"__bases__\", {value: [AST_PropAccess]});\n        AST_ItemAccess.prototype.properties = (function(){\n            var ρσ_d = Object.create(null);\n            ρσ_d[\"assignment\"] = \"[AST_Node or None] Not None if this is an assignment (a[x] = y) rather than a simple access\";\n            return ρσ_d;\n        }).call(this);\n\n        function AST_Splice() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_Splice.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_Splice, AST_PropAccess);\n        AST_Splice.prototype.__init__ = function __init__ () {\n            AST_PropAccess.prototype.__init__ && AST_PropAccess.prototype.__init__.apply(this, arguments);\n        };\n        AST_Splice.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                self.expression._walk(visitor);\n                self.property._walk(visitor);\n                self.property2._walk(visitor);\n            });\n        };\n        if (!AST_Splice.prototype._walk.__argnames__) Object.defineProperties(AST_Splice.prototype._walk, {\n            __argnames__ : {value: [\"visitor\"]}\n        });\n        AST_Splice.prototype.__repr__ = function __repr__ () {\n            if(AST_PropAccess.prototype.__repr__) return AST_PropAccess.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_Splice.prototype.__str__ = function __str__ () {\n            if(AST_PropAccess.prototype.__str__) return AST_PropAccess.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Splice.prototype, \"__bases__\", {value: [AST_PropAccess]});\n        AST_Splice.prototype.properties = (function(){\n            var ρσ_d = Object.create(null);\n            ρσ_d[\"property2\"] = \"[AST_Node] the 2nd property to access - typically ending index for the array.\";\n            ρσ_d[\"assignment\"] = \"[AST_Node] The data being spliced in.\";\n            return ρσ_d;\n        }).call(this);\n\n        function AST_Unary() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_Unary.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_Unary, AST_Node);\n        AST_Unary.prototype.__init__ = function __init__ () {\n            AST_Node.prototype.__init__ && AST_Node.prototype.__init__.apply(this, arguments);\n        };\n        AST_Unary.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                self.expression._walk(visitor);\n            });\n        };\n        if (!AST_Unary.prototype._walk.__argnames__) Object.defineProperties(AST_Unary.prototype._walk, {\n            __argnames__ : {value: [\"visitor\"]}\n        });\n        AST_Unary.prototype.__repr__ = function __repr__ () {\n            if(AST_Node.prototype.__repr__) return AST_Node.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_Unary.prototype.__str__ = function __str__ () {\n            if(AST_Node.prototype.__str__) return AST_Node.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Unary.prototype, \"__bases__\", {value: [AST_Node]});\n        AST_Unary.prototype.properties = (function(){\n            var ρσ_d = Object.create(null);\n            ρσ_d[\"operator\"] = \"[string] the operator\";\n            ρσ_d[\"expression\"] = \"[AST_Node] expression that this unary operator applies to\";\n            return ρσ_d;\n        }).call(this);\n\n        function AST_UnaryPrefix() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_UnaryPrefix.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_UnaryPrefix, AST_Unary);\n        AST_UnaryPrefix.prototype.__init__ = function __init__ () {\n            AST_Unary.prototype.__init__ && AST_Unary.prototype.__init__.apply(this, arguments);\n        };\n        AST_UnaryPrefix.prototype.__repr__ = function __repr__ () {\n            if(AST_Unary.prototype.__repr__) return AST_Unary.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_UnaryPrefix.prototype.__str__ = function __str__ () {\n            if(AST_Unary.prototype.__str__) return AST_Unary.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_UnaryPrefix.prototype, \"__bases__\", {value: [AST_Unary]});\n\n        function AST_Binary() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_Binary.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_Binary, AST_Node);\n        AST_Binary.prototype.__init__ = function __init__ () {\n            AST_Node.prototype.__init__ && AST_Node.prototype.__init__.apply(this, arguments);\n        };\n        AST_Binary.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                self.left._walk(visitor);\n                self.right._walk(visitor);\n            });\n        };\n        if (!AST_Binary.prototype._walk.__argnames__) Object.defineProperties(AST_Binary.prototype._walk, {\n            __argnames__ : {value: [\"visitor\"]}\n        });\n        AST_Binary.prototype.__repr__ = function __repr__ () {\n            if(AST_Node.prototype.__repr__) return AST_Node.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_Binary.prototype.__str__ = function __str__ () {\n            if(AST_Node.prototype.__str__) return AST_Node.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Binary.prototype, \"__bases__\", {value: [AST_Node]});\n        AST_Binary.prototype.properties = (function(){\n            var ρσ_d = Object.create(null);\n            ρσ_d[\"left\"] = \"[AST_Node] left-hand side expression\";\n            ρσ_d[\"operator\"] = \"[string] the operator\";\n            ρσ_d[\"right\"] = \"[AST_Node] right-hand side expression\";\n            return ρσ_d;\n        }).call(this);\n\n        function AST_Existential() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_Existential.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_Existential, AST_Node);\n        AST_Existential.prototype.__init__ = function __init__ () {\n            AST_Node.prototype.__init__ && AST_Node.prototype.__init__.apply(this, arguments);\n        };\n        AST_Existential.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                self.expression._walk(visitor);\n                if (self.after !== null && typeof self.after === \"object\") {\n                    self.after._walk(visitor);\n                }\n            });\n        };\n        if (!AST_Existential.prototype._walk.__argnames__) Object.defineProperties(AST_Existential.prototype._walk, {\n            __argnames__ : {value: [\"visitor\"]}\n        });\n        AST_Existential.prototype.__repr__ = function __repr__ () {\n            if(AST_Node.prototype.__repr__) return AST_Node.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_Existential.prototype.__str__ = function __str__ () {\n            if(AST_Node.prototype.__str__) return AST_Node.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Existential.prototype, \"__bases__\", {value: [AST_Node]});\n        AST_Existential.prototype.properties = (function(){\n            var ρσ_d = Object.create(null);\n            ρσ_d[\"expression\"] = \"[AST_Node] The expression whose existence we need to check\";\n            ρσ_d[\"after\"] = \"[None|string|AST_Node] is None when there is nothing following this operator, is a string when there is as AST_PropAccess following this operator, is an AST_Node if it is used a a shorthand for the conditional ternary, i.e. a ? b == a if a? else b\";\n            return ρσ_d;\n        }).call(this);\n\n        function AST_Conditional() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_Conditional.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_Conditional, AST_Node);\n        AST_Conditional.prototype.__init__ = function __init__ () {\n            AST_Node.prototype.__init__ && AST_Node.prototype.__init__.apply(this, arguments);\n        };\n        AST_Conditional.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                self.condition._walk(visitor);\n                self.consequent._walk(visitor);\n                self.alternative._walk(visitor);\n            });\n        };\n        if (!AST_Conditional.prototype._walk.__argnames__) Object.defineProperties(AST_Conditional.prototype._walk, {\n            __argnames__ : {value: [\"visitor\"]}\n        });\n        AST_Conditional.prototype.__repr__ = function __repr__ () {\n            if(AST_Node.prototype.__repr__) return AST_Node.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_Conditional.prototype.__str__ = function __str__ () {\n            if(AST_Node.prototype.__str__) return AST_Node.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Conditional.prototype, \"__bases__\", {value: [AST_Node]});\n        AST_Conditional.prototype.properties = (function(){\n            var ρσ_d = Object.create(null);\n            ρσ_d[\"condition\"] = \"[AST_Node]\";\n            ρσ_d[\"consequent\"] = \"[AST_Node]\";\n            ρσ_d[\"alternative\"] = \"[AST_Node]\";\n            return ρσ_d;\n        }).call(this);\n\n        function AST_Assign() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_Assign.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_Assign, AST_Binary);\n        AST_Assign.prototype.__init__ = function __init__ () {\n            AST_Binary.prototype.__init__ && AST_Binary.prototype.__init__.apply(this, arguments);\n        };\n        AST_Assign.prototype.is_chained = function is_chained() {\n            var self = this;\n            return is_node_type(self.right, AST_Assign) || is_node_type(self.right, AST_Seq) && (is_node_type(self.right.car, AST_Assign) || is_node_type(self.right.cdr, AST_Assign));\n        };\n        if (!AST_Assign.prototype.is_chained.__argnames__) Object.defineProperties(AST_Assign.prototype.is_chained, {\n            __argnames__ : {value: []}\n        });\n        AST_Assign.prototype.traverse_chain = function traverse_chain() {\n            var self = this;\n            var right, left_hand_sides, next, assign;\n            right = self.right;\n            while (true) {\n                if (is_node_type(right, AST_Assign)) {\n                    right = right.right;\n                    continue;\n                }\n                if (is_node_type(right, AST_Seq)) {\n                    if (is_node_type(right.car, AST_Assign)) {\n                        right = new AST_Seq((function(){\n                            var ρσ_d = Object.create(null);\n                            ρσ_d[\"car\"] = right.car.right;\n                            ρσ_d[\"cdr\"] = right.cdr;\n                            return ρσ_d;\n                        }).call(this));\n                        continue;\n                    }\n                    if (is_node_type(right.cdr, AST_Assign)) {\n                        right = right.cdr.right;\n                        continue;\n                    }\n                }\n                break;\n            }\n            left_hand_sides = [self.left];\n            next = self.right;\n            while (true) {\n                if (is_node_type(next, AST_Assign)) {\n                    left_hand_sides.push(next.left);\n                    next = next.right;\n                    continue;\n                }\n                if (is_node_type(next, AST_Seq)) {\n                    if (is_node_type(next.cdr, AST_Assign)) {\n                        assign = next.cdr;\n                        left_hand_sides.push(new AST_Seq((function(){\n                            var ρσ_d = Object.create(null);\n                            ρσ_d[\"car\"] = next.car;\n                            ρσ_d[\"cdr\"] = assign.left;\n                            return ρσ_d;\n                        }).call(this)));\n                        next = assign.right;\n                        continue;\n                    }\n                }\n                break;\n            }\n            return [left_hand_sides, right];\n        };\n        if (!AST_Assign.prototype.traverse_chain.__argnames__) Object.defineProperties(AST_Assign.prototype.traverse_chain, {\n            __argnames__ : {value: []}\n        });\n        AST_Assign.prototype.__repr__ = function __repr__ () {\n            if(AST_Binary.prototype.__repr__) return AST_Binary.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_Assign.prototype.__str__ = function __str__ () {\n            if(AST_Binary.prototype.__str__) return AST_Binary.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Assign.prototype, \"__bases__\", {value: [AST_Binary]});\n\n        function AST_Array() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_Array.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_Array, AST_Node);\n        AST_Array.prototype.__init__ = function __init__ () {\n            AST_Node.prototype.__init__ && AST_Node.prototype.__init__.apply(this, arguments);\n        };\n        AST_Array.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                var el;\n                var ρσ_Iter31 = ρσ_Iterable(self.elements);\n                for (var ρσ_Index31 = 0; ρσ_Index31 < ρσ_Iter31.length; ρσ_Index31++) {\n                    el = ρσ_Iter31[ρσ_Index31];\n                    el._walk(visitor);\n                }\n            });\n        };\n        if (!AST_Array.prototype._walk.__argnames__) Object.defineProperties(AST_Array.prototype._walk, {\n            __argnames__ : {value: [\"visitor\"]}\n        });\n        AST_Array.prototype.flatten = function flatten() {\n            var self = this;\n            function flatten(arr) {\n                var ans, value;\n                ans = ρσ_list_decorate([]);\n                var ρσ_Iter32 = ρσ_Iterable(arr);\n                for (var ρσ_Index32 = 0; ρσ_Index32 < ρσ_Iter32.length; ρσ_Index32++) {\n                    value = ρσ_Iter32[ρσ_Index32];\n                    if (is_node_type(value, AST_Seq)) {\n                        value = value.to_array();\n                    } else if (is_node_type(value, AST_Array)) {\n                        value = value.elements;\n                    }\n                    if (Array.isArray(value)) {\n                        ans = ans.concat(flatten(value));\n                    } else {\n                        ans.push(value);\n                    }\n                }\n                return ans;\n            };\n            if (!flatten.__argnames__) Object.defineProperties(flatten, {\n                __argnames__ : {value: [\"arr\"]}\n            });\n\n            return flatten(self.elements);\n        };\n        if (!AST_Array.prototype.flatten.__argnames__) Object.defineProperties(AST_Array.prototype.flatten, {\n            __argnames__ : {value: []}\n        });\n        AST_Array.prototype.__repr__ = function __repr__ () {\n            if(AST_Node.prototype.__repr__) return AST_Node.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_Array.prototype.__str__ = function __str__ () {\n            if(AST_Node.prototype.__str__) return AST_Node.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Array.prototype, \"__bases__\", {value: [AST_Node]});\n        AST_Array.prototype.properties = (function(){\n            var ρσ_d = Object.create(null);\n            ρσ_d[\"elements\"] = \"[AST_Node*] array of elements\";\n            return ρσ_d;\n        }).call(this);\n\n        function AST_Object() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_Object.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_Object, AST_Node);\n        AST_Object.prototype.__init__ = function __init__ () {\n            AST_Node.prototype.__init__ && AST_Node.prototype.__init__.apply(this, arguments);\n        };\n        AST_Object.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                var prop;\n                var ρσ_Iter33 = ρσ_Iterable(self.properties);\n                for (var ρσ_Index33 = 0; ρσ_Index33 < ρσ_Iter33.length; ρσ_Index33++) {\n                    prop = ρσ_Iter33[ρσ_Index33];\n                    prop._walk(visitor);\n                }\n            });\n        };\n        if (!AST_Object.prototype._walk.__argnames__) Object.defineProperties(AST_Object.prototype._walk, {\n            __argnames__ : {value: [\"visitor\"]}\n        });\n        AST_Object.prototype.__repr__ = function __repr__ () {\n            if(AST_Node.prototype.__repr__) return AST_Node.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_Object.prototype.__str__ = function __str__ () {\n            if(AST_Node.prototype.__str__) return AST_Node.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Object.prototype, \"__bases__\", {value: [AST_Node]});\n        AST_Object.prototype.properties = (function(){\n            var ρσ_d = Object.create(null);\n            ρσ_d[\"properties\"] = \"[AST_ObjectProperty*] array of properties\";\n            ρσ_d[\"is_pydict\"] = \"[bool] True if this object is a python dict literal\";\n            ρσ_d[\"is_jshash\"] = \"[bool] True if this object is a js hash literal\";\n            return ρσ_d;\n        }).call(this);\n\n        function AST_ExpressiveObject() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_ExpressiveObject.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_ExpressiveObject, AST_Object);\n        AST_ExpressiveObject.prototype.__init__ = function __init__ () {\n            AST_Object.prototype.__init__ && AST_Object.prototype.__init__.apply(this, arguments);\n        };\n        AST_ExpressiveObject.prototype.__repr__ = function __repr__ () {\n            if(AST_Object.prototype.__repr__) return AST_Object.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_ExpressiveObject.prototype.__str__ = function __str__ () {\n            if(AST_Object.prototype.__str__) return AST_Object.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_ExpressiveObject.prototype, \"__bases__\", {value: [AST_Object]});\n\n        function AST_ObjectProperty() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_ObjectProperty.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_ObjectProperty, AST_Node);\n        AST_ObjectProperty.prototype.__init__ = function __init__ () {\n            AST_Node.prototype.__init__ && AST_Node.prototype.__init__.apply(this, arguments);\n        };\n        AST_ObjectProperty.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                self.key._walk(visitor);\n                self.value._walk(visitor);\n            });\n        };\n        if (!AST_ObjectProperty.prototype._walk.__argnames__) Object.defineProperties(AST_ObjectProperty.prototype._walk, {\n            __argnames__ : {value: [\"visitor\"]}\n        });\n        AST_ObjectProperty.prototype.__repr__ = function __repr__ () {\n            if(AST_Node.prototype.__repr__) return AST_Node.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_ObjectProperty.prototype.__str__ = function __str__ () {\n            if(AST_Node.prototype.__str__) return AST_Node.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_ObjectProperty.prototype, \"__bases__\", {value: [AST_Node]});\n        AST_ObjectProperty.prototype.properties = (function(){\n            var ρσ_d = Object.create(null);\n            ρσ_d[\"key\"] = \"[AST_Node] the property expression\";\n            ρσ_d[\"value\"] = \"[AST_Node] property value.  For setters and getters this is an AST_Function.\";\n            ρσ_d[\"quoted\"] = \"\";\n            return ρσ_d;\n        }).call(this);\n\n        function AST_ObjectKeyVal() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_ObjectKeyVal.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_ObjectKeyVal, AST_ObjectProperty);\n        AST_ObjectKeyVal.prototype.__init__ = function __init__ () {\n            AST_ObjectProperty.prototype.__init__ && AST_ObjectProperty.prototype.__init__.apply(this, arguments);\n        };\n        AST_ObjectKeyVal.prototype.__repr__ = function __repr__ () {\n            if(AST_ObjectProperty.prototype.__repr__) return AST_ObjectProperty.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_ObjectKeyVal.prototype.__str__ = function __str__ () {\n            if(AST_ObjectProperty.prototype.__str__) return AST_ObjectProperty.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_ObjectKeyVal.prototype, \"__bases__\", {value: [AST_ObjectProperty]});\n\n        function AST_Set() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_Set.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_Set, AST_Node);\n        AST_Set.prototype.__init__ = function __init__ () {\n            AST_Node.prototype.__init__ && AST_Node.prototype.__init__.apply(this, arguments);\n        };\n        AST_Set.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                var prop;\n                var ρσ_Iter34 = ρσ_Iterable(self.items);\n                for (var ρσ_Index34 = 0; ρσ_Index34 < ρσ_Iter34.length; ρσ_Index34++) {\n                    prop = ρσ_Iter34[ρσ_Index34];\n                    prop._walk(visitor);\n                }\n            });\n        };\n        if (!AST_Set.prototype._walk.__argnames__) Object.defineProperties(AST_Set.prototype._walk, {\n            __argnames__ : {value: [\"visitor\"]}\n        });\n        AST_Set.prototype.__repr__ = function __repr__ () {\n            if(AST_Node.prototype.__repr__) return AST_Node.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_Set.prototype.__str__ = function __str__ () {\n            if(AST_Node.prototype.__str__) return AST_Node.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Set.prototype, \"__bases__\", {value: [AST_Node]});\n        AST_Set.prototype.properties = (function(){\n            var ρσ_d = Object.create(null);\n            ρσ_d[\"items\"] = \"[AST_SetItem*] array of items\";\n            return ρσ_d;\n        }).call(this);\n\n        function AST_SetItem() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_SetItem.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_SetItem, AST_Node);\n        AST_SetItem.prototype.__init__ = function __init__ () {\n            AST_Node.prototype.__init__ && AST_Node.prototype.__init__.apply(this, arguments);\n        };\n        AST_SetItem.prototype._walk = function _walk(visitor) {\n            var self = this;\n            return visitor._visit(self, function () {\n                self.value._walk(visitor);\n            });\n        };\n        if (!AST_SetItem.prototype._walk.__argnames__) Object.defineProperties(AST_SetItem.prototype._walk, {\n            __argnames__ : {value: [\"visitor\"]}\n        });\n        AST_SetItem.prototype.__repr__ = function __repr__ () {\n            if(AST_Node.prototype.__repr__) return AST_Node.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_SetItem.prototype.__str__ = function __str__ () {\n            if(AST_Node.prototype.__str__) return AST_Node.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_SetItem.prototype, \"__bases__\", {value: [AST_Node]});\n        AST_SetItem.prototype.properties = (function(){\n            var ρσ_d = Object.create(null);\n            ρσ_d[\"value\"] = \"[AST_Node] The value of this item\";\n            return ρσ_d;\n        }).call(this);\n\n        function AST_Symbol() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_Symbol.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_Symbol, AST_Node);\n        AST_Symbol.prototype.__init__ = function __init__ () {\n            AST_Node.prototype.__init__ && AST_Node.prototype.__init__.apply(this, arguments);\n        };\n        AST_Symbol.prototype.__repr__ = function __repr__ () {\n            if(AST_Node.prototype.__repr__) return AST_Node.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_Symbol.prototype.__str__ = function __str__ () {\n            if(AST_Node.prototype.__str__) return AST_Node.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Symbol.prototype, \"__bases__\", {value: [AST_Node]});\n        AST_Symbol.prototype.properties = (function(){\n            var ρσ_d = Object.create(null);\n            ρσ_d[\"name\"] = \"[string] name of this symbol\";\n            ρσ_d[\"scope\"] = \"[AST_Scope/S] the current scope (not necessarily the definition scope)\";\n            ρσ_d[\"thedef\"] = \"[SymbolDef/S] the definition of this symbol\";\n            return ρσ_d;\n        }).call(this);\n\n        function AST_SymbolAlias() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_SymbolAlias.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_SymbolAlias, AST_Symbol);\n        AST_SymbolAlias.prototype.__init__ = function __init__ () {\n            AST_Symbol.prototype.__init__ && AST_Symbol.prototype.__init__.apply(this, arguments);\n        };\n        AST_SymbolAlias.prototype.__repr__ = function __repr__ () {\n            if(AST_Symbol.prototype.__repr__) return AST_Symbol.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_SymbolAlias.prototype.__str__ = function __str__ () {\n            if(AST_Symbol.prototype.__str__) return AST_Symbol.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_SymbolAlias.prototype, \"__bases__\", {value: [AST_Symbol]});\n\n        function AST_SymbolDeclaration() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_SymbolDeclaration.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_SymbolDeclaration, AST_Symbol);\n        AST_SymbolDeclaration.prototype.__init__ = function __init__ () {\n            AST_Symbol.prototype.__init__ && AST_Symbol.prototype.__init__.apply(this, arguments);\n        };\n        AST_SymbolDeclaration.prototype.__repr__ = function __repr__ () {\n            if(AST_Symbol.prototype.__repr__) return AST_Symbol.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_SymbolDeclaration.prototype.__str__ = function __str__ () {\n            if(AST_Symbol.prototype.__str__) return AST_Symbol.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_SymbolDeclaration.prototype, \"__bases__\", {value: [AST_Symbol]});\n        AST_SymbolDeclaration.prototype.properties = (function(){\n            var ρσ_d = Object.create(null);\n            ρσ_d[\"init\"] = \"[AST_Node*/S] array of initializers for this declaration.\";\n            return ρσ_d;\n        }).call(this);\n\n        function AST_SymbolVar() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_SymbolVar.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_SymbolVar, AST_SymbolDeclaration);\n        AST_SymbolVar.prototype.__init__ = function __init__ () {\n            AST_SymbolDeclaration.prototype.__init__ && AST_SymbolDeclaration.prototype.__init__.apply(this, arguments);\n        };\n        AST_SymbolVar.prototype.__repr__ = function __repr__ () {\n            if(AST_SymbolDeclaration.prototype.__repr__) return AST_SymbolDeclaration.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_SymbolVar.prototype.__str__ = function __str__ () {\n            if(AST_SymbolDeclaration.prototype.__str__) return AST_SymbolDeclaration.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_SymbolVar.prototype, \"__bases__\", {value: [AST_SymbolDeclaration]});\n\n        function AST_ImportedVar() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_ImportedVar.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_ImportedVar, AST_SymbolVar);\n        AST_ImportedVar.prototype.__init__ = function __init__ () {\n            AST_SymbolVar.prototype.__init__ && AST_SymbolVar.prototype.__init__.apply(this, arguments);\n        };\n        AST_ImportedVar.prototype.__repr__ = function __repr__ () {\n            if(AST_SymbolVar.prototype.__repr__) return AST_SymbolVar.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_ImportedVar.prototype.__str__ = function __str__ () {\n            if(AST_SymbolVar.prototype.__str__) return AST_SymbolVar.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_ImportedVar.prototype, \"__bases__\", {value: [AST_SymbolVar]});\n        AST_ImportedVar.prototype.properties = (function(){\n            var ρσ_d = Object.create(null);\n            ρσ_d[\"alias\"] = \"AST_SymbolAlias the alias for this imported symbol\";\n            return ρσ_d;\n        }).call(this);\n\n        function AST_SymbolNonlocal() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_SymbolNonlocal.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_SymbolNonlocal, AST_SymbolDeclaration);\n        AST_SymbolNonlocal.prototype.__init__ = function __init__ () {\n            AST_SymbolDeclaration.prototype.__init__ && AST_SymbolDeclaration.prototype.__init__.apply(this, arguments);\n        };\n        AST_SymbolNonlocal.prototype.__repr__ = function __repr__ () {\n            if(AST_SymbolDeclaration.prototype.__repr__) return AST_SymbolDeclaration.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_SymbolNonlocal.prototype.__str__ = function __str__ () {\n            if(AST_SymbolDeclaration.prototype.__str__) return AST_SymbolDeclaration.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_SymbolNonlocal.prototype, \"__bases__\", {value: [AST_SymbolDeclaration]});\n\n        function AST_SymbolFunarg() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_SymbolFunarg.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_SymbolFunarg, AST_SymbolVar);\n        AST_SymbolFunarg.prototype.__init__ = function __init__ () {\n            AST_SymbolVar.prototype.__init__ && AST_SymbolVar.prototype.__init__.apply(this, arguments);\n        };\n        AST_SymbolFunarg.prototype.__repr__ = function __repr__ () {\n            if(AST_SymbolVar.prototype.__repr__) return AST_SymbolVar.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_SymbolFunarg.prototype.__str__ = function __str__ () {\n            if(AST_SymbolVar.prototype.__str__) return AST_SymbolVar.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_SymbolFunarg.prototype, \"__bases__\", {value: [AST_SymbolVar]});\n        AST_SymbolFunarg.prototype.properties = (function(){\n            var ρσ_d = Object.create(null);\n            ρσ_d[\"annotation\"] = \"[AST_Node?] The annotation provided for this argument (if any)\";\n            return ρσ_d;\n        }).call(this);\n\n        function AST_SymbolDefun() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_SymbolDefun.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_SymbolDefun, AST_SymbolDeclaration);\n        AST_SymbolDefun.prototype.__init__ = function __init__ () {\n            AST_SymbolDeclaration.prototype.__init__ && AST_SymbolDeclaration.prototype.__init__.apply(this, arguments);\n        };\n        AST_SymbolDefun.prototype.__repr__ = function __repr__ () {\n            if(AST_SymbolDeclaration.prototype.__repr__) return AST_SymbolDeclaration.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_SymbolDefun.prototype.__str__ = function __str__ () {\n            if(AST_SymbolDeclaration.prototype.__str__) return AST_SymbolDeclaration.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_SymbolDefun.prototype, \"__bases__\", {value: [AST_SymbolDeclaration]});\n\n        function AST_SymbolLambda() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_SymbolLambda.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_SymbolLambda, AST_SymbolDeclaration);\n        AST_SymbolLambda.prototype.__init__ = function __init__ () {\n            AST_SymbolDeclaration.prototype.__init__ && AST_SymbolDeclaration.prototype.__init__.apply(this, arguments);\n        };\n        AST_SymbolLambda.prototype.__repr__ = function __repr__ () {\n            if(AST_SymbolDeclaration.prototype.__repr__) return AST_SymbolDeclaration.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_SymbolLambda.prototype.__str__ = function __str__ () {\n            if(AST_SymbolDeclaration.prototype.__str__) return AST_SymbolDeclaration.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_SymbolLambda.prototype, \"__bases__\", {value: [AST_SymbolDeclaration]});\n\n        function AST_SymbolCatch() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_SymbolCatch.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_SymbolCatch, AST_SymbolDeclaration);\n        AST_SymbolCatch.prototype.__init__ = function __init__ () {\n            AST_SymbolDeclaration.prototype.__init__ && AST_SymbolDeclaration.prototype.__init__.apply(this, arguments);\n        };\n        AST_SymbolCatch.prototype.__repr__ = function __repr__ () {\n            if(AST_SymbolDeclaration.prototype.__repr__) return AST_SymbolDeclaration.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_SymbolCatch.prototype.__str__ = function __str__ () {\n            if(AST_SymbolDeclaration.prototype.__str__) return AST_SymbolDeclaration.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_SymbolCatch.prototype, \"__bases__\", {value: [AST_SymbolDeclaration]});\n\n        function AST_SymbolRef() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_SymbolRef.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_SymbolRef, AST_Symbol);\n        AST_SymbolRef.prototype.__init__ = function __init__ () {\n            AST_Symbol.prototype.__init__ && AST_Symbol.prototype.__init__.apply(this, arguments);\n        };\n        AST_SymbolRef.prototype.__repr__ = function __repr__ () {\n            if(AST_Symbol.prototype.__repr__) return AST_Symbol.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_SymbolRef.prototype.__str__ = function __str__ () {\n            if(AST_Symbol.prototype.__str__) return AST_Symbol.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_SymbolRef.prototype, \"__bases__\", {value: [AST_Symbol]});\n        AST_SymbolRef.prototype.properties = (function(){\n            var ρσ_d = Object.create(null);\n            ρσ_d[\"parens\"] = \"[boolean/S] if true, this variable is wrapped in parentheses\";\n            return ρσ_d;\n        }).call(this);\n\n        function AST_This() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_This.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_This, AST_Symbol);\n        AST_This.prototype.__init__ = function __init__ () {\n            AST_Symbol.prototype.__init__ && AST_Symbol.prototype.__init__.apply(this, arguments);\n        };\n        AST_This.prototype.__repr__ = function __repr__ () {\n            if(AST_Symbol.prototype.__repr__) return AST_Symbol.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_This.prototype.__str__ = function __str__ () {\n            if(AST_Symbol.prototype.__str__) return AST_Symbol.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_This.prototype, \"__bases__\", {value: [AST_Symbol]});\n\n        function AST_Constant() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_Constant.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_Constant, AST_Node);\n        AST_Constant.prototype.__init__ = function __init__ () {\n            AST_Node.prototype.__init__ && AST_Node.prototype.__init__.apply(this, arguments);\n        };\n        AST_Constant.prototype.__repr__ = function __repr__ () {\n            if(AST_Node.prototype.__repr__) return AST_Node.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_Constant.prototype.__str__ = function __str__ () {\n            if(AST_Node.prototype.__str__) return AST_Node.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Constant.prototype, \"__bases__\", {value: [AST_Node]});\n\n        function AST_String() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_String.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_String, AST_Constant);\n        AST_String.prototype.__init__ = function __init__ () {\n            AST_Constant.prototype.__init__ && AST_Constant.prototype.__init__.apply(this, arguments);\n        };\n        AST_String.prototype.__repr__ = function __repr__ () {\n            if(AST_Constant.prototype.__repr__) return AST_Constant.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_String.prototype.__str__ = function __str__ () {\n            if(AST_Constant.prototype.__str__) return AST_Constant.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_String.prototype, \"__bases__\", {value: [AST_Constant]});\n        AST_String.prototype.properties = (function(){\n            var ρσ_d = Object.create(null);\n            ρσ_d[\"value\"] = \"[string] the contents of this string\";\n            return ρσ_d;\n        }).call(this);\n\n        function AST_Verbatim() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_Verbatim.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_Verbatim, AST_Constant);\n        AST_Verbatim.prototype.__init__ = function __init__ () {\n            AST_Constant.prototype.__init__ && AST_Constant.prototype.__init__.apply(this, arguments);\n        };\n        AST_Verbatim.prototype.__repr__ = function __repr__ () {\n            if(AST_Constant.prototype.__repr__) return AST_Constant.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_Verbatim.prototype.__str__ = function __str__ () {\n            if(AST_Constant.prototype.__str__) return AST_Constant.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Verbatim.prototype, \"__bases__\", {value: [AST_Constant]});\n        AST_Verbatim.prototype.properties = (function(){\n            var ρσ_d = Object.create(null);\n            ρσ_d[\"value\"] = \"[string] A string of raw JS code\";\n            return ρσ_d;\n        }).call(this);\n\n        function AST_Number() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_Number.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_Number, AST_Constant);\n        AST_Number.prototype.__init__ = function __init__ () {\n            AST_Constant.prototype.__init__ && AST_Constant.prototype.__init__.apply(this, arguments);\n        };\n        AST_Number.prototype.__repr__ = function __repr__ () {\n            if(AST_Constant.prototype.__repr__) return AST_Constant.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_Number.prototype.__str__ = function __str__ () {\n            if(AST_Constant.prototype.__str__) return AST_Constant.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Number.prototype, \"__bases__\", {value: [AST_Constant]});\n        AST_Number.prototype.properties = (function(){\n            var ρσ_d = Object.create(null);\n            ρσ_d[\"value\"] = \"[number] the numeric value\";\n            return ρσ_d;\n        }).call(this);\n\n        function AST_RegExp() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_RegExp.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_RegExp, AST_Constant);\n        AST_RegExp.prototype.__init__ = function __init__ () {\n            AST_Constant.prototype.__init__ && AST_Constant.prototype.__init__.apply(this, arguments);\n        };\n        AST_RegExp.prototype.__repr__ = function __repr__ () {\n            if(AST_Constant.prototype.__repr__) return AST_Constant.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_RegExp.prototype.__str__ = function __str__ () {\n            if(AST_Constant.prototype.__str__) return AST_Constant.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_RegExp.prototype, \"__bases__\", {value: [AST_Constant]});\n        AST_RegExp.prototype.properties = (function(){\n            var ρσ_d = Object.create(null);\n            ρσ_d[\"value\"] = \"[RegExp] the actual regexp\";\n            return ρσ_d;\n        }).call(this);\n\n        function AST_Atom() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_Atom.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_Atom, AST_Constant);\n        AST_Atom.prototype.__init__ = function __init__(initializer) {\n            var self = this;\n            if (initializer) {\n                self.start = initializer.start;\n                self.end = initializer.end;\n            }\n        };\n        if (!AST_Atom.prototype.__init__.__argnames__) Object.defineProperties(AST_Atom.prototype.__init__, {\n            __argnames__ : {value: [\"initializer\"]}\n        });\n        AST_Atom.__argnames__ = AST_Atom.prototype.__init__.__argnames__;\n        AST_Atom.__handles_kwarg_interpolation__ = AST_Atom.prototype.__init__.__handles_kwarg_interpolation__;\n        AST_Atom.prototype.__repr__ = function __repr__ () {\n            if(AST_Constant.prototype.__repr__) return AST_Constant.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_Atom.prototype.__str__ = function __str__ () {\n            if(AST_Constant.prototype.__str__) return AST_Constant.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Atom.prototype, \"__bases__\", {value: [AST_Constant]});\n\n        function AST_Null() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_Null.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_Null, AST_Atom);\n        AST_Null.prototype.__init__ = function __init__ () {\n            AST_Atom.prototype.__init__ && AST_Atom.prototype.__init__.apply(this, arguments);\n        };\n        AST_Null.prototype.__repr__ = function __repr__ () {\n            if(AST_Atom.prototype.__repr__) return AST_Atom.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_Null.prototype.__str__ = function __str__ () {\n            if(AST_Atom.prototype.__str__) return AST_Atom.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Null.prototype, \"__bases__\", {value: [AST_Atom]});\n        AST_Null.prototype.value = null;\n\n        function AST_NaN() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_NaN.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_NaN, AST_Atom);\n        AST_NaN.prototype.__init__ = function __init__ () {\n            AST_Atom.prototype.__init__ && AST_Atom.prototype.__init__.apply(this, arguments);\n        };\n        AST_NaN.prototype.__repr__ = function __repr__ () {\n            if(AST_Atom.prototype.__repr__) return AST_Atom.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_NaN.prototype.__str__ = function __str__ () {\n            if(AST_Atom.prototype.__str__) return AST_Atom.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_NaN.prototype, \"__bases__\", {value: [AST_Atom]});\n        AST_NaN.prototype.value = NaN;\n\n        function AST_Undefined() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_Undefined.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_Undefined, AST_Atom);\n        AST_Undefined.prototype.__init__ = function __init__ () {\n            AST_Atom.prototype.__init__ && AST_Atom.prototype.__init__.apply(this, arguments);\n        };\n        AST_Undefined.prototype.__repr__ = function __repr__ () {\n            if(AST_Atom.prototype.__repr__) return AST_Atom.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_Undefined.prototype.__str__ = function __str__ () {\n            if(AST_Atom.prototype.__str__) return AST_Atom.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Undefined.prototype, \"__bases__\", {value: [AST_Atom]});\n        AST_Undefined.prototype.value = undefined;\n\n        function AST_Hole() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_Hole.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_Hole, AST_Atom);\n        AST_Hole.prototype.__init__ = function __init__ () {\n            AST_Atom.prototype.__init__ && AST_Atom.prototype.__init__.apply(this, arguments);\n        };\n        AST_Hole.prototype.__repr__ = function __repr__ () {\n            if(AST_Atom.prototype.__repr__) return AST_Atom.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_Hole.prototype.__str__ = function __str__ () {\n            if(AST_Atom.prototype.__str__) return AST_Atom.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Hole.prototype, \"__bases__\", {value: [AST_Atom]});\n        AST_Hole.prototype.value = undefined;\n\n        function AST_Infinity() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_Infinity.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_Infinity, AST_Atom);\n        AST_Infinity.prototype.__init__ = function __init__ () {\n            AST_Atom.prototype.__init__ && AST_Atom.prototype.__init__.apply(this, arguments);\n        };\n        AST_Infinity.prototype.__repr__ = function __repr__ () {\n            if(AST_Atom.prototype.__repr__) return AST_Atom.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_Infinity.prototype.__str__ = function __str__ () {\n            if(AST_Atom.prototype.__str__) return AST_Atom.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Infinity.prototype, \"__bases__\", {value: [AST_Atom]});\n        AST_Infinity.prototype.value = Infinity;\n\n        function AST_Boolean() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_Boolean.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_Boolean, AST_Atom);\n        AST_Boolean.prototype.__init__ = function __init__ () {\n            AST_Atom.prototype.__init__ && AST_Atom.prototype.__init__.apply(this, arguments);\n        };\n        AST_Boolean.prototype.__repr__ = function __repr__ () {\n            if(AST_Atom.prototype.__repr__) return AST_Atom.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_Boolean.prototype.__str__ = function __str__ () {\n            if(AST_Atom.prototype.__str__) return AST_Atom.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_Boolean.prototype, \"__bases__\", {value: [AST_Atom]});\n\n        function AST_False() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_False.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_False, AST_Boolean);\n        AST_False.prototype.__init__ = function __init__ () {\n            AST_Boolean.prototype.__init__ && AST_Boolean.prototype.__init__.apply(this, arguments);\n        };\n        AST_False.prototype.__repr__ = function __repr__ () {\n            if(AST_Boolean.prototype.__repr__) return AST_Boolean.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_False.prototype.__str__ = function __str__ () {\n            if(AST_Boolean.prototype.__str__) return AST_Boolean.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_False.prototype, \"__bases__\", {value: [AST_Boolean]});\n        AST_False.prototype.value = false;\n\n        function AST_True() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            AST_True.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(AST_True, AST_Boolean);\n        AST_True.prototype.__init__ = function __init__ () {\n            AST_Boolean.prototype.__init__ && AST_Boolean.prototype.__init__.apply(this, arguments);\n        };\n        AST_True.prototype.__repr__ = function __repr__ () {\n            if(AST_Boolean.prototype.__repr__) return AST_Boolean.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        AST_True.prototype.__str__ = function __str__ () {\n            if(AST_Boolean.prototype.__str__) return AST_Boolean.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(AST_True.prototype, \"__bases__\", {value: [AST_Boolean]});\n        AST_True.prototype.value = true;\n\n        function TreeWalker() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            TreeWalker.prototype.__init__.apply(this, arguments);\n        }\n        TreeWalker.prototype.__init__ = function __init__(callback) {\n            var self = this;\n            self.visit = callback;\n            self.stack = ρσ_list_decorate([]);\n        };\n        if (!TreeWalker.prototype.__init__.__argnames__) Object.defineProperties(TreeWalker.prototype.__init__, {\n            __argnames__ : {value: [\"callback\"]}\n        });\n        TreeWalker.__argnames__ = TreeWalker.prototype.__init__.__argnames__;\n        TreeWalker.__handles_kwarg_interpolation__ = TreeWalker.prototype.__init__.__handles_kwarg_interpolation__;\n        TreeWalker.prototype._visit = function _visit(node, descend) {\n            var self = this;\n            var ret;\n            self.stack.push(node);\n            ret = self.visit(node, (descend) ? function () {\n                descend.call(node);\n            } : noop);\n            if (!ret && descend) {\n                descend.call(node);\n            }\n            self.stack.pop();\n            return ret;\n        };\n        if (!TreeWalker.prototype._visit.__argnames__) Object.defineProperties(TreeWalker.prototype._visit, {\n            __argnames__ : {value: [\"node\", \"descend\"]}\n        });\n        TreeWalker.prototype.parent = function parent(n) {\n            var self = this;\n            return (ρσ_expr_temp = self.stack)[ρσ_bound_index(self.stack.length - 2 - (n || 0), ρσ_expr_temp)];\n        };\n        if (!TreeWalker.prototype.parent.__argnames__) Object.defineProperties(TreeWalker.prototype.parent, {\n            __argnames__ : {value: [\"n\"]}\n        });\n        TreeWalker.prototype.push = function push(node) {\n            var self = this;\n            self.stack.push(node);\n        };\n        if (!TreeWalker.prototype.push.__argnames__) Object.defineProperties(TreeWalker.prototype.push, {\n            __argnames__ : {value: [\"node\"]}\n        });\n        TreeWalker.prototype.pop = function pop() {\n            var self = this;\n            return self.stack.pop();\n        };\n        if (!TreeWalker.prototype.pop.__argnames__) Object.defineProperties(TreeWalker.prototype.pop, {\n            __argnames__ : {value: []}\n        });\n        TreeWalker.prototype.self = function self() {\n            var s = this;\n            return (ρσ_expr_temp = s.stack)[ρσ_bound_index(s.stack.length - 1, ρσ_expr_temp)];\n        };\n        if (!TreeWalker.prototype.self.__argnames__) Object.defineProperties(TreeWalker.prototype.self, {\n            __argnames__ : {value: []}\n        });\n        TreeWalker.prototype.find_parent = function find_parent(type) {\n            var self = this;\n            var stack, x, i;\n            stack = self.stack;\n            for (var ρσ_Index35 = stack.length - 1; ρσ_Index35 > -1; ρσ_Index35-=1) {\n                i = ρσ_Index35;\n                x = stack[(typeof i === \"number\" && i < 0) ? stack.length + i : i];\n                if (is_node_type(x, type)) {\n                    return x;\n                }\n            }\n        };\n        if (!TreeWalker.prototype.find_parent.__argnames__) Object.defineProperties(TreeWalker.prototype.find_parent, {\n            __argnames__ : {value: [\"type\"]}\n        });\n        TreeWalker.prototype.in_boolean_context = function in_boolean_context() {\n            var self = this;\n            var stack, i, p;\n            stack = self.stack;\n            i = stack.length;\n            self = stack[ρσ_bound_index(i -= 1, stack)];\n            while (i > 0) {\n                p = stack[ρσ_bound_index(i -= 1, stack)];\n                if (is_node_type(p, AST_If) && p.condition === self || is_node_type(p, AST_Conditional) && p.condition === self || is_node_type(p, AST_DWLoop) && p.condition === self || is_node_type(p, AST_UnaryPrefix) && p.operator === \"!\" && p.expression === self) {\n                    return true;\n                }\n                if (!(is_node_type(p, AST_Binary) && (p.operator === \"&&\" || p.operator === \"||\"))) {\n                    return false;\n                }\n                self = p;\n            }\n        };\n        if (!TreeWalker.prototype.in_boolean_context.__argnames__) Object.defineProperties(TreeWalker.prototype.in_boolean_context, {\n            __argnames__ : {value: []}\n        });\n        TreeWalker.prototype.__repr__ = function __repr__ () {\n                        return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        TreeWalker.prototype.__str__ = function __str__ () {\n            return this.__repr__();\n        };\n        Object.defineProperty(TreeWalker.prototype, \"__bases__\", {value: []});\n\n        function Found() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            Found.prototype.__init__.apply(this, arguments);\n        }\n        ρσ_extends(Found, Exception);\n        Found.prototype.__init__ = function __init__ () {\n            Exception.prototype.__init__ && Exception.prototype.__init__.apply(this, arguments);\n        };\n        Found.prototype.__repr__ = function __repr__ () {\n            if(Exception.prototype.__repr__) return Exception.prototype.__repr__.call(this);\n            return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        Found.prototype.__str__ = function __str__ () {\n            if(Exception.prototype.__str__) return Exception.prototype.__str__.call(this);\nreturn this.__repr__();\n        };\n        Object.defineProperty(Found.prototype, \"__bases__\", {value: [Exception]});\n        \n\n        function has_calls(expression) {\n            if (!expression) {\n                return false;\n            }\n            try {\n                expression.walk(new TreeWalker((function() {\n                    var ρσ_anonfunc = function (node) {\n                        if (is_node_type(node, AST_BaseCall) || is_node_type(node, AST_ItemAccess)) {\n                            throw new Found;\n                        }\n                    };\n                    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                        __argnames__ : {value: [\"node\"]}\n                    });\n                    return ρσ_anonfunc;\n                })()));\n            } catch (ρσ_Exception) {\n                ρσ_last_exception = ρσ_Exception;\n                if (ρσ_Exception instanceof Found) {\n                    return true;\n                } else {\n                    throw ρσ_Exception;\n                }\n            }\n            return false;\n        };\n        if (!has_calls.__argnames__) Object.defineProperties(has_calls, {\n            __argnames__ : {value: [\"expression\"]}\n        });\n\n        ρσ_modules.ast.is_node_type = is_node_type;\n        ρσ_modules.ast.AST = AST;\n        ρσ_modules.ast.AST_Token = AST_Token;\n        ρσ_modules.ast.AST_Node = AST_Node;\n        ρσ_modules.ast.AST_Statement = AST_Statement;\n        ρσ_modules.ast.AST_Debugger = AST_Debugger;\n        ρσ_modules.ast.AST_Directive = AST_Directive;\n        ρσ_modules.ast.AST_SimpleStatement = AST_SimpleStatement;\n        ρσ_modules.ast.AST_Assert = AST_Assert;\n        ρσ_modules.ast.walk_body = walk_body;\n        ρσ_modules.ast.AST_Block = AST_Block;\n        ρσ_modules.ast.AST_BlockStatement = AST_BlockStatement;\n        ρσ_modules.ast.AST_EmptyStatement = AST_EmptyStatement;\n        ρσ_modules.ast.AST_StatementWithBody = AST_StatementWithBody;\n        ρσ_modules.ast.AST_DWLoop = AST_DWLoop;\n        ρσ_modules.ast.AST_Do = AST_Do;\n        ρσ_modules.ast.AST_While = AST_While;\n        ρσ_modules.ast.AST_ForIn = AST_ForIn;\n        ρσ_modules.ast.AST_ForJS = AST_ForJS;\n        ρσ_modules.ast.AST_ListComprehension = AST_ListComprehension;\n        ρσ_modules.ast.AST_SetComprehension = AST_SetComprehension;\n        ρσ_modules.ast.AST_DictComprehension = AST_DictComprehension;\n        ρσ_modules.ast.AST_GeneratorComprehension = AST_GeneratorComprehension;\n        ρσ_modules.ast.AST_With = AST_With;\n        ρσ_modules.ast.AST_WithClause = AST_WithClause;\n        ρσ_modules.ast.AST_Scope = AST_Scope;\n        ρσ_modules.ast.AST_Toplevel = AST_Toplevel;\n        ρσ_modules.ast.AST_Import = AST_Import;\n        ρσ_modules.ast.AST_Imports = AST_Imports;\n        ρσ_modules.ast.AST_Decorator = AST_Decorator;\n        ρσ_modules.ast.AST_Lambda = AST_Lambda;\n        ρσ_modules.ast.AST_Function = AST_Function;\n        ρσ_modules.ast.AST_Class = AST_Class;\n        ρσ_modules.ast.AST_Method = AST_Method;\n        ρσ_modules.ast.AST_Jump = AST_Jump;\n        ρσ_modules.ast.AST_Exit = AST_Exit;\n        ρσ_modules.ast.AST_Return = AST_Return;\n        ρσ_modules.ast.AST_Yield = AST_Yield;\n        ρσ_modules.ast.AST_Throw = AST_Throw;\n        ρσ_modules.ast.AST_LoopControl = AST_LoopControl;\n        ρσ_modules.ast.AST_Break = AST_Break;\n        ρσ_modules.ast.AST_Continue = AST_Continue;\n        ρσ_modules.ast.AST_If = AST_If;\n        ρσ_modules.ast.AST_Try = AST_Try;\n        ρσ_modules.ast.AST_Catch = AST_Catch;\n        ρσ_modules.ast.AST_Except = AST_Except;\n        ρσ_modules.ast.AST_Finally = AST_Finally;\n        ρσ_modules.ast.AST_Definitions = AST_Definitions;\n        ρσ_modules.ast.AST_Var = AST_Var;\n        ρσ_modules.ast.AST_VarDef = AST_VarDef;\n        ρσ_modules.ast.AST_BaseCall = AST_BaseCall;\n        ρσ_modules.ast.AST_Call = AST_Call;\n        ρσ_modules.ast.AST_ClassCall = AST_ClassCall;\n        ρσ_modules.ast.AST_New = AST_New;\n        ρσ_modules.ast.AST_Seq = AST_Seq;\n        ρσ_modules.ast.AST_PropAccess = AST_PropAccess;\n        ρσ_modules.ast.AST_Dot = AST_Dot;\n        ρσ_modules.ast.AST_Sub = AST_Sub;\n        ρσ_modules.ast.AST_ItemAccess = AST_ItemAccess;\n        ρσ_modules.ast.AST_Splice = AST_Splice;\n        ρσ_modules.ast.AST_Unary = AST_Unary;\n        ρσ_modules.ast.AST_UnaryPrefix = AST_UnaryPrefix;\n        ρσ_modules.ast.AST_Binary = AST_Binary;\n        ρσ_modules.ast.AST_Existential = AST_Existential;\n        ρσ_modules.ast.AST_Conditional = AST_Conditional;\n        ρσ_modules.ast.AST_Assign = AST_Assign;\n        ρσ_modules.ast.AST_Array = AST_Array;\n        ρσ_modules.ast.AST_Object = AST_Object;\n        ρσ_modules.ast.AST_ExpressiveObject = AST_ExpressiveObject;\n        ρσ_modules.ast.AST_ObjectProperty = AST_ObjectProperty;\n        ρσ_modules.ast.AST_ObjectKeyVal = AST_ObjectKeyVal;\n        ρσ_modules.ast.AST_Set = AST_Set;\n        ρσ_modules.ast.AST_SetItem = AST_SetItem;\n        ρσ_modules.ast.AST_Symbol = AST_Symbol;\n        ρσ_modules.ast.AST_SymbolAlias = AST_SymbolAlias;\n        ρσ_modules.ast.AST_SymbolDeclaration = AST_SymbolDeclaration;\n        ρσ_modules.ast.AST_SymbolVar = AST_SymbolVar;\n        ρσ_modules.ast.AST_ImportedVar = AST_ImportedVar;\n        ρσ_modules.ast.AST_SymbolNonlocal = AST_SymbolNonlocal;\n        ρσ_modules.ast.AST_SymbolFunarg = AST_SymbolFunarg;\n        ρσ_modules.ast.AST_SymbolDefun = AST_SymbolDefun;\n        ρσ_modules.ast.AST_SymbolLambda = AST_SymbolLambda;\n        ρσ_modules.ast.AST_SymbolCatch = AST_SymbolCatch;\n        ρσ_modules.ast.AST_SymbolRef = AST_SymbolRef;\n        ρσ_modules.ast.AST_This = AST_This;\n        ρσ_modules.ast.AST_Constant = AST_Constant;\n        ρσ_modules.ast.AST_String = AST_String;\n        ρσ_modules.ast.AST_Verbatim = AST_Verbatim;\n        ρσ_modules.ast.AST_Number = AST_Number;\n        ρσ_modules.ast.AST_RegExp = AST_RegExp;\n        ρσ_modules.ast.AST_Atom = AST_Atom;\n        ρσ_modules.ast.AST_Null = AST_Null;\n        ρσ_modules.ast.AST_NaN = AST_NaN;\n        ρσ_modules.ast.AST_Undefined = AST_Undefined;\n        ρσ_modules.ast.AST_Hole = AST_Hole;\n        ρσ_modules.ast.AST_Infinity = AST_Infinity;\n        ρσ_modules.ast.AST_Boolean = AST_Boolean;\n        ρσ_modules.ast.AST_False = AST_False;\n        ρσ_modules.ast.AST_True = AST_True;\n        ρσ_modules.ast.TreeWalker = TreeWalker;\n        ρσ_modules.ast.Found = Found;\n        ρσ_modules.ast.has_calls = has_calls;\n    })();\n\n    (function(){\n        var __name__ = \"string_interpolation\";\n        function quoted_string(x) {\n            return \"\\\"\" + x.replace(/\\\\/g, \"\\\\\\\\\").replace(/\"/g, \"\\\\\\\"\").replace(/\\n/g, \"\\\\n\") + \"\\\"\";\n        };\n        if (!quoted_string.__argnames__) Object.defineProperties(quoted_string, {\n            __argnames__ : {value: [\"x\"]}\n        });\n\n        function render_markup(markup) {\n            var ρσ_unpack, pos, key, ch, fmtspec;\n            ρσ_unpack = [0, \"\"];\n            pos = ρσ_unpack[0];\n            key = ρσ_unpack[1];\n            while (pos < markup.length) {\n                ch = markup[(typeof pos === \"number\" && pos < 0) ? markup.length + pos : pos];\n                if (ch === \"!\" || ch === \":\") {\n                    break;\n                }\n                key += ch;\n                pos += 1;\n            }\n            fmtspec = markup.slice(pos);\n            return \"ρσ_str.format(\\\"{\" + fmtspec + \"}\\\", \" + key + \")\";\n        };\n        if (!render_markup.__argnames__) Object.defineProperties(render_markup, {\n            __argnames__ : {value: [\"markup\"]}\n        });\n\n        function interpolate(template, raise_error) {\n            var pos, in_brace, markup, ans, ch;\n            pos = in_brace = 0;\n            markup = \"\";\n            ans = [\"\"];\n            while (pos < template.length) {\n                ch = template[(typeof pos === \"number\" && pos < 0) ? template.length + pos : pos];\n                if (in_brace) {\n                    if (ch === \"{\") {\n                        in_brace += 1;\n                        markup += \"{\";\n                    } else if (ch === \"}\") {\n                        in_brace -= 1;\n                        if (in_brace > 0) {\n                            markup += \"}\";\n                        } else {\n                            ans.push([markup]);\n                            ans.push(\"\");\n                        }\n                    } else {\n                        markup += ch;\n                    }\n                } else {\n                    if (ch === \"{\") {\n                        if (template[ρσ_bound_index(pos + 1, template)] === \"{\") {\n                            pos += 1;\n                            ans[ans.length-1] += \"{\";\n                        } else {\n                            in_brace = 1;\n                            markup = \"\";\n                        }\n                    } else {\n                        ans[ans.length-1] += ch;\n                    }\n                }\n                pos += 1;\n            }\n            if (in_brace) {\n                raise_error(\"expected '}' before end of string\");\n            }\n            if (ans[ans.length-1] === \"+\") {\n                ans[ans.length-1] = \"\";\n            }\n            for (var i = 0; i < ans.length; i++) {\n                if (typeof ans[(typeof i === \"number\" && i < 0) ? ans.length + i : i] === \"string\") {\n                    ans[(typeof i === \"number\" && i < 0) ? ans.length + i : i] = quoted_string(ans[(typeof i === \"number\" && i < 0) ? ans.length + i : i]);\n                } else {\n                    ans[(typeof i === \"number\" && i < 0) ? ans.length + i : i] = \"+\" + render_markup.apply(this, ans[(typeof i === \"number\" && i < 0) ? ans.length + i : i]) + \"+\";\n                }\n            }\n            return ans.join(\"\");\n        };\n        if (!interpolate.__argnames__) Object.defineProperties(interpolate, {\n            __argnames__ : {value: [\"template\", \"raise_error\"]}\n        });\n\n        ρσ_modules.string_interpolation.quoted_string = quoted_string;\n        ρσ_modules.string_interpolation.render_markup = render_markup;\n        ρσ_modules.string_interpolation.interpolate = interpolate;\n    })();\n\n    (function(){\n        var __name__ = \"tokenizer\";\n        var RE_HEX_NUMBER, RE_OCT_NUMBER, RE_DEC_NUMBER, OPERATOR_CHARS, ASCII_CONTROL_CHARS, HEX_PAT, NAME_PAT, OPERATORS, OP_MAP, WHITESPACE_CHARS, PUNC_BEFORE_EXPRESSION, PUNC_CHARS, KEYWORDS, KEYWORDS_ATOM, RESERVED_WORDS, KEYWORDS_BEFORE_EXPRESSION, ALL_KEYWORDS, IDENTIFIER_PAT, UNICODE, EX_EOF;\n        var ALIAS_MAP = ρσ_modules.unicode_aliases.ALIAS_MAP;\n\n        var make_predicate = ρσ_modules.utils.make_predicate;\n        var characters = ρσ_modules.utils.characters;\n\n        var AST_Token = ρσ_modules.ast.AST_Token;\n\n        var SyntaxError = ρσ_modules.errors.SyntaxError;\n\n        var interpolate = ρσ_modules.string_interpolation.interpolate;\n\n        RE_HEX_NUMBER = /^0x[0-9a-f]+$/i;\n        RE_OCT_NUMBER = /^0[0-7]+$/;\n        RE_DEC_NUMBER = /^\\d*\\.?\\d*(?:e[+-]?\\d*(?:\\d\\.?|\\.?\\d)\\d*)?$/i;\n        OPERATOR_CHARS = make_predicate(characters(\"+-*&%=<>!?|~^@\"));\n        ASCII_CONTROL_CHARS = (function(){\n            var ρσ_d = Object.create(null);\n            ρσ_d[\"a\"] = 7;\n            ρσ_d[\"b\"] = 8;\n            ρσ_d[\"f\"] = 12;\n            ρσ_d[\"n\"] = 10;\n            ρσ_d[\"r\"] = 13;\n            ρσ_d[\"t\"] = 9;\n            ρσ_d[\"v\"] = 11;\n            return ρσ_d;\n        }).call(this);\n        HEX_PAT = /[a-fA-F0-9]/;\n        NAME_PAT = /[a-zA-Z ]/;\n        OPERATORS = make_predicate(ρσ_list_decorate([ \"in\", \"instanceof\", \"typeof\", \"new\", \"void\", \"del\", \"+\", \"-\", \"not\", \"~\", \"&\", \"|\", \"^\", \"**\", \"*\", \"//\", \"/\", \"%\", \">>\", \"<<\", \">>>\", \"<\", \">\", \"<=\", \">=\", \"==\", \"is\", \"!=\", \"=\", \"+=\", \"-=\", \"//=\", \"/=\", \"*=\", \"%=\", \">>=\", \"<<=\", \">>>=\", \"|=\", \"^=\", \"&=\", \"and\", \"or\", \"@\", \"->\" ]));\n        OP_MAP = (function(){\n            var ρσ_d = Object.create(null);\n            ρσ_d[\"or\"] = \"||\";\n            ρσ_d[\"and\"] = \"&&\";\n            ρσ_d[\"not\"] = \"!\";\n            ρσ_d[\"del\"] = \"delete\";\n            ρσ_d[\"None\"] = \"null\";\n            ρσ_d[\"is\"] = \"===\";\n            return ρσ_d;\n        }).call(this);\n        WHITESPACE_CHARS = make_predicate(characters(\"  \\n\\r\\t\\f\\u000b​᠎           \\u202f 　\"));\n        PUNC_BEFORE_EXPRESSION = make_predicate(characters(\"[{(,.;:\"));\n        PUNC_CHARS = make_predicate(characters(\"[]{}(),;:?\"));\n        KEYWORDS = \"as assert break class continue def del do elif else except finally for from global if import in is new nonlocal pass raise return yield try while with or and not\";\n        KEYWORDS_ATOM = \"False None True\";\n        RESERVED_WORDS = \"break case class catch const continue debugger default delete do else export extends finally for function if import in instanceof new return super switch this throw try typeof var void while with yield enum implements static private package let public protected interface await null true false\";\n        KEYWORDS_BEFORE_EXPRESSION = \"return yield new del raise elif else if\";\n        ALL_KEYWORDS = KEYWORDS + \" \" + KEYWORDS_ATOM;\n        KEYWORDS = make_predicate(KEYWORDS);\n        RESERVED_WORDS = make_predicate(RESERVED_WORDS);\n        KEYWORDS_BEFORE_EXPRESSION = make_predicate(KEYWORDS_BEFORE_EXPRESSION);\n        KEYWORDS_ATOM = make_predicate(KEYWORDS_ATOM);\n        IDENTIFIER_PAT = /^[a-z_$][_a-z0-9$]*$/i;\n        function is_string_modifier(val) {\n            var ch;\n            var ρσ_Iter36 = ρσ_Iterable(val);\n            for (var ρσ_Index36 = 0; ρσ_Index36 < ρσ_Iter36.length; ρσ_Index36++) {\n                ch = ρσ_Iter36[ρσ_Index36];\n                if (\"vrufVRUF\".indexOf(ch) === -1) {\n                    return false;\n                }\n            }\n            return true;\n        };\n        if (!is_string_modifier.__argnames__) Object.defineProperties(is_string_modifier, {\n            __argnames__ : {value: [\"val\"]}\n        });\n\n        function is_letter(code) {\n            return code >= 97 && code <= 122 || code >= 65 && code <= 90 || code >= 170 && UNICODE.letter.test(String.fromCharCode(code));\n        };\n        if (!is_letter.__argnames__) Object.defineProperties(is_letter, {\n            __argnames__ : {value: [\"code\"]}\n        });\n\n        function is_digit(code) {\n            return code >= 48 && code <= 57;\n        };\n        if (!is_digit.__argnames__) Object.defineProperties(is_digit, {\n            __argnames__ : {value: [\"code\"]}\n        });\n\n        function is_alphanumeric_char(code) {\n            return is_digit(code) || is_letter(code);\n        };\n        if (!is_alphanumeric_char.__argnames__) Object.defineProperties(is_alphanumeric_char, {\n            __argnames__ : {value: [\"code\"]}\n        });\n\n        function is_unicode_combining_mark(ch) {\n            return UNICODE.non_spacing_mark.test(ch) || UNICODE.space_combining_mark.test(ch);\n        };\n        if (!is_unicode_combining_mark.__argnames__) Object.defineProperties(is_unicode_combining_mark, {\n            __argnames__ : {value: [\"ch\"]}\n        });\n\n        function is_unicode_connector_punctuation(ch) {\n            return UNICODE.connector_punctuation.test(ch);\n        };\n        if (!is_unicode_connector_punctuation.__argnames__) Object.defineProperties(is_unicode_connector_punctuation, {\n            __argnames__ : {value: [\"ch\"]}\n        });\n\n        function is_identifier(name) {\n            return !RESERVED_WORDS[(typeof name === \"number\" && name < 0) ? RESERVED_WORDS.length + name : name] && !KEYWORDS[(typeof name === \"number\" && name < 0) ? KEYWORDS.length + name : name] && !KEYWORDS_ATOM[(typeof name === \"number\" && name < 0) ? KEYWORDS_ATOM.length + name : name] && IDENTIFIER_PAT.test(name);\n        };\n        if (!is_identifier.__argnames__) Object.defineProperties(is_identifier, {\n            __argnames__ : {value: [\"name\"]}\n        });\n\n        function is_identifier_start(code) {\n            return code === 36 || code === 95 || is_letter(code);\n        };\n        if (!is_identifier_start.__argnames__) Object.defineProperties(is_identifier_start, {\n            __argnames__ : {value: [\"code\"]}\n        });\n\n        function is_identifier_char(ch) {\n            var code;\n            code = ch.charCodeAt(0);\n            return is_identifier_start(code) || is_digit(code) || code === 8204 || code === 8205 || is_unicode_combining_mark(ch) || is_unicode_connector_punctuation(ch);\n        };\n        if (!is_identifier_char.__argnames__) Object.defineProperties(is_identifier_char, {\n            __argnames__ : {value: [\"ch\"]}\n        });\n\n        function parse_js_number(num) {\n            if (RE_HEX_NUMBER.test(num)) {\n                return parseInt(num.substr(2), 16);\n            } else if (RE_OCT_NUMBER.test(num)) {\n                return parseInt(num.substr(1), 8);\n            } else if (RE_DEC_NUMBER.test(num)) {\n                return parseFloat(num);\n            }\n        };\n        if (!parse_js_number.__argnames__) Object.defineProperties(parse_js_number, {\n            __argnames__ : {value: [\"num\"]}\n        });\n\n        UNICODE = (function(){\n            var ρσ_d = Object.create(null);\n            ρσ_d[\"letter\"] = new RegExp(\"[\\\\u0041-\\\\u005A\\\\u0061-\\\\u007A\\\\u00AA\\\\u00B5\\\\u00BA\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02C1\\\\u02C6-\\\\u02D1\\\\u02E0-\\\\u02E4\\\\u02EC\\\\u02EE\\\\u0370-\\\\u0374\\\\u0376\\\\u0377\\\\u037A-\\\\u037D\\\\u0386\\\\u0388-\\\\u038A\\\\u038C\\\\u038E-\\\\u03A1\\\\u03A3-\\\\u03F5\\\\u03F7-\\\\u0481\\\\u048A-\\\\u0523\\\\u0531-\\\\u0556\\\\u0559\\\\u0561-\\\\u0587\\\\u05D0-\\\\u05EA\\\\u05F0-\\\\u05F2\\\\u0621-\\\\u064A\\\\u066E\\\\u066F\\\\u0671-\\\\u06D3\\\\u06D5\\\\u06E5\\\\u06E6\\\\u06EE\\\\u06EF\\\\u06FA-\\\\u06FC\\\\u06FF\\\\u0710\\\\u0712-\\\\u072F\\\\u074D-\\\\u07A5\\\\u07B1\\\\u07CA-\\\\u07EA\\\\u07F4\\\\u07F5\\\\u07FA\\\\u0904-\\\\u0939\\\\u093D\\\\u0950\\\\u0958-\\\\u0961\\\\u0971\\\\u0972\\\\u097B-\\\\u097F\\\\u0985-\\\\u098C\\\\u098F\\\\u0990\\\\u0993-\\\\u09A8\\\\u09AA-\\\\u09B0\\\\u09B2\\\\u09B6-\\\\u09B9\\\\u09BD\\\\u09CE\\\\u09DC\\\\u09DD\\\\u09DF-\\\\u09E1\\\\u09F0\\\\u09F1\\\\u0A05-\\\\u0A0A\\\\u0A0F\\\\u0A10\\\\u0A13-\\\\u0A28\\\\u0A2A-\\\\u0A30\\\\u0A32\\\\u0A33\\\\u0A35\\\\u0A36\\\\u0A38\\\\u0A39\\\\u0A59-\\\\u0A5C\\\\u0A5E\\\\u0A72-\\\\u0A74\\\\u0A85-\\\\u0A8D\\\\u0A8F-\\\\u0A91\\\\u0A93-\\\\u0AA8\\\\u0AAA-\\\\u0AB0\\\\u0AB2\\\\u0AB3\\\\u0AB5-\\\\u0AB9\\\\u0ABD\\\\u0AD0\\\\u0AE0\\\\u0AE1\\\\u0B05-\\\\u0B0C\\\\u0B0F\\\\u0B10\\\\u0B13-\\\\u0B28\\\\u0B2A-\\\\u0B30\\\\u0B32\\\\u0B33\\\\u0B35-\\\\u0B39\\\\u0B3D\\\\u0B5C\\\\u0B5D\\\\u0B5F-\\\\u0B61\\\\u0B71\\\\u0B83\\\\u0B85-\\\\u0B8A\\\\u0B8E-\\\\u0B90\\\\u0B92-\\\\u0B95\\\\u0B99\\\\u0B9A\\\\u0B9C\\\\u0B9E\\\\u0B9F\\\\u0BA3\\\\u0BA4\\\\u0BA8-\\\\u0BAA\\\\u0BAE-\\\\u0BB9\\\\u0BD0\\\\u0C05-\\\\u0C0C\\\\u0C0E-\\\\u0C10\\\\u0C12-\\\\u0C28\\\\u0C2A-\\\\u0C33\\\\u0C35-\\\\u0C39\\\\u0C3D\\\\u0C58\\\\u0C59\\\\u0C60\\\\u0C61\\\\u0C85-\\\\u0C8C\\\\u0C8E-\\\\u0C90\\\\u0C92-\\\\u0CA8\\\\u0CAA-\\\\u0CB3\\\\u0CB5-\\\\u0CB9\\\\u0CBD\\\\u0CDE\\\\u0CE0\\\\u0CE1\\\\u0D05-\\\\u0D0C\\\\u0D0E-\\\\u0D10\\\\u0D12-\\\\u0D28\\\\u0D2A-\\\\u0D39\\\\u0D3D\\\\u0D60\\\\u0D61\\\\u0D7A-\\\\u0D7F\\\\u0D85-\\\\u0D96\\\\u0D9A-\\\\u0DB1\\\\u0DB3-\\\\u0DBB\\\\u0DBD\\\\u0DC0-\\\\u0DC6\\\\u0E01-\\\\u0E30\\\\u0E32\\\\u0E33\\\\u0E40-\\\\u0E46\\\\u0E81\\\\u0E82\\\\u0E84\\\\u0E87\\\\u0E88\\\\u0E8A\\\\u0E8D\\\\u0E94-\\\\u0E97\\\\u0E99-\\\\u0E9F\\\\u0EA1-\\\\u0EA3\\\\u0EA5\\\\u0EA7\\\\u0EAA\\\\u0EAB\\\\u0EAD-\\\\u0EB0\\\\u0EB2\\\\u0EB3\\\\u0EBD\\\\u0EC0-\\\\u0EC4\\\\u0EC6\\\\u0EDC\\\\u0EDD\\\\u0F00\\\\u0F40-\\\\u0F47\\\\u0F49-\\\\u0F6C\\\\u0F88-\\\\u0F8B\\\\u1000-\\\\u102A\\\\u103F\\\\u1050-\\\\u1055\\\\u105A-\\\\u105D\\\\u1061\\\\u1065\\\\u1066\\\\u106E-\\\\u1070\\\\u1075-\\\\u1081\\\\u108E\\\\u10A0-\\\\u10C5\\\\u10D0-\\\\u10FA\\\\u10FC\\\\u1100-\\\\u1159\\\\u115F-\\\\u11A2\\\\u11A8-\\\\u11F9\\\\u1200-\\\\u1248\\\\u124A-\\\\u124D\\\\u1250-\\\\u1256\\\\u1258\\\\u125A-\\\\u125D\\\\u1260-\\\\u1288\\\\u128A-\\\\u128D\\\\u1290-\\\\u12B0\\\\u12B2-\\\\u12B5\\\\u12B8-\\\\u12BE\\\\u12C0\\\\u12C2-\\\\u12C5\\\\u12C8-\\\\u12D6\\\\u12D8-\\\\u1310\\\\u1312-\\\\u1315\\\\u1318-\\\\u135A\\\\u1380-\\\\u138F\\\\u13A0-\\\\u13F4\\\\u1401-\\\\u166C\\\\u166F-\\\\u1676\\\\u1681-\\\\u169A\\\\u16A0-\\\\u16EA\\\\u1700-\\\\u170C\\\\u170E-\\\\u1711\\\\u1720-\\\\u1731\\\\u1740-\\\\u1751\\\\u1760-\\\\u176C\\\\u176E-\\\\u1770\\\\u1780-\\\\u17B3\\\\u17D7\\\\u17DC\\\\u1820-\\\\u1877\\\\u1880-\\\\u18A8\\\\u18AA\\\\u1900-\\\\u191C\\\\u1950-\\\\u196D\\\\u1970-\\\\u1974\\\\u1980-\\\\u19A9\\\\u19C1-\\\\u19C7\\\\u1A00-\\\\u1A16\\\\u1B05-\\\\u1B33\\\\u1B45-\\\\u1B4B\\\\u1B83-\\\\u1BA0\\\\u1BAE\\\\u1BAF\\\\u1C00-\\\\u1C23\\\\u1C4D-\\\\u1C4F\\\\u1C5A-\\\\u1C7D\\\\u1D00-\\\\u1DBF\\\\u1E00-\\\\u1F15\\\\u1F18-\\\\u1F1D\\\\u1F20-\\\\u1F45\\\\u1F48-\\\\u1F4D\\\\u1F50-\\\\u1F57\\\\u1F59\\\\u1F5B\\\\u1F5D\\\\u1F5F-\\\\u1F7D\\\\u1F80-\\\\u1FB4\\\\u1FB6-\\\\u1FBC\\\\u1FBE\\\\u1FC2-\\\\u1FC4\\\\u1FC6-\\\\u1FCC\\\\u1FD0-\\\\u1FD3\\\\u1FD6-\\\\u1FDB\\\\u1FE0-\\\\u1FEC\\\\u1FF2-\\\\u1FF4\\\\u1FF6-\\\\u1FFC\\\\u2071\\\\u207F\\\\u2090-\\\\u2094\\\\u2102\\\\u2107\\\\u210A-\\\\u2113\\\\u2115\\\\u2119-\\\\u211D\\\\u2124\\\\u2126\\\\u2128\\\\u212A-\\\\u212D\\\\u212F-\\\\u2139\\\\u213C-\\\\u213F\\\\u2145-\\\\u2149\\\\u214E\\\\u2183\\\\u2184\\\\u2C00-\\\\u2C2E\\\\u2C30-\\\\u2C5E\\\\u2C60-\\\\u2C6F\\\\u2C71-\\\\u2C7D\\\\u2C80-\\\\u2CE4\\\\u2D00-\\\\u2D25\\\\u2D30-\\\\u2D65\\\\u2D6F\\\\u2D80-\\\\u2D96\\\\u2DA0-\\\\u2DA6\\\\u2DA8-\\\\u2DAE\\\\u2DB0-\\\\u2DB6\\\\u2DB8-\\\\u2DBE\\\\u2DC0-\\\\u2DC6\\\\u2DC8-\\\\u2DCE\\\\u2DD0-\\\\u2DD6\\\\u2DD8-\\\\u2DDE\\\\u2E2F\\\\u3005\\\\u3006\\\\u3031-\\\\u3035\\\\u303B\\\\u303C\\\\u3041-\\\\u3096\\\\u309D-\\\\u309F\\\\u30A1-\\\\u30FA\\\\u30FC-\\\\u30FF\\\\u3105-\\\\u312D\\\\u3131-\\\\u318E\\\\u31A0-\\\\u31B7\\\\u31F0-\\\\u31FF\\\\u3400\\\\u4DB5\\\\u4E00\\\\u9FC3\\\\uA000-\\\\uA48C\\\\uA500-\\\\uA60C\\\\uA610-\\\\uA61F\\\\uA62A\\\\uA62B\\\\uA640-\\\\uA65F\\\\uA662-\\\\uA66E\\\\uA67F-\\\\uA697\\\\uA717-\\\\uA71F\\\\uA722-\\\\uA788\\\\uA78B\\\\uA78C\\\\uA7FB-\\\\uA801\\\\uA803-\\\\uA805\\\\uA807-\\\\uA80A\\\\uA80C-\\\\uA822\\\\uA840-\\\\uA873\\\\uA882-\\\\uA8B3\\\\uA90A-\\\\uA925\\\\uA930-\\\\uA946\\\\uAA00-\\\\uAA28\\\\uAA40-\\\\uAA42\\\\uAA44-\\\\uAA4B\\\\uAC00\\\\uD7A3\\\\uF900-\\\\uFA2D\\\\uFA30-\\\\uFA6A\\\\uFA70-\\\\uFAD9\\\\uFB00-\\\\uFB06\\\\uFB13-\\\\uFB17\\\\uFB1D\\\\uFB1F-\\\\uFB28\\\\uFB2A-\\\\uFB36\\\\uFB38-\\\\uFB3C\\\\uFB3E\\\\uFB40\\\\uFB41\\\\uFB43\\\\uFB44\\\\uFB46-\\\\uFBB1\\\\uFBD3-\\\\uFD3D\\\\uFD50-\\\\uFD8F\\\\uFD92-\\\\uFDC7\\\\uFDF0-\\\\uFDFB\\\\uFE70-\\\\uFE74\\\\uFE76-\\\\uFEFC\\\\uFF21-\\\\uFF3A\\\\uFF41-\\\\uFF5A\\\\uFF66-\\\\uFFBE\\\\uFFC2-\\\\uFFC7\\\\uFFCA-\\\\uFFCF\\\\uFFD2-\\\\uFFD7\\\\uFFDA-\\\\uFFDC]\");\n            ρσ_d[\"non_spacing_mark\"] = new RegExp(\"[\\\\u0300-\\\\u036F\\\\u0483-\\\\u0487\\\\u0591-\\\\u05BD\\\\u05BF\\\\u05C1\\\\u05C2\\\\u05C4\\\\u05C5\\\\u05C7\\\\u0610-\\\\u061A\\\\u064B-\\\\u065E\\\\u0670\\\\u06D6-\\\\u06DC\\\\u06DF-\\\\u06E4\\\\u06E7\\\\u06E8\\\\u06EA-\\\\u06ED\\\\u0711\\\\u0730-\\\\u074A\\\\u07A6-\\\\u07B0\\\\u07EB-\\\\u07F3\\\\u0816-\\\\u0819\\\\u081B-\\\\u0823\\\\u0825-\\\\u0827\\\\u0829-\\\\u082D\\\\u0900-\\\\u0902\\\\u093C\\\\u0941-\\\\u0948\\\\u094D\\\\u0951-\\\\u0955\\\\u0962\\\\u0963\\\\u0981\\\\u09BC\\\\u09C1-\\\\u09C4\\\\u09CD\\\\u09E2\\\\u09E3\\\\u0A01\\\\u0A02\\\\u0A3C\\\\u0A41\\\\u0A42\\\\u0A47\\\\u0A48\\\\u0A4B-\\\\u0A4D\\\\u0A51\\\\u0A70\\\\u0A71\\\\u0A75\\\\u0A81\\\\u0A82\\\\u0ABC\\\\u0AC1-\\\\u0AC5\\\\u0AC7\\\\u0AC8\\\\u0ACD\\\\u0AE2\\\\u0AE3\\\\u0B01\\\\u0B3C\\\\u0B3F\\\\u0B41-\\\\u0B44\\\\u0B4D\\\\u0B56\\\\u0B62\\\\u0B63\\\\u0B82\\\\u0BC0\\\\u0BCD\\\\u0C3E-\\\\u0C40\\\\u0C46-\\\\u0C48\\\\u0C4A-\\\\u0C4D\\\\u0C55\\\\u0C56\\\\u0C62\\\\u0C63\\\\u0CBC\\\\u0CBF\\\\u0CC6\\\\u0CCC\\\\u0CCD\\\\u0CE2\\\\u0CE3\\\\u0D41-\\\\u0D44\\\\u0D4D\\\\u0D62\\\\u0D63\\\\u0DCA\\\\u0DD2-\\\\u0DD4\\\\u0DD6\\\\u0E31\\\\u0E34-\\\\u0E3A\\\\u0E47-\\\\u0E4E\\\\u0EB1\\\\u0EB4-\\\\u0EB9\\\\u0EBB\\\\u0EBC\\\\u0EC8-\\\\u0ECD\\\\u0F18\\\\u0F19\\\\u0F35\\\\u0F37\\\\u0F39\\\\u0F71-\\\\u0F7E\\\\u0F80-\\\\u0F84\\\\u0F86\\\\u0F87\\\\u0F90-\\\\u0F97\\\\u0F99-\\\\u0FBC\\\\u0FC6\\\\u102D-\\\\u1030\\\\u1032-\\\\u1037\\\\u1039\\\\u103A\\\\u103D\\\\u103E\\\\u1058\\\\u1059\\\\u105E-\\\\u1060\\\\u1071-\\\\u1074\\\\u1082\\\\u1085\\\\u1086\\\\u108D\\\\u109D\\\\u135F\\\\u1712-\\\\u1714\\\\u1732-\\\\u1734\\\\u1752\\\\u1753\\\\u1772\\\\u1773\\\\u17B7-\\\\u17BD\\\\u17C6\\\\u17C9-\\\\u17D3\\\\u17DD\\\\u180B-\\\\u180D\\\\u18A9\\\\u1920-\\\\u1922\\\\u1927\\\\u1928\\\\u1932\\\\u1939-\\\\u193B\\\\u1A17\\\\u1A18\\\\u1A56\\\\u1A58-\\\\u1A5E\\\\u1A60\\\\u1A62\\\\u1A65-\\\\u1A6C\\\\u1A73-\\\\u1A7C\\\\u1A7F\\\\u1B00-\\\\u1B03\\\\u1B34\\\\u1B36-\\\\u1B3A\\\\u1B3C\\\\u1B42\\\\u1B6B-\\\\u1B73\\\\u1B80\\\\u1B81\\\\u1BA2-\\\\u1BA5\\\\u1BA8\\\\u1BA9\\\\u1C2C-\\\\u1C33\\\\u1C36\\\\u1C37\\\\u1CD0-\\\\u1CD2\\\\u1CD4-\\\\u1CE0\\\\u1CE2-\\\\u1CE8\\\\u1CED\\\\u1DC0-\\\\u1DE6\\\\u1DFD-\\\\u1DFF\\\\u20D0-\\\\u20DC\\\\u20E1\\\\u20E5-\\\\u20F0\\\\u2CEF-\\\\u2CF1\\\\u2DE0-\\\\u2DFF\\\\u302A-\\\\u302F\\\\u3099\\\\u309A\\\\uA66F\\\\uA67C\\\\uA67D\\\\uA6F0\\\\uA6F1\\\\uA802\\\\uA806\\\\uA80B\\\\uA825\\\\uA826\\\\uA8C4\\\\uA8E0-\\\\uA8F1\\\\uA926-\\\\uA92D\\\\uA947-\\\\uA951\\\\uA980-\\\\uA982\\\\uA9B3\\\\uA9B6-\\\\uA9B9\\\\uA9BC\\\\uAA29-\\\\uAA2E\\\\uAA31\\\\uAA32\\\\uAA35\\\\uAA36\\\\uAA43\\\\uAA4C\\\\uAAB0\\\\uAAB2-\\\\uAAB4\\\\uAAB7\\\\uAAB8\\\\uAABE\\\\uAABF\\\\uAAC1\\\\uABE5\\\\uABE8\\\\uABED\\\\uFB1E\\\\uFE00-\\\\uFE0F\\\\uFE20-\\\\uFE26]\");\n            ρσ_d[\"space_combining_mark\"] = new RegExp(\"[\\\\u0903\\\\u093E-\\\\u0940\\\\u0949-\\\\u094C\\\\u094E\\\\u0982\\\\u0983\\\\u09BE-\\\\u09C0\\\\u09C7\\\\u09C8\\\\u09CB\\\\u09CC\\\\u09D7\\\\u0A03\\\\u0A3E-\\\\u0A40\\\\u0A83\\\\u0ABE-\\\\u0AC0\\\\u0AC9\\\\u0ACB\\\\u0ACC\\\\u0B02\\\\u0B03\\\\u0B3E\\\\u0B40\\\\u0B47\\\\u0B48\\\\u0B4B\\\\u0B4C\\\\u0B57\\\\u0BBE\\\\u0BBF\\\\u0BC1\\\\u0BC2\\\\u0BC6-\\\\u0BC8\\\\u0BCA-\\\\u0BCC\\\\u0BD7\\\\u0C01-\\\\u0C03\\\\u0C41-\\\\u0C44\\\\u0C82\\\\u0C83\\\\u0CBE\\\\u0CC0-\\\\u0CC4\\\\u0CC7\\\\u0CC8\\\\u0CCA\\\\u0CCB\\\\u0CD5\\\\u0CD6\\\\u0D02\\\\u0D03\\\\u0D3E-\\\\u0D40\\\\u0D46-\\\\u0D48\\\\u0D4A-\\\\u0D4C\\\\u0D57\\\\u0D82\\\\u0D83\\\\u0DCF-\\\\u0DD1\\\\u0DD8-\\\\u0DDF\\\\u0DF2\\\\u0DF3\\\\u0F3E\\\\u0F3F\\\\u0F7F\\\\u102B\\\\u102C\\\\u1031\\\\u1038\\\\u103B\\\\u103C\\\\u1056\\\\u1057\\\\u1062-\\\\u1064\\\\u1067-\\\\u106D\\\\u1083\\\\u1084\\\\u1087-\\\\u108C\\\\u108F\\\\u109A-\\\\u109C\\\\u17B6\\\\u17BE-\\\\u17C5\\\\u17C7\\\\u17C8\\\\u1923-\\\\u1926\\\\u1929-\\\\u192B\\\\u1930\\\\u1931\\\\u1933-\\\\u1938\\\\u19B0-\\\\u19C0\\\\u19C8\\\\u19C9\\\\u1A19-\\\\u1A1B\\\\u1A55\\\\u1A57\\\\u1A61\\\\u1A63\\\\u1A64\\\\u1A6D-\\\\u1A72\\\\u1B04\\\\u1B35\\\\u1B3B\\\\u1B3D-\\\\u1B41\\\\u1B43\\\\u1B44\\\\u1B82\\\\u1BA1\\\\u1BA6\\\\u1BA7\\\\u1BAA\\\\u1C24-\\\\u1C2B\\\\u1C34\\\\u1C35\\\\u1CE1\\\\u1CF2\\\\uA823\\\\uA824\\\\uA827\\\\uA880\\\\uA881\\\\uA8B4-\\\\uA8C3\\\\uA952\\\\uA953\\\\uA983\\\\uA9B4\\\\uA9B5\\\\uA9BA\\\\uA9BB\\\\uA9BD-\\\\uA9C0\\\\uAA2F\\\\uAA30\\\\uAA33\\\\uAA34\\\\uAA4D\\\\uAA7B\\\\uABE3\\\\uABE4\\\\uABE6\\\\uABE7\\\\uABE9\\\\uABEA\\\\uABEC]\");\n            ρσ_d[\"connector_punctuation\"] = new RegExp(\"[\\\\u005F\\\\u203F\\\\u2040\\\\u2054\\\\uFE33\\\\uFE34\\\\uFE4D-\\\\uFE4F\\\\uFF3F]\");\n            return ρσ_d;\n        }).call(this);\n        function is_token(token, type, val) {\n            return token.type === type && (val === null || val === undefined || token.value === val);\n        };\n        if (!is_token.__argnames__) Object.defineProperties(is_token, {\n            __argnames__ : {value: [\"token\", \"type\", \"val\"]}\n        });\n\n        EX_EOF = Object.create(null);\n        function tokenizer(raw_text, filename) {\n            var S, read_string, read_regexp;\n            S = (function(){\n                var ρσ_d = Object.create(null);\n                ρσ_d[\"text\"] = raw_text.replace(/\\r\\n?|[\\n\\u2028\\u2029]/g, \"\\n\").replace(/\\uFEFF/g, \"\");\n                ρσ_d[\"filename\"] = filename;\n                ρσ_d[\"pos\"] = 0;\n                ρσ_d[\"tokpos\"] = 0;\n                ρσ_d[\"line\"] = 1;\n                ρσ_d[\"tokline\"] = 0;\n                ρσ_d[\"col\"] = 0;\n                ρσ_d[\"tokcol\"] = 0;\n                ρσ_d[\"newline_before\"] = false;\n                ρσ_d[\"regex_allowed\"] = false;\n                ρσ_d[\"comments_before\"] = [];\n                ρσ_d[\"whitespace_before\"] = [];\n                ρσ_d[\"newblock\"] = false;\n                ρσ_d[\"endblock\"] = false;\n                ρσ_d[\"indentation_matters\"] = [ true ];\n                ρσ_d[\"cached_whitespace\"] = \"\";\n                ρσ_d[\"prev\"] = undefined;\n                ρσ_d[\"index_or_slice\"] = [ false ];\n                ρσ_d[\"expecting_object_literal_key\"] = false;\n                return ρσ_d;\n            }).call(this);\n            function peek() {\n                return S.text.charAt(S.pos);\n            };\n\n            function prevChar() {\n                return S.text.charAt(S.tokpos - 1);\n            };\n\n            function next(signal_eof, in_string) {\n                var ch;\n                ch = S.text.charAt(S.pos);\n                S.pos += 1;\n                if (signal_eof && !ch) {\n                    throw EX_EOF;\n                }\n                if (ch === \"\\n\") {\n                    S.newline_before = S.newline_before || !in_string;\n                    S.line += 1;\n                    S.col = 0;\n                } else {\n                    S.col += 1;\n                }\n                return ch;\n            };\n            if (!next.__argnames__) Object.defineProperties(next, {\n                __argnames__ : {value: [\"signal_eof\", \"in_string\"]}\n            });\n\n            function find(what, signal_eof) {\n                var pos;\n                pos = S.text.indexOf(what, S.pos);\n                if (signal_eof && pos === -1) {\n                    throw EX_EOF;\n                }\n                return pos;\n            };\n            if (!find.__argnames__) Object.defineProperties(find, {\n                __argnames__ : {value: [\"what\", \"signal_eof\"]}\n            });\n\n            function start_token() {\n                S.tokline = S.line;\n                S.tokcol = S.col;\n                S.tokpos = S.pos;\n            };\n\n            function token(type, value, is_comment, keep_newline) {\n                var ret, i;\n                S.regex_allowed = type === \"operator\" || type === \"keyword\" && KEYWORDS_BEFORE_EXPRESSION[(typeof value === \"number\" && value < 0) ? KEYWORDS_BEFORE_EXPRESSION.length + value : value] || type === \"punc\" && PUNC_BEFORE_EXPRESSION[(typeof value === \"number\" && value < 0) ? PUNC_BEFORE_EXPRESSION.length + value : value];\n                if (type === \"operator\" && value === \"is\" && S.text.substr(S.pos).trimLeft().substr(0, 4).trimRight() === \"not\") {\n                    next_token();\n                    value = \"!==\";\n                }\n                if (type === \"operator\" && OP_MAP[(typeof value === \"number\" && value < 0) ? OP_MAP.length + value : value]) {\n                    value = OP_MAP[(typeof value === \"number\" && value < 0) ? OP_MAP.length + value : value];\n                }\n                ret = (function(){\n                    var ρσ_d = Object.create(null);\n                    ρσ_d[\"type\"] = type;\n                    ρσ_d[\"value\"] = value;\n                    ρσ_d[\"line\"] = S.tokline;\n                    ρσ_d[\"col\"] = S.tokcol;\n                    ρσ_d[\"pos\"] = S.tokpos;\n                    ρσ_d[\"endpos\"] = S.pos;\n                    ρσ_d[\"nlb\"] = S.newline_before;\n                    ρσ_d[\"file\"] = filename;\n                    return ρσ_d;\n                }).call(this);\n                if (!is_comment) {\n                    ret.comments_before = S.comments_before;\n                    S.comments_before = [];\n                    for (var ρσ_Index37 = 0; ρσ_Index37 < ret.comments_before.length; ρσ_Index37++) {\n                        i = ρσ_Index37;\n                        ret.nlb = ret.nlb || (ρσ_expr_temp = ret.comments_before)[(typeof i === \"number\" && i < 0) ? ρσ_expr_temp.length + i : i].nlb;\n                    }\n                }\n                if (!keep_newline) {\n                    S.newline_before = false;\n                }\n                if (type === \"punc\") {\n                    if (value === \":\" && !(ρσ_expr_temp = S.index_or_slice)[ρσ_expr_temp.length-1] && !S.expecting_object_literal_key && (!S.text.substring(S.pos + 1, find(\"\\n\")).trim() || !S.text.substring(S.pos + 1, find(\"#\")).trim())) {\n                        S.newblock = true;\n                        S.indentation_matters.push(true);\n                    }\n                    if (value === \"[\") {\n                        if (S.prev && (S.prev.type === \"name\" || S.prev.type === \"punc\" && \")]\".indexOf(S.prev.value) !== -1)) {\n                            S.index_or_slice.push(true);\n                        } else {\n                            S.index_or_slice.push(false);\n                        }\n                        S.indentation_matters.push(false);\n                    } else if (value === \"{\" || value === \"(\") {\n                        S.indentation_matters.push(false);\n                    } else if (value === \"]\") {\n                        S.index_or_slice.pop();\n                        S.indentation_matters.pop();\n                    } else if (value === \"}\" || value === \")\") {\n                        S.indentation_matters.pop();\n                    }\n                }\n                S.prev = new AST_Token(ret);\n                return S.prev;\n            };\n            if (!token.__argnames__) Object.defineProperties(token, {\n                __argnames__ : {value: [\"type\", \"value\", \"is_comment\", \"keep_newline\"]}\n            });\n\n            function parse_whitespace() {\n                var leading_whitespace, whitespace_exists, ch;\n                leading_whitespace = \"\";\n                whitespace_exists = false;\n                while (WHITESPACE_CHARS[ρσ_bound_index(peek(), WHITESPACE_CHARS)]) {\n                    whitespace_exists = true;\n                    ch = next();\n                    if (ch === \"\\n\") {\n                        leading_whitespace = \"\";\n                    } else {\n                        leading_whitespace += ch;\n                    }\n                }\n                if (peek() !== \"#\") {\n                    if (!whitespace_exists) {\n                        leading_whitespace = S.cached_whitespace;\n                    } else {\n                        S.cached_whitespace = leading_whitespace;\n                    }\n                    if (S.newline_before || S.endblock) {\n                        return test_indent_token(leading_whitespace);\n                    }\n                }\n            };\n\n            function test_indent_token(leading_whitespace) {\n                var most_recent;\n                most_recent = (ρσ_expr_temp = S.whitespace_before)[ρσ_expr_temp.length-1] || \"\";\n                S.endblock = false;\n                if ((ρσ_expr_temp = S.indentation_matters)[ρσ_expr_temp.length-1] && leading_whitespace !== most_recent) {\n                    if (S.newblock && leading_whitespace && leading_whitespace.indexOf(most_recent) === 0) {\n                        S.newblock = false;\n                        S.whitespace_before.push(leading_whitespace);\n                        return 1;\n                    } else if (most_recent && most_recent.indexOf(leading_whitespace) === 0) {\n                        S.endblock = true;\n                        S.whitespace_before.pop();\n                        return -1;\n                    } else {\n                        parse_error(\"Inconsistent indentation\");\n                    }\n                } else {\n                    return 0;\n                }\n            };\n            if (!test_indent_token.__argnames__) Object.defineProperties(test_indent_token, {\n                __argnames__ : {value: [\"leading_whitespace\"]}\n            });\n\n            function read_while(pred) {\n                var ret, i, ch;\n                ret = \"\";\n                i = 0;\n                ch = \"\";\n                while ((ch = peek()) && pred(ch, i)) {\n                    i += 1;\n                    ret += next();\n                }\n                return ret;\n            };\n            if (!read_while.__argnames__) Object.defineProperties(read_while, {\n                __argnames__ : {value: [\"pred\"]}\n            });\n\n            function parse_error(err, is_eof) {\n                throw new SyntaxError(err, filename, S.tokline, S.tokcol, S.tokpos, is_eof);\n            };\n            if (!parse_error.__argnames__) Object.defineProperties(parse_error, {\n                __argnames__ : {value: [\"err\", \"is_eof\"]}\n            });\n\n            function read_num(prefix) {\n                var has_e, has_x, has_dot, num, valid, seen;\n                has_e = false;\n                has_x = false;\n                has_dot = prefix === \".\";\n                if (!prefix && peek() === \"0\" && S.text.charAt(S.pos + 1) === \"b\") {\n                    [next(), next()];\n                    num = read_while((function() {\n                        var ρσ_anonfunc = function (ch) {\n                            return ch === \"0\" || ch === \"1\";\n                        };\n                        if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                            __argnames__ : {value: [\"ch\"]}\n                        });\n                        return ρσ_anonfunc;\n                    })());\n                    valid = parseInt(num, 2);\n                    if (isNaN(valid)) {\n                        parse_error(\"Invalid syntax for a binary number\");\n                    }\n                    return token(\"num\", valid);\n                }\n                seen = [];\n                num = read_while((function() {\n                    var ρσ_anonfunc = function (ch, i) {\n                        seen.push(ch);\n                        if (ch === \"x\" || ch === \"X\") {\n                            if (has_x || seen.length !== 2 || seen[0] !== \"0\") {\n                                return false;\n                            }\n                            has_x = true;\n                            return true;\n                        } else if (ch === \"e\" || ch === \"E\") {\n                            if (has_x) {\n                                return true;\n                            }\n                            if (has_e || (i === 0 || typeof i === \"object\" && ρσ_equals(i, 0))) {\n                                return false;\n                            }\n                            has_e = true;\n                            return true;\n                        } else if (ch === \"-\") {\n                            if (i === 0 && !prefix) {\n                                return true;\n                            }\n                            if (has_e && seen[ρσ_bound_index(i - 1, seen)].toLowerCase() === \"e\") {\n                                return true;\n                            }\n                            return false;\n                        } else if (ch === \"+\") {\n                            if (has_e && seen[ρσ_bound_index(i - 1, seen)].toLowerCase() === \"e\") {\n                                return true;\n                            }\n                            return false;\n                        } else if (ch === \".\") {\n                            return (!has_dot && !has_x && !has_e) ? has_dot = true : false;\n                        }\n                        return is_alphanumeric_char(ch.charCodeAt(0));\n                    };\n                    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                        __argnames__ : {value: [\"ch\", \"i\"]}\n                    });\n                    return ρσ_anonfunc;\n                })());\n                if (prefix) {\n                    num = prefix + num;\n                }\n                valid = parse_js_number(num);\n                if (!isNaN(valid)) {\n                    return token(\"num\", valid);\n                } else {\n                    parse_error(\"Invalid syntax: \" + num);\n                }\n            };\n            if (!read_num.__argnames__) Object.defineProperties(read_num, {\n                __argnames__ : {value: [\"prefix\"]}\n            });\n\n            function read_hex_digits(count) {\n                var ans, nval;\n                ans = \"\";\n                while (count > 0) {\n                    count -= 1;\n                    if (!HEX_PAT.test(peek())) {\n                        return ans;\n                    }\n                    ans += next();\n                }\n                nval = parseInt(ans, 16);\n                if (nval > 1114111) {\n                    return ans;\n                }\n                return nval;\n            };\n            if (!read_hex_digits.__argnames__) Object.defineProperties(read_hex_digits, {\n                __argnames__ : {value: [\"count\"]}\n            });\n\n            function read_escape_sequence() {\n                var q, octal, code, name, key;\n                q = next(true);\n                if (q === \"\\n\") {\n                    return \"\";\n                }\n                if (q === \"\\\\\") {\n                    return q;\n                }\n                if (\"\\\"'\".indexOf(q) !== -1) {\n                    return q;\n                }\n                if (ASCII_CONTROL_CHARS[(typeof q === \"number\" && q < 0) ? ASCII_CONTROL_CHARS.length + q : q]) {\n                    return String.fromCharCode(ASCII_CONTROL_CHARS[(typeof q === \"number\" && q < 0) ? ASCII_CONTROL_CHARS.length + q : q]);\n                }\n                if (\"0\" <= q && q <= \"7\") {\n                    octal = q;\n                    if (\"0\" <= (ρσ_cond_temp = peek()) && ρσ_cond_temp <= \"7\") {\n                        octal += next();\n                    }\n                    if (\"0\" <= (ρσ_cond_temp = peek()) && ρσ_cond_temp <= \"7\") {\n                        octal += next();\n                    }\n                    code = parseInt(octal, 8);\n                    if (isNaN(code)) {\n                        return \"\\\\\" + octal;\n                    }\n                    return String.fromCharCode(code);\n                }\n                if (q === \"x\") {\n                    code = read_hex_digits(2);\n                    if (typeof code === \"number\") {\n                        return String.fromCharCode(code);\n                    }\n                    return \"\\\\x\" + code;\n                }\n                if (q === \"u\") {\n                    code = read_hex_digits(4);\n                    if (typeof code === \"number\") {\n                        return String.fromCharCode(code);\n                    }\n                    return \"\\\\u\" + code;\n                }\n                if (q === \"U\") {\n                    code = read_hex_digits(8);\n                    if (typeof code === \"number\") {\n                        if (code <= 65535) {\n                            return String.fromCharCode(code);\n                        }\n                        code -= 65536;\n                        return String.fromCharCode(55296 + (code >> 10), 56320 + (code & 1023));\n                    }\n                    return \"\\\\U\" + code;\n                }\n                if (q === \"N\" && peek() === \"{\") {\n                    next();\n                    name = read_while((function() {\n                        var ρσ_anonfunc = function (ch) {\n                            return NAME_PAT.test(ch);\n                        };\n                        if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                            __argnames__ : {value: [\"ch\"]}\n                        });\n                        return ρσ_anonfunc;\n                    })());\n                    if (peek() !== \"}\") {\n                        return \"\\\\N{\" + name;\n                    }\n                    next();\n                    key = (name || \"\").toLowerCase();\n                    if (!name || !Object.prototype.hasOwnProperty.call(ALIAS_MAP, key)) {\n                        return \"\\\\N{\" + name + \"}\";\n                    }\n                    code = ALIAS_MAP[(typeof key === \"number\" && key < 0) ? ALIAS_MAP.length + key : key];\n                    if (code <= 65535) {\n                        return String.fromCharCode(code);\n                    }\n                    code -= 65536;\n                    return String.fromCharCode(55296 + (code >> 10), 56320 + (code & 1023));\n                }\n                return \"\\\\\" + q;\n            };\n\n            function with_eof_error(eof_error, cont) {\n                return function () {\n                    try {\n                        return cont.apply(null, arguments);\n                    } catch (ρσ_Exception) {\n                        ρσ_last_exception = ρσ_Exception;\n                        {\n                            var ex = ρσ_Exception;\n                            if (ex === EX_EOF) {\n                                parse_error(eof_error, true);\n                            } else {\n                                throw ρσ_Exception;\n                            }\n                        } \n                    }\n                };\n            };\n            if (!with_eof_error.__argnames__) Object.defineProperties(with_eof_error, {\n                __argnames__ : {value: [\"eof_error\", \"cont\"]}\n            });\n\n            read_string = with_eof_error(\"Unterminated string constant\", (function() {\n                var ρσ_anonfunc = function (is_raw_literal, is_js_literal) {\n                    var quote, tok_type, ret, is_multiline, ch;\n                    quote = next();\n                    tok_type = (is_js_literal) ? \"js\" : \"string\";\n                    ret = \"\";\n                    is_multiline = false;\n                    if (peek() === quote) {\n                        next(true);\n                        if (peek() === quote) {\n                            next(true);\n                            is_multiline = true;\n                        } else {\n                            return token(tok_type, \"\");\n                        }\n                    }\n                    while (ch = next(true, true)) {\n                        if (ch === \"\\n\" && !is_multiline) {\n                            parse_error(\"End of line while scanning string literal\");\n                        }\n                        if (ch === \"\\\\\") {\n                            ret += (is_raw_literal) ? \"\\\\\" + next(true) : read_escape_sequence();\n                            continue;\n                        }\n                        if (ch === quote) {\n                            if (!is_multiline) {\n                                break;\n                            }\n                            if (peek() === quote) {\n                                next();\n                                if (peek() === quote) {\n                                    next();\n                                    break;\n                                } else {\n                                    ch += quote;\n                                }\n                            }\n                        }\n                        ret += ch;\n                    }\n                    return token(tok_type, ret);\n                };\n                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                    __argnames__ : {value: [\"is_raw_literal\", \"is_js_literal\"]}\n                });\n                return ρσ_anonfunc;\n            })());\n            function handle_interpolated_string(string, start_tok) {\n                function raise_error(err) {\n                    throw new SyntaxError(err, filename, start_tok.line, start_tok.col, start_tok.pos, false);\n                };\n                if (!raise_error.__argnames__) Object.defineProperties(raise_error, {\n                    __argnames__ : {value: [\"err\"]}\n                });\n\n                S.text = S.text.slice(0, S.pos) + \"(\" + interpolate(string, raise_error) + \")\" + S.text.slice(S.pos);\n                return token(\"punc\", next());\n            };\n            if (!handle_interpolated_string.__argnames__) Object.defineProperties(handle_interpolated_string, {\n                __argnames__ : {value: [\"string\", \"start_tok\"]}\n            });\n\n            function read_line_comment(shebang) {\n                var i, ret;\n                if (!shebang) {\n                    next();\n                }\n                i = find(\"\\n\");\n                if (i === -1) {\n                    ret = S.text.substr(S.pos);\n                    S.pos = S.text.length;\n                } else {\n                    ret = S.text.substring(S.pos, i);\n                    S.pos = i;\n                }\n                return token((shebang) ? \"shebang\" : \"comment1\", ret, true);\n            };\n            if (!read_line_comment.__argnames__) Object.defineProperties(read_line_comment, {\n                __argnames__ : {value: [\"shebang\"]}\n            });\n\n            function read_name() {\n                var name, ch;\n                name = ch = \"\";\n                while ((ch = peek()) !== null) {\n                    if (ch === \"\\\\\") {\n                        if (S.text.charAt(S.pos + 1) === \"\\n\") {\n                            S.pos += 2;\n                            continue;\n                        }\n                        break;\n                    } else if (is_identifier_char(ch)) {\n                        name += next();\n                    } else {\n                        break;\n                    }\n                }\n                return name;\n            };\n\n            read_regexp = with_eof_error(\"Unterminated regular expression\", function () {\n                var prev_backslash, regexp, ch, in_class, verbose_regexp, in_comment, mods;\n                prev_backslash = false;\n                regexp = ch = \"\";\n                in_class = false;\n                verbose_regexp = false;\n                in_comment = false;\n                if (peek() === \"/\") {\n                    next(true);\n                    if (peek() === \"/\") {\n                        verbose_regexp = true;\n                        next(true);\n                    } else {\n                        mods = read_name();\n                        return token(\"regexp\", new RegExp(regexp, mods));\n                    }\n                }\n                while (ch = next(true)) {\n                    if (in_comment) {\n                        if (ch === \"\\n\") {\n                            in_comment = false;\n                        }\n                        continue;\n                    }\n                    if (prev_backslash) {\n                        regexp += \"\\\\\" + ch;\n                        prev_backslash = false;\n                    } else if (ch === \"[\") {\n                        in_class = true;\n                        regexp += ch;\n                    } else if (ch === \"]\" && in_class) {\n                        in_class = false;\n                        regexp += ch;\n                    } else if (ch === \"/\" && !in_class) {\n                        if (verbose_regexp) {\n                            if (peek() !== \"/\") {\n                                regexp += \"\\\\/\";\n                                continue;\n                            }\n                            next(true);\n                            if (peek() !== \"/\") {\n                                regexp += \"\\\\/\\\\/\";\n                                continue;\n                            }\n                            next(true);\n                        }\n                        break;\n                    } else if (ch === \"\\\\\") {\n                        prev_backslash = true;\n                    } else if (verbose_regexp && !in_class && \" \\n\\r\\t\".indexOf(ch) !== -1) {\n                    } else if (verbose_regexp && !in_class && ch === \"#\") {\n                        in_comment = true;\n                    } else {\n                        regexp += ch;\n                    }\n                }\n                mods = read_name();\n                return token(\"regexp\", new RegExp(regexp, mods));\n            });\n            function read_operator(prefix) {\n                var op;\n                function grow(op) {\n                    var bigger;\n                    if (!peek()) {\n                        return op;\n                    }\n                    bigger = op + peek();\n                    if (OPERATORS[(typeof bigger === \"number\" && bigger < 0) ? OPERATORS.length + bigger : bigger]) {\n                        next();\n                        return grow(bigger);\n                    } else {\n                        return op;\n                    }\n                };\n                if (!grow.__argnames__) Object.defineProperties(grow, {\n                    __argnames__ : {value: [\"op\"]}\n                });\n\n                op = grow(prefix || next());\n                if (op === \"->\") {\n                    return token(\"punc\", op);\n                }\n                return token(\"operator\", op);\n            };\n            if (!read_operator.__argnames__) Object.defineProperties(read_operator, {\n                __argnames__ : {value: [\"prefix\"]}\n            });\n\n            function handle_slash() {\n                next();\n                return (S.regex_allowed) ? read_regexp(\"\") : read_operator(\"/\");\n            };\n\n            function handle_dot() {\n                next();\n                return (is_digit(peek().charCodeAt(0))) ? read_num(\".\") : token(\"punc\", \".\");\n            };\n\n            function read_word() {\n                var word;\n                word = read_name();\n                return (KEYWORDS_ATOM[(typeof word === \"number\" && word < 0) ? KEYWORDS_ATOM.length + word : word]) ? token(\"atom\", word) : (!KEYWORDS[(typeof word === \"number\" && word < 0) ? KEYWORDS.length + word : word]) ? token(\"name\", word) : (OPERATORS[(typeof word === \"number\" && word < 0) ? OPERATORS.length + word : word] && prevChar() !== \".\") ? token(\"operator\", word) : token(\"keyword\", word);\n            };\n\n            function next_token() {\n                var indent, ch, code, tmp_, regex_allowed, tok, mods, start_pos_for_string, stok;\n                indent = parse_whitespace();\n                if (indent === -1) {\n                    return token(\"punc\", \"}\", false, true);\n                }\n                start_token();\n                ch = peek();\n                if (!ch) {\n                    return token(\"eof\");\n                }\n                code = ch.charCodeAt(0);\n                tmp_ = code;\n                if (tmp_ === 34 || tmp_ === 39) {\n                    return read_string(false);\n                } else if (tmp_ === 35) {\n                    if (S.pos === 0 && S.text.charAt(1) === \"!\") {\n                        return read_line_comment(true);\n                    }\n                    regex_allowed = S.regex_allowed;\n                    S.comments_before.push(read_line_comment());\n                    S.regex_allowed = regex_allowed;\n                    return next_token();\n                } else if (tmp_ === 46) {\n                    return handle_dot();\n                } else if (tmp_ === 47) {\n                    return handle_slash();\n                }\n                if (is_digit(code)) {\n                    return read_num();\n                }\n                if (PUNC_CHARS[(typeof ch === \"number\" && ch < 0) ? PUNC_CHARS.length + ch : ch]) {\n                    return token(\"punc\", next());\n                }\n                if (OPERATOR_CHARS[(typeof ch === \"number\" && ch < 0) ? OPERATOR_CHARS.length + ch : ch]) {\n                    return read_operator();\n                }\n                if (code === 92 && S.text.charAt(S.pos + 1) === \"\\n\") {\n                    next();\n                    next();\n                    S.newline_before = false;\n                    return next_token();\n                }\n                if (is_identifier_start(code)) {\n                    tok = read_word();\n                    if (\"'\\\"\".indexOf(peek()) !== -1 && is_string_modifier(tok.value)) {\n                        mods = tok.value.toLowerCase();\n                        start_pos_for_string = S.tokpos;\n                        stok = read_string(mods.indexOf(\"r\") !== -1, mods.indexOf(\"v\") !== -1);\n                        tok.endpos = stok.endpos;\n                        if (stok.type !== \"js\" && mods.indexOf(\"f\") !== -1) {\n                            tok.col += start_pos_for_string - tok.pos;\n                            return handle_interpolated_string(stok.value, tok);\n                        }\n                        tok.value = stok.value;\n                        tok.type = stok.type;\n                    }\n                    return tok;\n                }\n                parse_error(\"Unexpected character «\" + ch + \"»\");\n            };\n\n            next_token.context = (function() {\n                var ρσ_anonfunc = function (nc) {\n                    if (nc) {\n                        S = nc;\n                    }\n                    return S;\n                };\n                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                    __argnames__ : {value: [\"nc\"]}\n                });\n                return ρσ_anonfunc;\n            })();\n            return next_token;\n        };\n        if (!tokenizer.__argnames__) Object.defineProperties(tokenizer, {\n            __argnames__ : {value: [\"raw_text\", \"filename\"]}\n        });\n\n        ρσ_modules.tokenizer.RE_HEX_NUMBER = RE_HEX_NUMBER;\n        ρσ_modules.tokenizer.RE_OCT_NUMBER = RE_OCT_NUMBER;\n        ρσ_modules.tokenizer.RE_DEC_NUMBER = RE_DEC_NUMBER;\n        ρσ_modules.tokenizer.OPERATOR_CHARS = OPERATOR_CHARS;\n        ρσ_modules.tokenizer.ASCII_CONTROL_CHARS = ASCII_CONTROL_CHARS;\n        ρσ_modules.tokenizer.HEX_PAT = HEX_PAT;\n        ρσ_modules.tokenizer.NAME_PAT = NAME_PAT;\n        ρσ_modules.tokenizer.OPERATORS = OPERATORS;\n        ρσ_modules.tokenizer.OP_MAP = OP_MAP;\n        ρσ_modules.tokenizer.WHITESPACE_CHARS = WHITESPACE_CHARS;\n        ρσ_modules.tokenizer.PUNC_BEFORE_EXPRESSION = PUNC_BEFORE_EXPRESSION;\n        ρσ_modules.tokenizer.PUNC_CHARS = PUNC_CHARS;\n        ρσ_modules.tokenizer.KEYWORDS = KEYWORDS;\n        ρσ_modules.tokenizer.KEYWORDS_ATOM = KEYWORDS_ATOM;\n        ρσ_modules.tokenizer.RESERVED_WORDS = RESERVED_WORDS;\n        ρσ_modules.tokenizer.KEYWORDS_BEFORE_EXPRESSION = KEYWORDS_BEFORE_EXPRESSION;\n        ρσ_modules.tokenizer.ALL_KEYWORDS = ALL_KEYWORDS;\n        ρσ_modules.tokenizer.IDENTIFIER_PAT = IDENTIFIER_PAT;\n        ρσ_modules.tokenizer.UNICODE = UNICODE;\n        ρσ_modules.tokenizer.EX_EOF = EX_EOF;\n        ρσ_modules.tokenizer.is_string_modifier = is_string_modifier;\n        ρσ_modules.tokenizer.is_letter = is_letter;\n        ρσ_modules.tokenizer.is_digit = is_digit;\n        ρσ_modules.tokenizer.is_alphanumeric_char = is_alphanumeric_char;\n        ρσ_modules.tokenizer.is_unicode_combining_mark = is_unicode_combining_mark;\n        ρσ_modules.tokenizer.is_unicode_connector_punctuation = is_unicode_connector_punctuation;\n        ρσ_modules.tokenizer.is_identifier = is_identifier;\n        ρσ_modules.tokenizer.is_identifier_start = is_identifier_start;\n        ρσ_modules.tokenizer.is_identifier_char = is_identifier_char;\n        ρσ_modules.tokenizer.parse_js_number = parse_js_number;\n        ρσ_modules.tokenizer.is_token = is_token;\n        ρσ_modules.tokenizer.tokenizer = tokenizer;\n    })();\n\n    (function(){\n        var __name__ = \"parse\";\n        var COMPILER_VERSION, PYTHON_FLAGS, NATIVE_CLASSES, ERROR_CLASSES, COMMON_STATIC, FORBIDDEN_CLASS_VARS, UNARY_PREFIX, ASSIGNMENT, PRECEDENCE, STATEMENTS_WITH_LABELS, ATOMIC_START_TOKEN, compile_time_decorators;\n        var make_predicate = ρσ_modules.utils.make_predicate;\n        var array_to_hash = ρσ_modules.utils.array_to_hash;\n        var defaults = ρσ_modules.utils.defaults;\n        var has_prop = ρσ_modules.utils.has_prop;\n        var cache_file_name = ρσ_modules.utils.cache_file_name;\n\n        var SyntaxError = ρσ_modules.errors.SyntaxError;\n        var ImportError = ρσ_modules.errors.ImportError;\n\n        var AST_Array = ρσ_modules.ast.AST_Array;\n        var AST_Assign = ρσ_modules.ast.AST_Assign;\n        var AST_Binary = ρσ_modules.ast.AST_Binary;\n        var AST_BlockStatement = ρσ_modules.ast.AST_BlockStatement;\n        var AST_Break = ρσ_modules.ast.AST_Break;\n        var AST_Call = ρσ_modules.ast.AST_Call;\n        var AST_Catch = ρσ_modules.ast.AST_Catch;\n        var AST_Class = ρσ_modules.ast.AST_Class;\n        var AST_ClassCall = ρσ_modules.ast.AST_ClassCall;\n        var AST_Conditional = ρσ_modules.ast.AST_Conditional;\n        var AST_Constant = ρσ_modules.ast.AST_Constant;\n        var AST_Continue = ρσ_modules.ast.AST_Continue;\n        var AST_DWLoop = ρσ_modules.ast.AST_DWLoop;\n        var AST_Debugger = ρσ_modules.ast.AST_Debugger;\n        var AST_Decorator = ρσ_modules.ast.AST_Decorator;\n        var AST_Definitions = ρσ_modules.ast.AST_Definitions;\n        var AST_DictComprehension = ρσ_modules.ast.AST_DictComprehension;\n        var AST_Directive = ρσ_modules.ast.AST_Directive;\n        var AST_Do = ρσ_modules.ast.AST_Do;\n        var AST_Dot = ρσ_modules.ast.AST_Dot;\n        var AST_EmptyStatement = ρσ_modules.ast.AST_EmptyStatement;\n        var AST_Except = ρσ_modules.ast.AST_Except;\n        var AST_ExpressiveObject = ρσ_modules.ast.AST_ExpressiveObject;\n        var AST_False = ρσ_modules.ast.AST_False;\n        var AST_Finally = ρσ_modules.ast.AST_Finally;\n        var AST_ForIn = ρσ_modules.ast.AST_ForIn;\n        var AST_ForJS = ρσ_modules.ast.AST_ForJS;\n        var AST_Function = ρσ_modules.ast.AST_Function;\n        var AST_GeneratorComprehension = ρσ_modules.ast.AST_GeneratorComprehension;\n        var AST_Hole = ρσ_modules.ast.AST_Hole;\n        var AST_If = ρσ_modules.ast.AST_If;\n        var AST_Import = ρσ_modules.ast.AST_Import;\n        var AST_ImportedVar = ρσ_modules.ast.AST_ImportedVar;\n        var AST_Imports = ρσ_modules.ast.AST_Imports;\n        var AST_ListComprehension = ρσ_modules.ast.AST_ListComprehension;\n        var AST_Method = ρσ_modules.ast.AST_Method;\n        var AST_New = ρσ_modules.ast.AST_New;\n        var AST_Null = ρσ_modules.ast.AST_Null;\n        var AST_Number = ρσ_modules.ast.AST_Number;\n        var AST_Object = ρσ_modules.ast.AST_Object;\n        var AST_ObjectKeyVal = ρσ_modules.ast.AST_ObjectKeyVal;\n        var AST_PropAccess = ρσ_modules.ast.AST_PropAccess;\n        var AST_RegExp = ρσ_modules.ast.AST_RegExp;\n        var AST_Return = ρσ_modules.ast.AST_Return;\n        var AST_Scope = ρσ_modules.ast.AST_Scope;\n        var AST_Set = ρσ_modules.ast.AST_Set;\n        var AST_SetComprehension = ρσ_modules.ast.AST_SetComprehension;\n        var AST_SetItem = ρσ_modules.ast.AST_SetItem;\n        var AST_Seq = ρσ_modules.ast.AST_Seq;\n        var AST_SimpleStatement = ρσ_modules.ast.AST_SimpleStatement;\n        var AST_Splice = ρσ_modules.ast.AST_Splice;\n        var AST_String = ρσ_modules.ast.AST_String;\n        var AST_Sub = ρσ_modules.ast.AST_Sub;\n        var AST_ItemAccess = ρσ_modules.ast.AST_ItemAccess;\n        var AST_SymbolAlias = ρσ_modules.ast.AST_SymbolAlias;\n        var AST_SymbolCatch = ρσ_modules.ast.AST_SymbolCatch;\n        var AST_SymbolDefun = ρσ_modules.ast.AST_SymbolDefun;\n        var AST_SymbolFunarg = ρσ_modules.ast.AST_SymbolFunarg;\n        var AST_SymbolLambda = ρσ_modules.ast.AST_SymbolLambda;\n        var AST_SymbolNonlocal = ρσ_modules.ast.AST_SymbolNonlocal;\n        var AST_SymbolRef = ρσ_modules.ast.AST_SymbolRef;\n        var AST_SymbolVar = ρσ_modules.ast.AST_SymbolVar;\n        var AST_This = ρσ_modules.ast.AST_This;\n        var AST_Throw = ρσ_modules.ast.AST_Throw;\n        var AST_Toplevel = ρσ_modules.ast.AST_Toplevel;\n        var AST_True = ρσ_modules.ast.AST_True;\n        var AST_Try = ρσ_modules.ast.AST_Try;\n        var AST_UnaryPrefix = ρσ_modules.ast.AST_UnaryPrefix;\n        var AST_Undefined = ρσ_modules.ast.AST_Undefined;\n        var AST_Var = ρσ_modules.ast.AST_Var;\n        var AST_VarDef = ρσ_modules.ast.AST_VarDef;\n        var AST_Verbatim = ρσ_modules.ast.AST_Verbatim;\n        var AST_While = ρσ_modules.ast.AST_While;\n        var AST_With = ρσ_modules.ast.AST_With;\n        var AST_WithClause = ρσ_modules.ast.AST_WithClause;\n        var AST_Yield = ρσ_modules.ast.AST_Yield;\n        var AST_Assert = ρσ_modules.ast.AST_Assert;\n        var AST_Existential = ρσ_modules.ast.AST_Existential;\n        var is_node_type = ρσ_modules.ast.is_node_type;\n\n        var tokenizer = ρσ_modules.tokenizer.tokenizer;\n        var is_token = ρσ_modules.tokenizer.is_token;\n        var RESERVED_WORDS = ρσ_modules.tokenizer.RESERVED_WORDS;\n\n        COMPILER_VERSION = \"8422d7fe5f1a0d447dcdd3834e2c6390a0db2358\";\n        PYTHON_FLAGS = (function(){\n            var ρσ_d = Object.create(null);\n            ρσ_d[\"dict_literals\"] = true;\n            ρσ_d[\"overload_getitem\"] = true;\n            ρσ_d[\"bound_methods\"] = true;\n            ρσ_d[\"hash_literals\"] = true;\n            return ρσ_d;\n        }).call(this);\n        NATIVE_CLASSES = (function(){\n            var ρσ_d = Object.create(null);\n            ρσ_d[\"Image\"] = Object.create(null);\n            ρσ_d[\"RegExp\"] = Object.create(null);\n            ρσ_d[\"Error\"] = Object.create(null);\n            ρσ_d[\"EvalError\"] = Object.create(null);\n            ρσ_d[\"InternalError\"] = Object.create(null);\n            ρσ_d[\"RangeError\"] = Object.create(null);\n            ρσ_d[\"ReferenceError\"] = Object.create(null);\n            ρσ_d[\"SyntaxError\"] = Object.create(null);\n            ρσ_d[\"TypeError\"] = Object.create(null);\n            ρσ_d[\"URIError\"] = Object.create(null);\n            ρσ_d[\"Object\"] = (function(){\n                var ρσ_d = Object.create(null);\n                ρσ_d[\"static\"] = ρσ_list_decorate([ \"getOwnPropertyNames\", \"getOwnPropertyDescriptor\", \"getOwnPropertySymbols\", \"keys\", \"create\", \"defineProperty\", \"defineProperties\", \"getPrototypeOf\", \"setPrototypeOf\", \"assign\" ]);\n                return ρσ_d;\n            }).call(this);\n            ρσ_d[\"String\"] = (function(){\n                var ρσ_d = Object.create(null);\n                ρσ_d[\"static\"] = ρσ_list_decorate([ \"fromCharCode\" ]);\n                return ρσ_d;\n            }).call(this);\n            ρσ_d[\"Array\"] = (function(){\n                var ρσ_d = Object.create(null);\n                ρσ_d[\"static\"] = ρσ_list_decorate([ \"isArray\", \"from\", \"of\" ]);\n                return ρσ_d;\n            }).call(this);\n            ρσ_d[\"Function\"] = Object.create(null);\n            ρσ_d[\"Date\"] = (function(){\n                var ρσ_d = Object.create(null);\n                ρσ_d[\"static\"] = ρσ_list_decorate([ \"UTC\", \"now\", \"parse\" ]);\n                return ρσ_d;\n            }).call(this);\n            ρσ_d[\"ArrayBuffer\"] = Object.create(null);\n            ρσ_d[\"DataView\"] = Object.create(null);\n            ρσ_d[\"Float32Array\"] = Object.create(null);\n            ρσ_d[\"Float64Array\"] = Object.create(null);\n            ρσ_d[\"Int16Array\"] = Object.create(null);\n            ρσ_d[\"Int32Array\"] = Object.create(null);\n            ρσ_d[\"Int8Array\"] = Object.create(null);\n            ρσ_d[\"Uint16Array\"] = Object.create(null);\n            ρσ_d[\"Uint32Array\"] = Object.create(null);\n            ρσ_d[\"Uint8Array\"] = Object.create(null);\n            ρσ_d[\"Uint8ClampedArray\"] = Object.create(null);\n            ρσ_d[\"Map\"] = Object.create(null);\n            ρσ_d[\"WeakMap\"] = Object.create(null);\n            ρσ_d[\"Proxy\"] = Object.create(null);\n            ρσ_d[\"Set\"] = Object.create(null);\n            ρσ_d[\"WeakSet\"] = Object.create(null);\n            ρσ_d[\"WebSocket\"] = Object.create(null);\n            ρσ_d[\"XMLHttpRequest\"] = Object.create(null);\n            ρσ_d[\"TextEncoder\"] = Object.create(null);\n            ρσ_d[\"TextDecoder\"] = Object.create(null);\n            ρσ_d[\"MouseEvent\"] = Object.create(null);\n            ρσ_d[\"Event\"] = Object.create(null);\n            ρσ_d[\"CustomEvent\"] = Object.create(null);\n            ρσ_d[\"Blob\"] = Object.create(null);\n            return ρσ_d;\n        }).call(this);\n        ERROR_CLASSES = (function(){\n            var ρσ_d = Object.create(null);\n            ρσ_d[\"Exception\"] = Object.create(null);\n            ρσ_d[\"AttributeError\"] = Object.create(null);\n            ρσ_d[\"IndexError\"] = Object.create(null);\n            ρσ_d[\"KeyError\"] = Object.create(null);\n            ρσ_d[\"ValueError\"] = Object.create(null);\n            ρσ_d[\"UnicodeDecodeError\"] = Object.create(null);\n            ρσ_d[\"AssertionError\"] = Object.create(null);\n            ρσ_d[\"ZeroDivisionError\"] = Object.create(null);\n            return ρσ_d;\n        }).call(this);\n        COMMON_STATIC = ρσ_list_decorate([ \"call\", \"apply\", \"bind\", \"toString\" ]);\n        FORBIDDEN_CLASS_VARS = \"prototype constructor\".split(\" \");\n        UNARY_PREFIX = make_predicate(\"typeof void delete ~ - + ! @\");\n        ASSIGNMENT = make_predicate(\"= += -= /= //= *= %= >>= <<= >>>= |= ^= &=\");\n        PRECEDENCE = (function() {\n            var ρσ_anonfunc = function (a, ret) {\n                var b, j, i;\n                for (var ρσ_Index38 = 0; ρσ_Index38 < a.length; ρσ_Index38++) {\n                    i = ρσ_Index38;\n                    b = a[(typeof i === \"number\" && i < 0) ? a.length + i : i];\n                    for (var ρσ_Index39 = 0; ρσ_Index39 < b.length; ρσ_Index39++) {\n                        j = ρσ_Index39;\n                        ret[ρσ_bound_index(b[(typeof j === \"number\" && j < 0) ? b.length + j : j], ret)] = i + 1;\n                    }\n                }\n                return ret;\n            };\n            if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                __argnames__ : {value: [\"a\", \"ret\"]}\n            });\n            return ρσ_anonfunc;\n        })()(ρσ_list_decorate([ ρσ_list_decorate([ \"||\" ]), ρσ_list_decorate([ \"&&\" ]), ρσ_list_decorate([ \"|\" ]), ρσ_list_decorate([ \"^\" ]), ρσ_list_decorate([ \"&\" ]), ρσ_list_decorate([ \"==\", \"===\", \"!=\", \"!==\" ]), ρσ_list_decorate([ \"<\", \">\", \"<=\", \">=\", \"in\", \"instanceof\" ]), ρσ_list_decorate([ \">>\", \"<<\", \">>>\" ]), ρσ_list_decorate([ \"+\", \"-\" ]), ρσ_list_decorate([ \"*\", \"/\", \"//\", \"%\" ]), ρσ_list_decorate([ \"**\" ]) ]), Object.create(null));\n        STATEMENTS_WITH_LABELS = array_to_hash(ρσ_list_decorate([ \"for\", \"do\", \"while\", \"switch\" ]));\n        ATOMIC_START_TOKEN = array_to_hash(ρσ_list_decorate([ \"atom\", \"num\", \"string\", \"regexp\", \"name\", \"js\" ]));\n        compile_time_decorators = ρσ_list_decorate([ \"staticmethod\", \"external\", \"property\" ]);\n        function has_simple_decorator(decorators, name) {\n            var remove, s;\n            remove = [];\n            for (var i = 0; i < decorators.length; i++) {\n                s = decorators[(typeof i === \"number\" && i < 0) ? decorators.length + i : i];\n                if (is_node_type(s, AST_SymbolRef) && !s.parens && s.name === name) {\n                    remove.push(i);\n                }\n            }\n            if (remove.length) {\n                remove.reverse();\n                for (var i = 0; i < remove.length; i++) {\n                    decorators.splice(remove[(typeof i === \"number\" && i < 0) ? remove.length + i : i], 1);\n                }\n                return true;\n            }\n            return false;\n        };\n        if (!has_simple_decorator.__argnames__) Object.defineProperties(has_simple_decorator, {\n            __argnames__ : {value: [\"decorators\", \"name\"]}\n        });\n\n        function has_setter_decorator(decorators, name) {\n            var remove, s;\n            remove = [];\n            for (var i = 0; i < decorators.length; i++) {\n                s = decorators[(typeof i === \"number\" && i < 0) ? decorators.length + i : i];\n                if (is_node_type(s, AST_Dot) && is_node_type(s.expression, AST_SymbolRef) && s.expression.name === name && s.property === \"setter\") {\n                    remove.push(i);\n                }\n            }\n            if (remove.length) {\n                remove.reverse();\n                for (var i = 0; i < remove.length; i++) {\n                    decorators.splice(remove[(typeof i === \"number\" && i < 0) ? remove.length + i : i], 1);\n                }\n                return true;\n            }\n            return false;\n        };\n        if (!has_setter_decorator.__argnames__) Object.defineProperties(has_setter_decorator, {\n            __argnames__ : {value: [\"decorators\", \"name\"]}\n        });\n\n        function create_parser_ctx(S, import_dirs, module_id, baselib_items, imported_module_ids, imported_modules, importing_modules, options) {\n            function next() {\n                S.prev = S.token;\n                if (S.peeked.length) {\n                    S.token = S.peeked.shift();\n                } else {\n                    S.token = S.input();\n                }\n                return S.token;\n            };\n\n            function is_(type, value) {\n                return is_token(S.token, type, value);\n            };\n            if (!is_.__argnames__) Object.defineProperties(is_, {\n                __argnames__ : {value: [\"type\", \"value\"]}\n            });\n\n            function peek() {\n                if (!S.peeked.length) {\n                    S.peeked.push(S.input());\n                }\n                return S.peeked[0];\n            };\n\n            function prev() {\n                return S.prev;\n            };\n\n            function croak(msg, line, col, pos, is_eof) {\n                var ctx;\n                ctx = S.input.context();\n                throw new SyntaxError(msg, ctx.filename, (line !== undefined) ? line : ctx.tokline, (col !== undefined) ? col : ctx.tokcol, (pos !== undefined) ? pos : ctx.tokpos, is_eof);\n            };\n            if (!croak.__argnames__) Object.defineProperties(croak, {\n                __argnames__ : {value: [\"msg\", \"line\", \"col\", \"pos\", \"is_eof\"]}\n            });\n\n            function token_error(token, msg) {\n                var is_eof;\n                is_eof = token.type === \"eof\";\n                croak(msg, token.line, token.col, undefined, is_eof);\n            };\n            if (!token_error.__argnames__) Object.defineProperties(token_error, {\n                __argnames__ : {value: [\"token\", \"msg\"]}\n            });\n\n            function unexpected(token) {\n                if (token === undefined) {\n                    token = S.token;\n                }\n                token_error(token, \"Unexpected token: \" + token.type + \" «\" + token.value + \"»\");\n            };\n            if (!unexpected.__argnames__) Object.defineProperties(unexpected, {\n                __argnames__ : {value: [\"token\"]}\n            });\n\n            function expect_token(type, val) {\n                if (is_(type, val)) {\n                    return next();\n                }\n                token_error(S.token, \"Unexpected token \" + S.token.type + \" «\" + S.token.value + \"»\" + \", expected \" + type + \" «\" + val + \"»\");\n            };\n            if (!expect_token.__argnames__) Object.defineProperties(expect_token, {\n                __argnames__ : {value: [\"type\", \"val\"]}\n            });\n\n            function expect(punc) {\n                return expect_token(\"punc\", punc);\n            };\n            if (!expect.__argnames__) Object.defineProperties(expect, {\n                __argnames__ : {value: [\"punc\"]}\n            });\n\n            function semicolon() {\n                if (is_(\"punc\", \";\")) {\n                    next();\n                    S.token.nlb = true;\n                }\n            };\n\n            function embed_tokens(parser) {\n                function with_embedded_tokens() {\n                    var start, expr, end;\n                    start = S.token;\n                    expr = parser();\n                    if (expr === undefined) {\n                        unexpected();\n                    }\n                    end = prev();\n                    expr.start = start;\n                    expr.end = end;\n                    return expr;\n                };\n\n                return with_embedded_tokens;\n            };\n            if (!embed_tokens.__argnames__) Object.defineProperties(embed_tokens, {\n                __argnames__ : {value: [\"parser\"]}\n            });\n\n            function scan_for_top_level_callables(body) {\n                var ans, opt, x, obj;\n                ans = [];\n                if (Array.isArray(body)) {\n                    var ρσ_Iter40 = ρσ_Iterable(body);\n                    for (var ρσ_Index40 = 0; ρσ_Index40 < ρσ_Iter40.length; ρσ_Index40++) {\n                        obj = ρσ_Iter40[ρσ_Index40];\n                        if (is_node_type(obj, AST_Function) || is_node_type(obj, AST_Class)) {\n                            if (obj.name) {\n                                ans.push(obj.name.name);\n                            } else {\n                                token_error(obj.start, \"Top-level functions must have names\");\n                            }\n                        } else {\n                            if (is_node_type(obj, AST_Scope)) {\n                                continue;\n                            }\n                            var ρσ_Iter41 = ρσ_Iterable(ρσ_list_decorate([ \"body\", \"alternative\" ]));\n                            for (var ρσ_Index41 = 0; ρσ_Index41 < ρσ_Iter41.length; ρσ_Index41++) {\n                                x = ρσ_Iter41[ρσ_Index41];\n                                opt = obj[(typeof x === \"number\" && x < 0) ? obj.length + x : x];\n                                if (opt) {\n                                    ans = ans.concat(scan_for_top_level_callables(opt));\n                                }\n                                if (is_node_type(opt, AST_Assign) && !is_node_type(opt.right, AST_Scope)) {\n                                    ans = ans.concat(scan_for_top_level_callables(opt.right));\n                                }\n                            }\n                        }\n                    }\n                } else if (body.body) {\n                    ans = ans.concat(scan_for_top_level_callables(body.body));\n                    if (body.alternative) {\n                        ans = ans.concat(scan_for_top_level_callables(body.alternative));\n                    }\n                }\n                return ans;\n            };\n            if (!scan_for_top_level_callables.__argnames__) Object.defineProperties(scan_for_top_level_callables, {\n                __argnames__ : {value: [\"body\"]}\n            });\n\n            function scan_for_classes(body) {\n                var ans, obj;\n                ans = Object.create(null);\n                var ρσ_Iter42 = ρσ_Iterable(body);\n                for (var ρσ_Index42 = 0; ρσ_Index42 < ρσ_Iter42.length; ρσ_Index42++) {\n                    obj = ρσ_Iter42[ρσ_Index42];\n                    if (is_node_type(obj, AST_Class)) {\n                        ans[ρσ_bound_index(obj.name.name, ans)] = obj;\n                    }\n                }\n                return ans;\n            };\n            if (!scan_for_classes.__argnames__) Object.defineProperties(scan_for_classes, {\n                __argnames__ : {value: [\"body\"]}\n            });\n\n            function scan_for_local_vars(body) {\n                var localvars, seen, opt, option, clause, stmt, is_compound_assign, lhs;\n                localvars = [];\n                seen = Object.create(null);\n                function push(x) {\n                    if (has_prop(seen, x)) {\n                        return;\n                    }\n                    seen[(typeof x === \"number\" && x < 0) ? seen.length + x : x] = true;\n                    localvars.push(x);\n                };\n                if (!push.__argnames__) Object.defineProperties(push, {\n                    __argnames__ : {value: [\"x\"]}\n                });\n\n                function extend(arr) {\n                    var x;\n                    var ρσ_Iter43 = ρσ_Iterable(arr);\n                    for (var ρσ_Index43 = 0; ρσ_Index43 < ρσ_Iter43.length; ρσ_Index43++) {\n                        x = ρσ_Iter43[ρσ_Index43];\n                        push(x);\n                    }\n                };\n                if (!extend.__argnames__) Object.defineProperties(extend, {\n                    __argnames__ : {value: [\"arr\"]}\n                });\n\n                function scan_in_array(arr) {\n                    var x;\n                    var ρσ_Iter44 = ρσ_Iterable(arr);\n                    for (var ρσ_Index44 = 0; ρσ_Index44 < ρσ_Iter44.length; ρσ_Index44++) {\n                        x = ρσ_Iter44[ρσ_Index44];\n                        if (is_node_type(x, AST_Seq)) {\n                            x = x.to_array();\n                        } else if (is_node_type(x, AST_Array)) {\n                            x = x.elements;\n                        }\n                        if (Array.isArray(x)) {\n                            scan_in_array(x);\n                        } else {\n                            if (!is_node_type(x, AST_PropAccess)) {\n                                push(x.name);\n                            }\n                        }\n                    }\n                };\n                if (!scan_in_array.__argnames__) Object.defineProperties(scan_in_array, {\n                    __argnames__ : {value: [\"arr\"]}\n                });\n\n                function add_assign_lhs(lhs) {\n                    if (is_node_type(lhs, AST_Seq)) {\n                        lhs = new AST_Array((function(){\n                            var ρσ_d = Object.create(null);\n                            ρσ_d[\"elements\"] = lhs.to_array();\n                            return ρσ_d;\n                        }).call(this));\n                    }\n                    if (is_node_type(lhs, AST_Array)) {\n                        push(\"ρσ_unpack\");\n                        scan_in_array(lhs.elements);\n                    } else if (lhs.name) {\n                        push(lhs.name);\n                    }\n                };\n                if (!add_assign_lhs.__argnames__) Object.defineProperties(add_assign_lhs, {\n                    __argnames__ : {value: [\"lhs\"]}\n                });\n\n                function add_for_in(stmt) {\n                    if (is_node_type(stmt.init, AST_Array)) {\n                        push(\"ρσ_unpack\");\n                        scan_in_array(stmt.init.elements);\n                    } else {\n                        push(stmt.init.name);\n                    }\n                };\n                if (!add_for_in.__argnames__) Object.defineProperties(add_for_in, {\n                    __argnames__ : {value: [\"stmt\"]}\n                });\n\n                if (Array.isArray(body)) {\n                    var ρσ_Iter45 = ρσ_Iterable(body);\n                    for (var ρσ_Index45 = 0; ρσ_Index45 < ρσ_Iter45.length; ρσ_Index45++) {\n                        stmt = ρσ_Iter45[ρσ_Index45];\n                        if (is_node_type(stmt, AST_Scope)) {\n                            continue;\n                        }\n                        var ρσ_Iter46 = ρσ_Iterable(ρσ_list_decorate([ \"body\", \"alternative\", \"bcatch\" ]));\n                        for (var ρσ_Index46 = 0; ρσ_Index46 < ρσ_Iter46.length; ρσ_Index46++) {\n                            option = ρσ_Iter46[ρσ_Index46];\n                            opt = stmt[(typeof option === \"number\" && option < 0) ? stmt.length + option : option];\n                            if (opt) {\n                                extend(scan_for_local_vars(opt));\n                            }\n                            if (is_node_type(opt, AST_Assign) && !is_node_type(opt.right, AST_Scope)) {\n                                extend(scan_for_local_vars(opt.right));\n                            }\n                        }\n                        if (is_node_type(stmt, AST_ForIn)) {\n                            add_for_in(stmt);\n                        } else if (is_node_type(stmt, AST_DWLoop)) {\n                            extend(scan_for_local_vars(stmt));\n                        } else if (is_node_type(stmt, AST_With)) {\n                            [push(\"ρσ_with_exception\"), push(\"ρσ_with_suppress\")];\n                            var ρσ_Iter47 = ρσ_Iterable(stmt.clauses);\n                            for (var ρσ_Index47 = 0; ρσ_Index47 < ρσ_Iter47.length; ρσ_Index47++) {\n                                clause = ρσ_Iter47[ρσ_Index47];\n                                if (clause.alias) {\n                                    push(clause.alias.name);\n                                }\n                            }\n                        }\n                    }\n                } else if (body.body) {\n                    extend(scan_for_local_vars(body.body));\n                    if (body.alternative) {\n                        extend(scan_for_local_vars(body.alternative));\n                    }\n                } else if (is_node_type(body, AST_Assign)) {\n                    if (body.is_chained()) {\n                        is_compound_assign = false;\n                        var ρσ_Iter48 = ρσ_Iterable(body.traverse_chain()[0]);\n                        for (var ρσ_Index48 = 0; ρσ_Index48 < ρσ_Iter48.length; ρσ_Index48++) {\n                            lhs = ρσ_Iter48[ρσ_Index48];\n                            add_assign_lhs(lhs);\n                            if (is_node_type(lhs, AST_Seq) || is_node_type(lhs, AST_Array)) {\n                                is_compound_assign = true;\n                                break;\n                            }\n                        }\n                        if (is_compound_assign) {\n                            push(\"ρσ_chain_assign_temp\");\n                        }\n                    } else {\n                        add_assign_lhs(body.left);\n                    }\n                    if (!is_node_type(body.right, AST_Scope)) {\n                        extend(scan_for_local_vars(body.right));\n                    }\n                } else if (is_node_type(body, AST_ForIn)) {\n                    add_for_in(body);\n                }\n                return localvars;\n            };\n            if (!scan_for_local_vars.__argnames__) Object.defineProperties(scan_for_local_vars, {\n                __argnames__ : {value: [\"body\"]}\n            });\n\n            function scan_for_nonlocal_defs(body) {\n                var vardef, opt, option, stmt;\n                vars = [];\n                if (Array.isArray(body)) {\n                    var ρσ_Iter49 = ρσ_Iterable(body);\n                    for (var ρσ_Index49 = 0; ρσ_Index49 < ρσ_Iter49.length; ρσ_Index49++) {\n                        stmt = ρσ_Iter49[ρσ_Index49];\n                        if (is_node_type(stmt, AST_Scope)) {\n                            continue;\n                        }\n                        if (is_node_type(stmt, AST_Definitions)) {\n                            var ρσ_Iter50 = ρσ_Iterable(stmt.definitions);\n                            for (var ρσ_Index50 = 0; ρσ_Index50 < ρσ_Iter50.length; ρσ_Index50++) {\n                                vardef = ρσ_Iter50[ρσ_Index50];\n                                vars.push(vardef.name.name);\n                            }\n                        }\n                        var ρσ_Iter51 = ρσ_Iterable(ρσ_list_decorate([ \"body\", \"alternative\" ]));\n                        for (var ρσ_Index51 = 0; ρσ_Index51 < ρσ_Iter51.length; ρσ_Index51++) {\n                            option = ρσ_Iter51[ρσ_Index51];\n                            var vars;\n                            opt = stmt[(typeof option === \"number\" && option < 0) ? stmt.length + option : option];\n                            if (opt) {\n                                vars = vars.concat(scan_for_nonlocal_defs(opt));\n                            }\n                        }\n                    }\n                } else if (body.body) {\n                    vars = vars.concat(scan_for_nonlocal_defs(body.body));\n                    if (body.alternative) {\n                        vars = vars.concat(scan_for_nonlocal_defs(body.alternative));\n                    }\n                }\n                return vars;\n            };\n            if (!scan_for_nonlocal_defs.__argnames__) Object.defineProperties(scan_for_nonlocal_defs, {\n                __argnames__ : {value: [\"body\"]}\n            });\n\n            function return_() {\n                var value, is_end_of_statement;\n                if (is_(\"punc\", \";\")) {\n                    semicolon();\n                    value = null;\n                } else {\n                    is_end_of_statement = S.token.nlb || is_(\"eof\") || is_(\"punc\", \"}\");\n                    if (is_end_of_statement) {\n                        value = null;\n                    } else {\n                        value = expression(true);\n                        semicolon();\n                    }\n                }\n                return value;\n            };\n\n            \n            var statement = embed_tokens(function statement() {\n                var tmp_, start, func, chain, cond, msg, tmp;\n                if (S.token.type === \"operator\" && S.token.value.substr(0, 1) === \"/\") {\n                    token_error(S.token, \"RapydScript does not support statements starting with regexp literals\");\n                }\n                S.statement_starting_token = S.token;\n                tmp_ = S.token.type;\n                if (tmp_ === \"string\") {\n                    return simple_statement();\n                } else if (tmp_ === \"shebang\") {\n                    tmp_ = S.token.value;\n                    next();\n                    return new AST_Directive((function(){\n                        var ρσ_d = Object.create(null);\n                        ρσ_d[\"value\"] = tmp_;\n                        return ρσ_d;\n                    }).call(this));\n                } else if (tmp_ === \"num\" || tmp_ === \"regexp\" || tmp_ === \"operator\" || tmp_ === \"atom\" || tmp_ === \"js\") {\n                    return simple_statement();\n                } else if (tmp_ === \"punc\") {\n                    tmp_ = S.token.value;\n                    if (tmp_ === \":\") {\n                        return new AST_BlockStatement((function(){\n                            var ρσ_d = Object.create(null);\n                            ρσ_d[\"start\"] = S.token;\n                            ρσ_d[\"body\"] = block_();\n                            ρσ_d[\"end\"] = prev();\n                            return ρσ_d;\n                        }).call(this));\n                    } else if (tmp_ === \"{\" || tmp_ === \"[\" || tmp_ === \"(\") {\n                        return simple_statement();\n                    } else if (tmp_ === \";\") {\n                        next();\n                        return new AST_EmptyStatement((function(){\n                            var ρσ_d = Object.create(null);\n                            ρσ_d[\"stype\"] = \";\";\n                            ρσ_d[\"start\"] = prev();\n                            ρσ_d[\"end\"] = prev();\n                            return ρσ_d;\n                        }).call(this));\n                    } else {\n                        unexpected();\n                    }\n                } else if (tmp_ === \"name\") {\n                    if (is_token(peek(), \"punc\", \":\")) token_error(peek(), \"invalid syntax, colon not allowed here\");\n                    return simple_statement();\n                } else if (tmp_ === \"keyword\") {\n                    tmp_ = S.token.value;\n                    next();\n                    if (tmp_ === \"break\") {\n                        return break_cont(AST_Break);\n                    } else if (tmp_ === \"continue\") {\n                        return break_cont(AST_Continue);\n                    } else if (tmp_ === \"debugger\") {\n                        semicolon();\n                        return new AST_Debugger;\n                    } else if (tmp_ === \"do\") {\n                        return new AST_Do((function(){\n                            var ρσ_d = Object.create(null);\n                            ρσ_d[\"body\"] = in_loop(statement);\n                            ρσ_d[\"condition\"] = function () {\n                                var tmp;\n                                expect(\".\");\n                                expect_token(\"keyword\", \"while\");\n                                tmp = expression(true);\n                                semicolon();\n                                return tmp;\n                            }();\n                            return ρσ_d;\n                        }).call(this));\n                    } else if (tmp_ === \"while\") {\n                        return new AST_While((function(){\n                            var ρσ_d = Object.create(null);\n                            ρσ_d[\"condition\"] = expression(true);\n                            ρσ_d[\"body\"] = in_loop(statement);\n                            return ρσ_d;\n                        }).call(this));\n                    } else if (tmp_ === \"for\") {\n                        if (is_(\"js\")) {\n                            return for_js();\n                        }\n                        return for_();\n                    } else if (tmp_ === \"from\") {\n                        return import_(true);\n                    } else if (tmp_ === \"import\") {\n                        return import_(false);\n                    } else if (tmp_ === \"class\") {\n                        return class_();\n                    } else if (tmp_ === \"def\") {\n                        start = prev();\n                        func = function_((ρσ_expr_temp = S.in_class)[ρσ_expr_temp.length-1], false);\n                        func.start = start;\n                        func.end = prev();\n                        chain = subscripts(func, true);\n                        if (chain === func) {\n                            return func;\n                        } else {\n                            return new AST_SimpleStatement((function(){\n                                var ρσ_d = Object.create(null);\n                                ρσ_d[\"start\"] = start;\n                                ρσ_d[\"body\"] = chain;\n                                ρσ_d[\"end\"] = prev();\n                                return ρσ_d;\n                            }).call(this));\n                        }\n                    } else if (tmp_ === \"assert\") {\n                        start = prev();\n                        cond = expression(false);\n                        msg = null;\n                        if (is_(\"punc\", \",\")) {\n                            next();\n                            msg = expression(false);\n                        }\n                        return new AST_Assert((function(){\n                            var ρσ_d = Object.create(null);\n                            ρσ_d[\"start\"] = start;\n                            ρσ_d[\"condition\"] = cond;\n                            ρσ_d[\"message\"] = msg;\n                            ρσ_d[\"end\"] = prev();\n                            return ρσ_d;\n                        }).call(this));\n                    } else if (tmp_ === \"if\") {\n                        return if_();\n                    } else if (tmp_ === \"pass\") {\n                        semicolon();\n                        return new AST_EmptyStatement((function(){\n                            var ρσ_d = Object.create(null);\n                            ρσ_d[\"stype\"] = \"pass\";\n                            ρσ_d[\"start\"] = prev();\n                            ρσ_d[\"end\"] = prev();\n                            return ρσ_d;\n                        }).call(this));\n                    } else if (tmp_ === \"return\") {\n                        if (S.in_function === 0) {\n                            croak(\"'return' outside of function\");\n                        }\n                        if ((ρσ_expr_temp = S.functions)[ρσ_expr_temp.length-1].is_generator) {\n                            croak(\"'return' not allowed in a function with yield\");\n                        }\n                        (ρσ_expr_temp = S.functions)[ρσ_expr_temp.length-1].is_generator = false;\n                        return new AST_Return((function(){\n                            var ρσ_d = Object.create(null);\n                            ρσ_d[\"value\"] = return_();\n                            return ρσ_d;\n                        }).call(this));\n                    } else if (tmp_ === \"yield\") {\n                        return yield_();\n                    } else if (tmp_ === \"raise\") {\n                        if (S.token.nlb) {\n                            return new AST_Throw((function(){\n                                var ρσ_d = Object.create(null);\n                                ρσ_d[\"value\"] = new AST_SymbolCatch((function(){\n                                    var ρσ_d = Object.create(null);\n                                    ρσ_d[\"name\"] = \"ρσ_Exception\";\n                                    return ρσ_d;\n                                }).call(this));\n                                return ρσ_d;\n                            }).call(this));\n                        }\n                        tmp = expression(true);\n                        semicolon();\n                        return new AST_Throw((function(){\n                            var ρσ_d = Object.create(null);\n                            ρσ_d[\"value\"] = tmp;\n                            return ρσ_d;\n                        }).call(this));\n                    } else if (tmp_ === \"try\") {\n                        return try_();\n                    } else if (tmp_ === \"nonlocal\") {\n                        tmp = nonlocal_();\n                        semicolon();\n                        return tmp;\n                    } else if (tmp_ === \"global\") {\n                        tmp = nonlocal_(true);\n                        semicolon();\n                        return tmp;\n                    } else if (tmp_ === \"with\") {\n                        return with_();\n                    } else {\n                        unexpected();\n                    }\n                }\n            });\n\n            function with_() {\n                var clauses, start, expr, alias, body;\n                clauses = [];\n                start = S.token;\n                while (true) {\n                    if (is_(\"eof\")) {\n                        unexpected();\n                    }\n                    expr = expression();\n                    alias = null;\n                    if (is_(\"keyword\", \"as\")) {\n                        next();\n                        alias = as_symbol(AST_SymbolAlias);\n                    }\n                    clauses.push(new AST_WithClause((function(){\n                        var ρσ_d = Object.create(null);\n                        ρσ_d[\"expression\"] = expr;\n                        ρσ_d[\"alias\"] = alias;\n                        return ρσ_d;\n                    }).call(this)));\n                    if (is_(\"punc\", \",\")) {\n                        next();\n                        continue;\n                    }\n                    if (!is_(\"punc\", \":\")) {\n                        unexpected();\n                    }\n                    break;\n                }\n                if (!clauses.length) {\n                    token_error(start, \"with statement must have at least one clause\");\n                }\n                body = statement();\n                return new AST_With((function(){\n                    var ρσ_d = Object.create(null);\n                    ρσ_d[\"clauses\"] = clauses;\n                    ρσ_d[\"body\"] = body;\n                    return ρσ_d;\n                }).call(this));\n            };\n\n            function simple_statement(tmp) {\n                tmp = expression(true);\n                semicolon();\n                return new AST_SimpleStatement((function(){\n                    var ρσ_d = Object.create(null);\n                    ρσ_d[\"body\"] = tmp;\n                    return ρσ_d;\n                }).call(this));\n            };\n            if (!simple_statement.__argnames__) Object.defineProperties(simple_statement, {\n                __argnames__ : {value: [\"tmp\"]}\n            });\n\n            function break_cont(t) {\n                if (S.in_loop === 0) {\n                    croak(t.name.slice(4) + \" not inside a loop or switch\");\n                }\n                semicolon();\n                return new t;\n            };\n            if (!break_cont.__argnames__) Object.defineProperties(break_cont, {\n                __argnames__ : {value: [\"t\"]}\n            });\n\n            function yield_() {\n                var is_yield_from;\n                if (S.in_function === 0) {\n                    croak(\"'yield' outside of function\");\n                }\n                if ((ρσ_expr_temp = S.functions)[ρσ_expr_temp.length-1].is_generator === false) {\n                    croak(\"'yield' not allowed in a function with return\");\n                }\n                (ρσ_expr_temp = S.functions)[ρσ_expr_temp.length-1].is_generator = true;\n                is_yield_from = is_(\"keyword\", \"from\");\n                if (is_yield_from) {\n                    next();\n                }\n                return new AST_Yield((function(){\n                    var ρσ_d = Object.create(null);\n                    ρσ_d[\"is_yield_from\"] = is_yield_from;\n                    ρσ_d[\"value\"] = return_();\n                    return ρσ_d;\n                }).call(this));\n            };\n\n            function for_(list_comp) {\n                var init, tmp;\n                init = null;\n                if (!is_(\"punc\", \";\")) {\n                    init = expression(true, true);\n                    if (is_node_type(init, AST_Seq)) {\n                        if (is_node_type(init.car, AST_SymbolRef) && is_node_type(init.cdr, AST_SymbolRef)) {\n                            tmp = init.to_array();\n                        } else {\n                            tmp = ρσ_list_decorate([ init ]);\n                        }\n                        init = new AST_Array((function(){\n                            var ρσ_d = Object.create(null);\n                            ρσ_d[\"start\"] = init.start;\n                            ρσ_d[\"elements\"] = tmp;\n                            ρσ_d[\"end\"] = init.end;\n                            return ρσ_d;\n                        }).call(this));\n                    }\n                    if (is_(\"operator\", \"in\")) {\n                        if (is_node_type(init, AST_Var) && init.definitions.length > 1) {\n                            croak(\"Only one variable declaration allowed in for..in loop\");\n                        }\n                        next();\n                        return for_in(init, list_comp);\n                    }\n                }\n                unexpected();\n            };\n            if (!for_.__argnames__) Object.defineProperties(for_, {\n                __argnames__ : {value: [\"list_comp\"]}\n            });\n\n            function for_in(init, list_comp) {\n                var lhs, obj;\n                lhs = (is_node_type(init, AST_Var)) ? init.definitions[0].name : null;\n                obj = expression(true);\n                if (list_comp) {\n                    return (function(){\n                        var ρσ_d = Object.create(null);\n                        ρσ_d[\"init\"] = init;\n                        ρσ_d[\"name\"] = lhs;\n                        ρσ_d[\"object\"] = obj;\n                        return ρσ_d;\n                    }).call(this);\n                }\n                return new AST_ForIn((function(){\n                    var ρσ_d = Object.create(null);\n                    ρσ_d[\"init\"] = init;\n                    ρσ_d[\"name\"] = lhs;\n                    ρσ_d[\"object\"] = obj;\n                    ρσ_d[\"body\"] = in_loop(statement);\n                    return ρσ_d;\n                }).call(this));\n            };\n            if (!for_in.__argnames__) Object.defineProperties(for_in, {\n                __argnames__ : {value: [\"init\", \"list_comp\"]}\n            });\n\n            function for_js() {\n                var condition;\n                condition = as_atom_node();\n                return new AST_ForJS((function(){\n                    var ρσ_d = Object.create(null);\n                    ρσ_d[\"condition\"] = condition;\n                    ρσ_d[\"body\"] = in_loop(statement);\n                    return ρσ_d;\n                }).call(this));\n            };\n\n            function get_class_in_scope(expr) {\n                var s, referenced_path, class_name;\n                if (is_node_type(expr, AST_SymbolRef)) {\n                    if (has_prop(NATIVE_CLASSES, expr.name)) {\n                        return NATIVE_CLASSES[ρσ_bound_index(expr.name, NATIVE_CLASSES)];\n                    }\n                    if (has_prop(ERROR_CLASSES, expr.name)) {\n                        return ERROR_CLASSES[ρσ_bound_index(expr.name, ERROR_CLASSES)];\n                    }\n                    for (var ρσ_Index52 = S.classes.length - 1; ρσ_Index52 > -1; ρσ_Index52-=1) {\n                        s = ρσ_Index52;\n                        if (has_prop((ρσ_expr_temp = S.classes)[(typeof s === \"number\" && s < 0) ? ρσ_expr_temp.length + s : s], expr.name)) {\n                            return (ρσ_expr_temp = (ρσ_expr_temp = S.classes)[(typeof s === \"number\" && s < 0) ? ρσ_expr_temp.length + s : s])[ρσ_bound_index(expr.name, ρσ_expr_temp)];\n                        }\n                    }\n                } else if (is_node_type(expr, AST_Dot)) {\n                    referenced_path = ρσ_list_decorate([]);\n                    while (is_node_type(expr, AST_Dot)) {\n                        referenced_path.unshift(expr.property);\n                        expr = expr.expression;\n                    }\n                    if (is_node_type(expr, AST_SymbolRef)) {\n                        referenced_path.unshift(expr.name);\n                        if (len(referenced_path) > 1) {\n                            class_name = referenced_path.join(\".\");\n                            for (var ρσ_Index53 = S.classes.length - 1; ρσ_Index53 > -1; ρσ_Index53-=1) {\n                                s = ρσ_Index53;\n                                if (has_prop((ρσ_expr_temp = S.classes)[(typeof s === \"number\" && s < 0) ? ρσ_expr_temp.length + s : s], class_name)) {\n                                    return (ρσ_expr_temp = (ρσ_expr_temp = S.classes)[(typeof s === \"number\" && s < 0) ? ρσ_expr_temp.length + s : s])[(typeof class_name === \"number\" && class_name < 0) ? ρσ_expr_temp.length + class_name : class_name];\n                                }\n                            }\n                        }\n                    }\n                }\n                return false;\n            };\n            if (!get_class_in_scope.__argnames__) Object.defineProperties(get_class_in_scope, {\n                __argnames__ : {value: [\"expr\"]}\n            });\n\n            function import_error(message) {\n                var ctx;\n                ctx = S.input.context();\n                throw new ImportError(message, ctx.filename, ctx.tokline, ctx.tokcol, ctx.tokpos);\n            };\n            if (!import_error.__argnames__) Object.defineProperties(import_error, {\n                __argnames__ : {value: [\"message\"]}\n            });\n\n            function do_import(key) {\n                var package_module_id, src_code, filename, modpath, ρσ_unpack, data, location, cached, srchash, ikey, bitem;\n                if (has_prop(imported_modules, key)) {\n                    return;\n                }\n                if (has_prop(importing_modules, key) && importing_modules[(typeof key === \"number\" && key < 0) ? importing_modules.length + key : key]) {\n                    import_error(\"Detected a recursive import of: \" + key + \" while importing: \" + module_id);\n                }\n                package_module_id = key.split(\".\").slice(0, -1).join(\".\");\n                if (len(package_module_id) > 0) {\n                    do_import(package_module_id);\n                }\n                if (options.for_linting) {\n                    imported_modules[(typeof key === \"number\" && key < 0) ? imported_modules.length + key : key] = (function(){\n                        var ρσ_d = Object.create(null);\n                        ρσ_d[\"is_cached\"] = true;\n                        ρσ_d[\"classes\"] = Object.create(null);\n                        ρσ_d[\"module_id\"] = key;\n                        ρσ_d[\"exports\"] = ρσ_list_decorate([]);\n                        ρσ_d[\"nonlocalvars\"] = ρσ_list_decorate([]);\n                        ρσ_d[\"baselib\"] = Object.create(null);\n                        ρσ_d[\"outputs\"] = Object.create(null);\n                        ρσ_d[\"discard_asserts\"] = options.discard_asserts;\n                        return ρσ_d;\n                    }).call(this);\n                    return;\n                }\n                function safe_read(base_path) {\n                    var ρσ_unpack, i, path;\n                    var ρσ_Iter54 = ρσ_Iterable(enumerate(ρσ_list_decorate([ base_path + \".pyj\", base_path + \"/__init__.pyj\" ])));\n                    for (var ρσ_Index54 = 0; ρσ_Index54 < ρσ_Iter54.length; ρσ_Index54++) {\n                        ρσ_unpack = ρσ_Iter54[ρσ_Index54];\n                        i = ρσ_unpack[0];\n                        path = ρσ_unpack[1];\n                        try {\n                            return ρσ_list_decorate([ readfile(path, \"utf-8\"), path ]);\n                        } catch (ρσ_Exception) {\n                            ρσ_last_exception = ρσ_Exception;\n                            {\n                                var e = ρσ_Exception;\n                                if (e.code === \"ENOENT\" || e.code === \"EPERM\" || e.code === \"EACCESS\") {\n                                    if (i === 1) {\n                                        return [null, null];\n                                    }\n                                }\n                                if (i === 1) {\n                                    throw ρσ_Exception;\n                                }\n                            } \n                        }\n                    }\n                };\n                if (!safe_read.__argnames__) Object.defineProperties(safe_read, {\n                    __argnames__ : {value: [\"base_path\"]}\n                });\n\n                src_code = filename = null;\n                modpath = key.replace(/\\./g, \"/\");\n                var ρσ_Iter55 = ρσ_Iterable(import_dirs);\n                for (var ρσ_Index55 = 0; ρσ_Index55 < ρσ_Iter55.length; ρσ_Index55++) {\n                    location = ρσ_Iter55[ρσ_Index55];\n                    if (location) {\n                        ρσ_unpack = safe_read(location + \"/\" + modpath);\nρσ_unpack = ρσ_unpack_asarray(2, ρσ_unpack);\n                        data = ρσ_unpack[0];\n                        filename = ρσ_unpack[1];\n                        if (data !== null) {\n                            src_code = data;\n                            break;\n                        }\n                    }\n                }\n                if (src_code === null) {\n                    import_error(\"Failed Import: '\" + key + \"' module doesn't exist in any of the import directories: \" + import_dirs.join(\":\"));\n                }\n                try {\n                    cached = JSON.parse(readfile(cache_file_name(filename, options.module_cache_dir), \"utf-8\"));\n                } catch (ρσ_Exception) {\n                    ρσ_last_exception = ρσ_Exception;\n                    {\n                        cached = null;\n                    } \n                }\n                srchash = sha1sum(src_code);\n                if (cached && cached.version === COMPILER_VERSION && cached.signature === srchash && cached.discard_asserts === options.discard_asserts) {\n                    var ρσ_Iter56 = ρσ_Iterable(cached.imported_module_ids);\n                    for (var ρσ_Index56 = 0; ρσ_Index56 < ρσ_Iter56.length; ρσ_Index56++) {\n                        ikey = ρσ_Iter56[ρσ_Index56];\n                        do_import(ikey);\n                    }\n                    imported_modules[(typeof key === \"number\" && key < 0) ? imported_modules.length + key : key] = (function(){\n                        var ρσ_d = Object.create(null);\n                        ρσ_d[\"is_cached\"] = true;\n                        ρσ_d[\"classes\"] = cached.classes;\n                        ρσ_d[\"outputs\"] = cached.outputs;\n                        ρσ_d[\"module_id\"] = key;\n                        ρσ_d[\"import_order\"] = Object.keys(imported_modules).length;\n                        ρσ_d[\"nonlocalvars\"] = cached.nonlocalvars;\n                        ρσ_d[\"baselib\"] = cached.baselib;\n                        ρσ_d[\"exports\"] = cached.exports;\n                        ρσ_d[\"discard_asserts\"] = options.discard_asserts;\n                        ρσ_d[\"imported_module_ids\"] = cached.imported_module_ids;\n                        return ρσ_d;\n                    }).call(this);\n                } else {\n                    parse(src_code, (function(){\n                        var ρσ_d = Object.create(null);\n                        ρσ_d[\"filename\"] = filename;\n                        ρσ_d[\"toplevel\"] = null;\n                        ρσ_d[\"basedir\"] = options.basedir;\n                        ρσ_d[\"libdir\"] = options.libdir;\n                        ρσ_d[\"import_dirs\"] = options.import_dirs;\n                        ρσ_d[\"module_id\"] = key;\n                        ρσ_d[\"imported_modules\"] = imported_modules;\n                        ρσ_d[\"importing_modules\"] = importing_modules;\n                        ρσ_d[\"discard_asserts\"] = options.discard_asserts;\n                        ρσ_d[\"module_cache_dir\"] = options.module_cache_dir;\n                        return ρσ_d;\n                    }).call(this));\n                }\n                imported_modules[(typeof key === \"number\" && key < 0) ? imported_modules.length + key : key].srchash = srchash;\n                var ρσ_Iter57 = ρσ_Iterable(Object.keys(imported_modules[(typeof key === \"number\" && key < 0) ? imported_modules.length + key : key].baselib));\n                for (var ρσ_Index57 = 0; ρσ_Index57 < ρσ_Iter57.length; ρσ_Index57++) {\n                    bitem = ρσ_Iter57[ρσ_Index57];\n                    baselib_items[(typeof bitem === \"number\" && bitem < 0) ? baselib_items.length + bitem : bitem] = true;\n                }\n            };\n            if (!do_import.__argnames__) Object.defineProperties(do_import, {\n                __argnames__ : {value: [\"key\"]}\n            });\n\n            function read_python_flags() {\n                var bracketed, name, val;\n                expect_token(\"keyword\", \"import\");\n                bracketed = is_(\"punc\", \"(\");\n                if (bracketed) {\n                    next();\n                }\n                while (true) {\n                    if (!is_(\"name\")) {\n                        croak(\"Name expected\");\n                    }\n                    name = S.token.value;\n                    val = (name.startsWith(\"no_\")) ? false : true;\n                    if (!val) {\n                        name = name.slice(3);\n                    }\n                    if (!PYTHON_FLAGS) {\n                        croak(\"Unknown __python__ flag: \" + name);\n                    }\n                    S.scoped_flags.set(name, val);\n                    next();\n                    if (is_(\"punc\", \",\")) {\n                        next();\n                    } else {\n                        if (bracketed) {\n                            if (is_(\"punc\", \")\")) {\n                                next();\n                            } else {\n                                continue;\n                            }\n                        }\n                        break;\n                    }\n                }\n                return new AST_EmptyStatement((function(){\n                    var ρσ_d = Object.create(null);\n                    ρσ_d[\"stype\"] = \"scoped_flags\";\n                    ρσ_d[\"start\"] = prev();\n                    ρσ_d[\"end\"] = prev();\n                    return ρσ_d;\n                }).call(this));\n            };\n\n            function import_(from_import) {\n                var ans, tok, tmp, name, last_tok, key, alias, aimp, ρσ_unpack, classes, argnames, bracketed, exports, symdef, aname, obj, argvar, cname, imp;\n                ans = new AST_Imports((function(){\n                    var ρσ_d = Object.create(null);\n                    ρσ_d[\"imports\"] = ρσ_list_decorate([]);\n                    return ρσ_d;\n                }).call(this));\n                while (true) {\n                    tok = tmp = name = last_tok = expression(false);\n                    key = \"\";\n                    while (is_node_type(tmp, AST_Dot)) {\n                        key = \".\" + tmp.property + key;\n                        tmp = last_tok = tmp.expression;\n                    }\n                    key = tmp.name + key;\n                    if (from_import && key === \"__python__\") {\n                        return read_python_flags();\n                    }\n                    alias = null;\n                    if (!from_import && is_(\"keyword\", \"as\")) {\n                        next();\n                        alias = as_symbol(AST_SymbolAlias);\n                    }\n                    aimp = new AST_Import((function(){\n                        var ρσ_d = Object.create(null);\n                        ρσ_d[\"module\"] = name;\n                        ρσ_d[\"key\"] = key;\n                        ρσ_d[\"alias\"] = alias;\n                        ρσ_d[\"argnames\"] = null;\n                        ρσ_d[\"body\"] = function () {\n                            return imported_modules[(typeof key === \"number\" && key < 0) ? imported_modules.length + key : key];\n                        };\n                        return ρσ_d;\n                    }).call(this));\n                    ρσ_unpack = [tok.start, last_tok.end];\n                    aimp.start = ρσ_unpack[0];\n                    aimp.end = ρσ_unpack[1];\n                    ans.imports.push(aimp);\n                    if (from_import) {\n                        break;\n                    }\n                    if (is_(\"punc\", \",\")) {\n                        next();\n                    } else {\n                        break;\n                    }\n                }\n                var ρσ_Iter58 = ρσ_Iterable(ans[\"imports\"]);\n                for (var ρσ_Index58 = 0; ρσ_Index58 < ρσ_Iter58.length; ρσ_Index58++) {\n                    imp = ρσ_Iter58[ρσ_Index58];\n                    do_import(imp.key);\n                    if (imported_module_ids.indexOf(imp.key) === -1) {\n                        imported_module_ids.push(imp.key);\n                    }\n                    classes = imported_modules[(typeof key === \"number\" && key < 0) ? imported_modules.length + key : key].classes;\n                    if (from_import) {\n                        expect_token(\"keyword\", \"import\");\n                        imp.argnames = argnames = ρσ_list_decorate([]);\n                        bracketed = is_(\"punc\", \"(\");\n                        if (bracketed) {\n                            next();\n                        }\n                        exports = Object.create(null);\n                        var ρσ_Iter59 = ρσ_Iterable(imported_modules[(typeof key === \"number\" && key < 0) ? imported_modules.length + key : key].exports);\n                        for (var ρσ_Index59 = 0; ρσ_Index59 < ρσ_Iter59.length; ρσ_Index59++) {\n                            symdef = ρσ_Iter59[ρσ_Index59];\n                            exports[ρσ_bound_index(symdef.name, exports)] = true;\n                        }\n                        while (true) {\n                            aname = as_symbol(AST_ImportedVar);\n                            if (!options.for_linting && !has_prop(exports, aname.name)) {\n                                import_error(\"The symbol \\\"\" + aname.name + \"\\\" is not exported from the module: \" + key);\n                            }\n                            if (is_(\"keyword\", \"as\")) {\n                                next();\n                                aname.alias = as_symbol(AST_SymbolAlias);\n                            }\n                            argnames.push(aname);\n                            if (is_(\"punc\", \",\")) {\n                                next();\n                            } else {\n                                if (bracketed) {\n                                    if (is_(\"punc\", \")\")) {\n                                        next();\n                                    } else {\n                                        continue;\n                                    }\n                                }\n                                break;\n                            }\n                        }\n                        var ρσ_Iter60 = ρσ_Iterable(argnames);\n                        for (var ρσ_Index60 = 0; ρσ_Index60 < ρσ_Iter60.length; ρσ_Index60++) {\n                            argvar = ρσ_Iter60[ρσ_Index60];\n                            obj = classes[ρσ_bound_index(argvar.name, classes)];\n                            if (obj) {\n                                key = (argvar.alias) ? argvar.alias.name : argvar.name;\n                                (ρσ_expr_temp = (ρσ_expr_temp = S.classes)[ρσ_expr_temp.length-1])[(typeof key === \"number\" && key < 0) ? ρσ_expr_temp.length + key : key] = (function(){\n                                    var ρσ_d = Object.create(null);\n                                    ρσ_d[\"static\"] = obj.static;\n                                    ρσ_d[\"bound\"] = obj.bound;\n                                    ρσ_d[\"classvars\"] = obj.classvars;\n                                    return ρσ_d;\n                                }).call(this);\n                            }\n                        }\n                    } else {\n                        var ρσ_Iter61 = ρσ_Iterable(Object.keys(classes));\n                        for (var ρσ_Index61 = 0; ρσ_Index61 < ρσ_Iter61.length; ρσ_Index61++) {\n                            cname = ρσ_Iter61[ρσ_Index61];\n                            obj = classes[(typeof cname === \"number\" && cname < 0) ? classes.length + cname : cname];\n                            key = (imp.alias) ? imp.alias.name : imp.key;\n                            (ρσ_expr_temp = (ρσ_expr_temp = S.classes)[ρσ_expr_temp.length-1])[ρσ_bound_index(key + \".\" + obj.name.name, ρσ_expr_temp)] = (function(){\n                                var ρσ_d = Object.create(null);\n                                ρσ_d[\"static\"] = obj.static;\n                                ρσ_d[\"bound\"] = obj.bound;\n                                ρσ_d[\"classvars\"] = obj.classvars;\n                                return ρσ_d;\n                            }).call(this);\n                        }\n                    }\n                }\n                return ans;\n            };\n            if (!import_.__argnames__) Object.defineProperties(import_, {\n                __argnames__ : {value: [\"from_import\"]}\n            });\n\n            function class_() {\n                var name, externaldecorator, class_details, bases, class_parent, a, docstrings, definition, descriptor, stmt, class_var_names, visitor;\n                name = as_symbol(AST_SymbolDefun);\n                if (!name) {\n                    unexpected();\n                }\n                externaldecorator = has_simple_decorator(S.decorators, \"external\");\n                class_details = (function(){\n                    var ρσ_d = Object.create(null);\n                    ρσ_d[\"static\"] = ρσ_list_decorate([]);\n                    ρσ_d[\"bound\"] = [];\n                    ρσ_d[\"classvars\"] = Object.create(null);\n                    return ρσ_d;\n                }).call(this);\n                bases = [];\n                class_parent = null;\n                if (is_(\"punc\", \"(\")) {\n                    S.in_parenthesized_expr = true;\n                    next();\n                    while (true) {\n                        if (is_(\"punc\", \")\")) {\n                            S.in_parenthesized_expr = false;\n                            next();\n                            break;\n                        }\n                        a = expr_atom(false);\n                        if (class_parent === null) {\n                            class_parent = a;\n                        }\n                        bases.push(a);\n                        if (is_(\"punc\", \",\")) {\n                            next();\n                            continue;\n                        }\n                    }\n                }\n                docstrings = [];\n                definition = new AST_Class((function(){\n                    var ρσ_d = Object.create(null);\n                    ρσ_d[\"name\"] = name;\n                    ρσ_d[\"docstrings\"] = docstrings;\n                    ρσ_d[\"module_id\"] = module_id;\n                    ρσ_d[\"dynamic_properties\"] = Object.create(null);\n                    ρσ_d[\"parent\"] = class_parent;\n                    ρσ_d[\"bases\"] = bases;\n                    ρσ_d[\"localvars\"] = ρσ_list_decorate([]);\n                    ρσ_d[\"classvars\"] = class_details.classvars;\n                    ρσ_d[\"static\"] = class_details.static;\n                    ρσ_d[\"external\"] = externaldecorator;\n                    ρσ_d[\"bound\"] = class_details.bound;\n                    ρσ_d[\"statements\"] = ρσ_list_decorate([]);\n                    ρσ_d[\"decorators\"] = function () {\n                        var d, decorator;\n                        d = ρσ_list_decorate([]);\n                        var ρσ_Iter62 = ρσ_Iterable(S.decorators);\n                        for (var ρσ_Index62 = 0; ρσ_Index62 < ρσ_Iter62.length; ρσ_Index62++) {\n                            decorator = ρσ_Iter62[ρσ_Index62];\n                            d.push(new AST_Decorator((function(){\n                                var ρσ_d = Object.create(null);\n                                ρσ_d[\"expression\"] = decorator;\n                                return ρσ_d;\n                            }).call(this)));\n                        }\n                        S.decorators = [];\n                        return d;\n                    }();\n                    ρσ_d[\"body\"] = (function() {\n                        var ρσ_anonfunc = function (loop, labels) {\n                            var a;\n                            S.in_class.push(name.name);\n                            (ρσ_expr_temp = (ρσ_expr_temp = S.classes)[ρσ_bound_index(S.classes.length - 1, ρσ_expr_temp)])[ρσ_bound_index(name.name, ρσ_expr_temp)] = class_details;\n                            S.classes.push(Object.create(null));\n                            S.scoped_flags.push();\n                            S.in_function += 1;\n                            S.in_loop = 0;\n                            S.labels = ρσ_list_decorate([]);\n                            a = block_(docstrings);\n                            S.in_function -= 1;\n                            S.scoped_flags.pop();\n                            S.classes.pop();\n                            S.in_class.pop();\n                            S.in_loop = loop;\n                            S.labels = labels;\n                            return a;\n                        };\n                        if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                            __argnames__ : {value: [\"loop\", \"labels\"]}\n                        });\n                        return ρσ_anonfunc;\n                    })()(S.in_loop, S.labels);\n                    return ρσ_d;\n                }).call(this));\n                var ρσ_Iter63 = ρσ_Iterable(definition.body);\n                for (var ρσ_Index63 = 0; ρσ_Index63 < ρσ_Iter63.length; ρσ_Index63++) {\n                    stmt = ρσ_Iter63[ρσ_Index63];\n                    if (is_node_type(stmt, AST_Method)) {\n                        if (stmt.is_getter || stmt.is_setter) {\n                            descriptor = (ρσ_expr_temp = definition.dynamic_properties)[ρσ_bound_index(stmt.name.name, ρσ_expr_temp)];\n                            if (!descriptor) {\n                                descriptor = (ρσ_expr_temp = definition.dynamic_properties)[ρσ_bound_index(stmt.name.name, ρσ_expr_temp)] = Object.create(null);\n                            }\n                            descriptor[ρσ_bound_index((stmt.is_getter) ? \"getter\" : \"setter\", descriptor)] = stmt;\n                        } else if (stmt.name.name === \"__init__\") {\n                            definition.init = stmt;\n                        }\n                    }\n                }\n                class_var_names = Object.create(null);\n                function walker() {\n                    function visit_node(node, descend) {\n                        var varname;\n                        if (is_node_type(node, AST_Method)) {\n                            class_var_names[ρσ_bound_index(node.name.name, class_var_names)] = true;\n                            return;\n                        } else if (is_node_type(node, AST_Assign) && is_node_type(node.left, AST_SymbolRef)) {\n                            varname = node.left.name;\n                            if (FORBIDDEN_CLASS_VARS.indexOf(varname) !== -1) {\n                                token_error(node.left.start, varname + \" is not allowed as a class variable name\");\n                            }\n                            class_var_names[(typeof varname === \"number\" && varname < 0) ? class_var_names.length + varname : varname] = true;\n                            (ρσ_expr_temp = definition.classvars)[(typeof varname === \"number\" && varname < 0) ? ρσ_expr_temp.length + varname : varname] = true;\n                        } else if (is_node_type(node, AST_SymbolRef) && has_prop(class_var_names, node.name)) {\n                            node.thedef = new AST_SymbolDefun((function(){\n                                var ρσ_d = Object.create(null);\n                                ρσ_d[\"name\"] = name.name + \".prototype.\" + node.name;\n                                return ρσ_d;\n                            }).call(this));\n                        }\n                        if (descend) {\n                            descend.call(node);\n                        }\n                    };\n                    if (!visit_node.__argnames__) Object.defineProperties(visit_node, {\n                        __argnames__ : {value: [\"node\", \"descend\"]}\n                    });\n\n                    this._visit = visit_node;\n                };\n\n                visitor = new walker;\n                var ρσ_Iter64 = ρσ_Iterable(definition.body);\n                for (var ρσ_Index64 = 0; ρσ_Index64 < ρσ_Iter64.length; ρσ_Index64++) {\n                    stmt = ρσ_Iter64[ρσ_Index64];\n                    if (!is_node_type(stmt, AST_Class)) {\n                        stmt.walk(visitor);\n                        definition.statements.push(stmt);\n                    }\n                }\n                return definition;\n            };\n\n            function function_(in_class, is_expression) {\n                var name, is_anonymous, staticmethod, property_getter, property_setter, staticloc, ctor, return_annotation, is_generator, docstrings, definition, assignments, j, i, nonlocals;\n                name = (is_(\"name\")) ? as_symbol((in_class) ? AST_SymbolDefun : AST_SymbolLambda) : null;\n                if (in_class && !name) {\n                    croak(\"Cannot use anonymous function as class methods\");\n                }\n                is_anonymous = !name;\n                staticmethod = property_getter = property_setter = false;\n                if (in_class) {\n                    staticloc = has_simple_decorator(S.decorators, \"staticmethod\");\n                    property_getter = has_simple_decorator(S.decorators, \"property\");\n                    property_setter = has_setter_decorator(S.decorators, name.name);\n                    if (staticloc) {\n                        if (property_getter || property_setter) {\n                            croak(\"A method cannot be both static and a property getter/setter\");\n                        }\n                        (ρσ_expr_temp = (ρσ_expr_temp = S.classes)[ρσ_bound_index(S.classes.length - 2, ρσ_expr_temp)])[(typeof in_class === \"number\" && in_class < 0) ? ρσ_expr_temp.length + in_class : in_class].static.push(name.name);\n                        staticmethod = true;\n                    } else if (name.name !== \"__init__\" && S.scoped_flags.get(\"bound_methods\")) {\n                        (ρσ_expr_temp = (ρσ_expr_temp = S.classes)[ρσ_bound_index(S.classes.length - 2, ρσ_expr_temp)])[(typeof in_class === \"number\" && in_class < 0) ? ρσ_expr_temp.length + in_class : in_class].bound.push(name.name);\n                    }\n                }\n                expect(\"(\");\n                S.in_parenthesized_expr = true;\n                ctor = (in_class) ? AST_Method : AST_Function;\n                return_annotation = null;\n                is_generator = [];\n                docstrings = [];\n                definition = new ctor((function(){\n                    var ρσ_d = Object.create(null);\n                    ρσ_d[\"name\"] = name;\n                    ρσ_d[\"is_expression\"] = is_expression;\n                    ρσ_d[\"is_anonymous\"] = is_anonymous;\n                    ρσ_d[\"argnames\"] = (function() {\n                        var ρσ_anonfunc = function (a) {\n                            var defaults, first, seen_names, def_line, current_arg_name, name_token;\n                            defaults = Object.create(null);\n                            first = true;\n                            seen_names = Object.create(null);\n                            def_line = S.input.context().tokline;\n                            current_arg_name = null;\n                            name_token = null;\n                            function get_arg() {\n                                var name_ctx, ntok, annotation, sym;\n                                current_arg_name = S.token.value;\n                                if (has_prop(seen_names, current_arg_name)) {\n                                    token_error(prev(), \"Can't repeat parameter names\");\n                                }\n                                if (current_arg_name === \"arguments\") {\n                                    token_error(prev(), \"Can't use the name arguments as a parameter name, it is reserved by JavaScript\");\n                                }\n                                seen_names[(typeof current_arg_name === \"number\" && current_arg_name < 0) ? seen_names.length + current_arg_name : current_arg_name] = true;\n                                name_token = S.token;\n                                name_ctx = S.input.context();\n                                ntok = peek();\n                                if (ntok.type === \"punc\" && ntok.value === \":\") {\n                                    next();\n                                    expect(\":\");\n                                    annotation = maybe_conditional();\n                                    if (!is_token(name_token, \"name\")) {\n                                        croak(\"Name expected\", name_ctx.tokline);\n                                        return null;\n                                    }\n                                    sym = new AST_SymbolFunarg((function(){\n                                        var ρσ_d = Object.create(null);\n                                        ρσ_d[\"name\"] = name_token.value;\n                                        ρσ_d[\"start\"] = S.token;\n                                        ρσ_d[\"end\"] = S.token;\n                                        ρσ_d[\"annotation\"] = annotation;\n                                        return ρσ_d;\n                                    }).call(this));\n                                    return sym;\n                                } else {\n                                    if (!is_(\"name\")) {\n                                        if (S.input.context().tokline !== def_line) {\n                                            croak(\"Name expected\", def_line);\n                                        } else {\n                                            croak(\"Name expected\");\n                                        }\n                                        return null;\n                                    }\n                                    sym = new AST_SymbolFunarg((function(){\n                                        var ρσ_d = Object.create(null);\n                                        ρσ_d[\"name\"] = current_arg_name;\n                                        ρσ_d[\"start\"] = S.token;\n                                        ρσ_d[\"end\"] = S.token;\n                                        ρσ_d[\"annotation\"] = null;\n                                        return ρσ_d;\n                                    }).call(this));\n                                    next();\n                                    return sym;\n                                }\n                            };\n\n                            while (!is_(\"punc\", \")\")) {\n                                if (first) {\n                                    first = false;\n                                } else {\n                                    expect(\",\");\n                                    if (is_(\"punc\", \")\")) {\n                                        break;\n                                    }\n                                }\n                                if (is_(\"operator\", \"**\")) {\n                                    next();\n                                    if (a.kwargs) {\n                                        token_error(name_token, \"Can't define multiple **kwargs in function definition\");\n                                    }\n                                    a.kwargs = get_arg();\n                                } else if (is_(\"operator\", \"*\")) {\n                                    next();\n                                    if (a.starargs) {\n                                        token_error(name_token, \"Can't define multiple *args in function definition\");\n                                    }\n                                    if (a.kwargs) {\n                                        token_error(name_token, \"Can't define *args after **kwargs in function definition\");\n                                    }\n                                    a.starargs = get_arg();\n                                } else {\n                                    if (a.starargs || a.kwargs) {\n                                        token_error(name_token, \"Can't define a formal parameter after *args or **kwargs\");\n                                    }\n                                    a.push(get_arg());\n                                    if (is_(\"operator\", \"=\")) {\n                                        if (a.kwargs) {\n                                            token_error(name_token, \"Can't define an optional formal parameter after **kwargs\");\n                                        }\n                                        next();\n                                        defaults[(typeof current_arg_name === \"number\" && current_arg_name < 0) ? defaults.length + current_arg_name : current_arg_name] = expression(false);\n                                        a.has_defaults = true;\n                                    } else {\n                                        if (a.has_defaults) {\n                                            token_error(name_token, \"Can't define required formal parameters after optional formal parameters\");\n                                        }\n                                    }\n                                }\n                            }\n                            next();\n                            if (is_(\"punc\", \"->\")) {\n                                next();\n                                return_annotation = maybe_conditional();\n                            }\n                            S.in_parenthesized_expr = false;\n                            a.defaults = defaults;\n                            a.is_simple_func = !a.starargs && !a.kwargs && !a.has_defaults;\n                            return a;\n                        };\n                        if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                            __argnames__ : {value: [\"a\"]}\n                        });\n                        return ρσ_anonfunc;\n                    })()([]);\n                    ρσ_d[\"localvars\"] = ρσ_list_decorate([]);\n                    ρσ_d[\"decorators\"] = function () {\n                        var d, decorator;\n                        d = [];\n                        var ρσ_Iter65 = ρσ_Iterable(S.decorators);\n                        for (var ρσ_Index65 = 0; ρσ_Index65 < ρσ_Iter65.length; ρσ_Index65++) {\n                            decorator = ρσ_Iter65[ρσ_Index65];\n                            d.push(new AST_Decorator((function(){\n                                var ρσ_d = Object.create(null);\n                                ρσ_d[\"expression\"] = decorator;\n                                return ρσ_d;\n                            }).call(this)));\n                        }\n                        S.decorators = [];\n                        return d;\n                    }();\n                    ρσ_d[\"docstrings\"] = docstrings;\n                    ρσ_d[\"body\"] = (function() {\n                        var ρσ_anonfunc = function (loop, labels) {\n                            var a;\n                            S.in_class.push(false);\n                            S.classes.push(Object.create(null));\n                            S.scoped_flags.push();\n                            S.in_function += 1;\n                            S.functions.push(Object.create(null));\n                            S.in_loop = 0;\n                            S.labels = ρσ_list_decorate([]);\n                            a = block_(docstrings);\n                            S.in_function -= 1;\n                            S.scoped_flags.pop();\n                            is_generator.push(bool(S.functions.pop().is_generator));\n                            S.classes.pop();\n                            S.in_class.pop();\n                            S.in_loop = loop;\n                            S.labels = labels;\n                            return a;\n                        };\n                        if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                            __argnames__ : {value: [\"loop\", \"labels\"]}\n                        });\n                        return ρσ_anonfunc;\n                    })()(S.in_loop, S.labels);\n                    return ρσ_d;\n                }).call(this));\n                definition.return_annotation = return_annotation;\n                definition.is_generator = is_generator[0];\n                if (is_node_type(definition, AST_Method)) {\n                    definition.static = staticmethod;\n                    definition.is_getter = property_getter;\n                    definition.is_setter = property_setter;\n                    if (definition.argnames.length < 1 && !definition.static) {\n                        croak(\"Methods of a class must have at least one argument, traditionally named self\");\n                    }\n                    if (definition.name && definition.name.name === \"__init__\") {\n                        if (definition.is_generator) {\n                            croak(\"The __init__ method of a class cannot be a generator (yield not allowed)\");\n                        }\n                        if (property_getter || property_setter) {\n                            croak(\"The __init__ method of a class cannot be a property getter/setter\");\n                        }\n                    }\n                }\n                if (definition.is_generator) {\n                    baselib_items[\"yield\"] = true;\n                }\n                assignments = scan_for_local_vars(definition.body);\n                for (var ρσ_Index66 = 0; ρσ_Index66 < assignments.length; ρσ_Index66++) {\n                    i = ρσ_Index66;\n                    for (var ρσ_Index67 = 0; ρσ_Index67 < definition.argnames.length + 1; ρσ_Index67++) {\n                        j = ρσ_Index67;\n                        if (j === definition.argnames.length) {\n                            definition.localvars.push(new_symbol(AST_SymbolVar, assignments[(typeof i === \"number\" && i < 0) ? assignments.length + i : i]));\n                        } else if (j < definition.argnames.length && assignments[(typeof i === \"number\" && i < 0) ? assignments.length + i : i] === (ρσ_expr_temp = definition.argnames)[(typeof j === \"number\" && j < 0) ? ρσ_expr_temp.length + j : j].name) {\n                            break;\n                        }\n                    }\n                }\n                nonlocals = scan_for_nonlocal_defs(definition.body);\n                nonlocals = (function() {\n                    var ρσ_Iter = ρσ_Iterable(nonlocals), ρσ_Result = ρσ_set(), name;\n                    for (var ρσ_Index = 0; ρσ_Index < ρσ_Iter.length; ρσ_Index++) {\n                        name = ρσ_Iter[ρσ_Index];\n                        ρσ_Result.add(name);\n                    }\n                    return ρσ_Result;\n                })();\n                definition.localvars = definition.localvars.filter((function() {\n                    var ρσ_anonfunc = function (v) {\n                        return !nonlocals.has(v.name);\n                    };\n                    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                        __argnames__ : {value: [\"v\"]}\n                    });\n                    return ρσ_anonfunc;\n                })());\n                return definition;\n            };\n            if (!function_.__argnames__) Object.defineProperties(function_, {\n                __argnames__ : {value: [\"in_class\", \"is_expression\"]}\n            });\n\n            function if_() {\n                var cond, body, belse;\n                cond = expression(true);\n                body = statement();\n                belse = null;\n                if (is_(\"keyword\", \"elif\") || is_(\"keyword\", \"else\")) {\n                    if (is_(\"keyword\", \"else\")) {\n                        next();\n                    } else {\n                        S.token.value = \"if\";\n                    }\n                    belse = statement();\n                }\n                return new AST_If((function(){\n                    var ρσ_d = Object.create(null);\n                    ρσ_d[\"condition\"] = cond;\n                    ρσ_d[\"body\"] = body;\n                    ρσ_d[\"alternative\"] = belse;\n                    return ρσ_d;\n                }).call(this));\n            };\n\n            function is_docstring(stmt) {\n                if (is_node_type(stmt, AST_SimpleStatement)) {\n                    if (is_node_type(stmt.body, AST_String)) {\n                        return stmt.body;\n                    }\n                }\n                return false;\n            };\n            if (!is_docstring.__argnames__) Object.defineProperties(is_docstring, {\n                __argnames__ : {value: [\"stmt\"]}\n            });\n\n            function block_(docstrings) {\n                var a, stmt, ds;\n                expect(\":\");\n                a = [];\n                if (!S.token.nlb) {\n                    while (!S.token.nlb) {\n                        if (is_(\"eof\")) {\n                            unexpected();\n                        }\n                        stmt = statement();\n                        if (docstrings) {\n                            ds = is_docstring(stmt);\n                            if (ds) {\n                                docstrings.push(ds);\n                                continue;\n                            }\n                        }\n                        a.push(stmt);\n                    }\n                } else {\n                    while (!is_(\"punc\", \"}\")) {\n                        if (is_(\"eof\")) {\n                            return a;\n                        }\n                        stmt = statement();\n                        if (docstrings) {\n                            ds = is_docstring(stmt);\n                            if (ds) {\n                                docstrings.push(ds);\n                                continue;\n                            }\n                        }\n                        a.push(stmt);\n                    }\n                    next();\n                }\n                return a;\n            };\n            if (!block_.__argnames__) Object.defineProperties(block_, {\n                __argnames__ : {value: [\"docstrings\"]}\n            });\n\n            function try_() {\n                var body, bcatch, bfinally, start, exceptions, name;\n                body = block_();\n                bcatch = [];\n                bfinally = null;\n                while (is_(\"keyword\", \"except\")) {\n                    start = S.token;\n                    next();\n                    exceptions = ρσ_list_decorate([]);\n                    if (!is_(\"punc\", \":\") && !is_(\"keyword\", \"as\")) {\n                        exceptions.push(as_symbol(AST_SymbolVar));\n                        while (is_(\"punc\", \",\")) {\n                            next();\n                            exceptions.push(as_symbol(AST_SymbolVar));\n                        }\n                    }\n                    name = null;\n                    if (is_(\"keyword\", \"as\")) {\n                        next();\n                        name = as_symbol(AST_SymbolCatch);\n                    }\n                    bcatch.push(new AST_Except((function(){\n                        var ρσ_d = Object.create(null);\n                        ρσ_d[\"start\"] = start;\n                        ρσ_d[\"argname\"] = name;\n                        ρσ_d[\"errors\"] = exceptions;\n                        ρσ_d[\"body\"] = block_();\n                        ρσ_d[\"end\"] = prev();\n                        return ρσ_d;\n                    }).call(this)));\n                }\n                if (is_(\"keyword\", \"finally\")) {\n                    start = S.token;\n                    next();\n                    bfinally = new AST_Finally((function(){\n                        var ρσ_d = Object.create(null);\n                        ρσ_d[\"start\"] = start;\n                        ρσ_d[\"body\"] = block_();\n                        ρσ_d[\"end\"] = prev();\n                        return ρσ_d;\n                    }).call(this));\n                }\n                if (!bcatch.length && !bfinally) {\n                    croak(\"Missing except/finally blocks\");\n                }\n                return new AST_Try((function(){\n                    var ρσ_d = Object.create(null);\n                    ρσ_d[\"body\"] = body;\n                    ρσ_d[\"bcatch\"] = (bcatch.length) ? new AST_Catch((function(){\n                        var ρσ_d = Object.create(null);\n                        ρσ_d[\"body\"] = bcatch;\n                        return ρσ_d;\n                    }).call(this)) : null;\n                    ρσ_d[\"bfinally\"] = bfinally;\n                    return ρσ_d;\n                }).call(this));\n            };\n\n            function vardefs(symbol_class) {\n                var a;\n                a = ρσ_list_decorate([]);\n                while (true) {\n                    a.push(new AST_VarDef((function(){\n                        var ρσ_d = Object.create(null);\n                        ρσ_d[\"start\"] = S.token;\n                        ρσ_d[\"name\"] = as_symbol(symbol_class);\n                        ρσ_d[\"value\"] = (is_(\"operator\", \"=\")) ? (next(), expression(false)) : null;\n                        ρσ_d[\"end\"] = prev();\n                        return ρσ_d;\n                    }).call(this)));\n                    if (!is_(\"punc\", \",\")) {\n                        break;\n                    }\n                    next();\n                }\n                return a;\n            };\n            if (!vardefs.__argnames__) Object.defineProperties(vardefs, {\n                __argnames__ : {value: [\"symbol_class\"]}\n            });\n\n            function nonlocal_(is_global) {\n                var defs, vardef;\n                defs = vardefs(AST_SymbolNonlocal);\n                if (is_global) {\n                    var ρσ_Iter68 = ρσ_Iterable(defs);\n                    for (var ρσ_Index68 = 0; ρσ_Index68 < ρσ_Iter68.length; ρσ_Index68++) {\n                        vardef = ρσ_Iter68[ρσ_Index68];\n                        S.globals.push(vardef.name.name);\n                    }\n                }\n                return new AST_Var((function(){\n                    var ρσ_d = Object.create(null);\n                    ρσ_d[\"start\"] = prev();\n                    ρσ_d[\"definitions\"] = defs;\n                    ρσ_d[\"end\"] = prev();\n                    return ρσ_d;\n                }).call(this));\n            };\n            if (!nonlocal_.__argnames__) Object.defineProperties(nonlocal_, {\n                __argnames__ : {value: [\"is_global\"]}\n            });\n\n            function new_() {\n                var start, newexp, args;\n                start = S.token;\n                expect_token(\"operator\", \"new\");\n                newexp = expr_atom(false);\n                if (is_(\"punc\", \"(\")) {\n                    S.in_parenthesized_expr = true;\n                    next();\n                    args = func_call_list();\n                    S.in_parenthesized_expr = false;\n                } else {\n                    args = func_call_list(true);\n                }\n                return subscripts(new AST_New((function(){\n                    var ρσ_d = Object.create(null);\n                    ρσ_d[\"start\"] = start;\n                    ρσ_d[\"expression\"] = newexp;\n                    ρσ_d[\"args\"] = args;\n                    ρσ_d[\"end\"] = prev();\n                    return ρσ_d;\n                }).call(this)), true);\n            };\n\n            function string_() {\n                var strings, start;\n                strings = [];\n                start = S.token;\n                while (true) {\n                    strings.push(S.token.value);\n                    if (peek().type !== \"string\") {\n                        break;\n                    }\n                    next();\n                }\n                return new AST_String((function(){\n                    var ρσ_d = Object.create(null);\n                    ρσ_d[\"start\"] = start;\n                    ρσ_d[\"end\"] = S.token;\n                    ρσ_d[\"value\"] = strings.join(\"\");\n                    return ρσ_d;\n                }).call(this));\n            };\n\n            function token_as_atom_node() {\n                var tok, tmp_, tmp__;\n                tok = S.token;\n                tmp_ = tok.type;\n                if (tmp_ === \"name\") {\n                    return token_as_symbol(tok, AST_SymbolRef);\n                } else if (tmp_ === \"num\") {\n                    return new AST_Number((function(){\n                        var ρσ_d = Object.create(null);\n                        ρσ_d[\"start\"] = tok;\n                        ρσ_d[\"end\"] = tok;\n                        ρσ_d[\"value\"] = tok.value;\n                        return ρσ_d;\n                    }).call(this));\n                } else if (tmp_ === \"string\") {\n                    return string_();\n                } else if (tmp_ === \"regexp\") {\n                    return new AST_RegExp((function(){\n                        var ρσ_d = Object.create(null);\n                        ρσ_d[\"start\"] = tok;\n                        ρσ_d[\"end\"] = tok;\n                        ρσ_d[\"value\"] = tok.value;\n                        return ρσ_d;\n                    }).call(this));\n                } else if (tmp_ === \"atom\") {\n                    tmp__ = tok.value;\n                    if (tmp__ === \"False\") {\n                        return new AST_False((function(){\n                            var ρσ_d = Object.create(null);\n                            ρσ_d[\"start\"] = tok;\n                            ρσ_d[\"end\"] = tok;\n                            return ρσ_d;\n                        }).call(this));\n                    } else if (tmp__ === \"True\") {\n                        return new AST_True((function(){\n                            var ρσ_d = Object.create(null);\n                            ρσ_d[\"start\"] = tok;\n                            ρσ_d[\"end\"] = tok;\n                            return ρσ_d;\n                        }).call(this));\n                    } else if (tmp__ === \"None\") {\n                        return new AST_Null((function(){\n                            var ρσ_d = Object.create(null);\n                            ρσ_d[\"start\"] = tok;\n                            ρσ_d[\"end\"] = tok;\n                            return ρσ_d;\n                        }).call(this));\n                    }\n                } else if (tmp_ === \"js\") {\n                    return new AST_Verbatim((function(){\n                        var ρσ_d = Object.create(null);\n                        ρσ_d[\"start\"] = tok;\n                        ρσ_d[\"end\"] = tok;\n                        ρσ_d[\"value\"] = tok.value;\n                        return ρσ_d;\n                    }).call(this));\n                }\n                token_error(tok, \"Expecting an atomic token (number/string/bool/regexp/js/None)\");\n            };\n\n            function as_atom_node() {\n                var ret;\n                ret = token_as_atom_node();\n                next();\n                return ret;\n            };\n\n            function expr_atom(allow_calls) {\n                var start, tmp_, ex, ret, cls, func;\n                if (is_(\"operator\", \"new\")) {\n                    return new_();\n                }\n                start = S.token;\n                if (is_(\"punc\")) {\n                    tmp_ = start.value;\n                    if (tmp_ === \"(\") {\n                        S.in_parenthesized_expr = true;\n                        next();\n                        if (is_(\"punc\", \")\")) {\n                            next();\n                            return new AST_Array((function(){\n                                var ρσ_d = Object.create(null);\n                                ρσ_d[\"elements\"] = ρσ_list_decorate([]);\n                                return ρσ_d;\n                            }).call(this));\n                        }\n                        ex = expression(true);\n                        if (is_(\"keyword\", \"for\")) {\n                            ret = read_comprehension(new AST_GeneratorComprehension((function(){\n                                var ρσ_d = Object.create(null);\n                                ρσ_d[\"statement\"] = ex;\n                                return ρσ_d;\n                            }).call(this)), \")\");\n                            S.in_parenthesized_expr = false;\n                            return ret;\n                        }\n                        ex.start = start;\n                        ex.end = S.token;\n                        if (is_node_type(ex, AST_SymbolRef)) {\n                            ex.parens = true;\n                        }\n                        if (!is_node_type(ex, AST_GeneratorComprehension)) {\n                            expect(\")\");\n                        }\n                        S.in_parenthesized_expr = false;\n                        return subscripts(ex, allow_calls);\n                    } else if (tmp_ === \"[\") {\n                        return subscripts(array_(), allow_calls);\n                    } else if (tmp_ === \"{\") {\n                        return subscripts(object_(), allow_calls);\n                    }\n                    unexpected();\n                }\n                if (is_(\"keyword\", \"class\")) {\n                    next();\n                    cls = class_();\n                    cls.start = start;\n                    cls.end = prev();\n                    return subscripts(cls, allow_calls);\n                }\n                if (is_(\"keyword\", \"def\")) {\n                    next();\n                    func = function_(false, true);\n                    func.start = start;\n                    func.end = prev();\n                    return subscripts(func, allow_calls);\n                }\n                if (is_(\"keyword\", \"yield\")) {\n                    next();\n                    return yield_();\n                }\n                if (ATOMIC_START_TOKEN[ρσ_bound_index(S.token.type, ATOMIC_START_TOKEN)]) {\n                    return subscripts(as_atom_node(), allow_calls);\n                }\n                unexpected();\n            };\n            if (!expr_atom.__argnames__) Object.defineProperties(expr_atom, {\n                __argnames__ : {value: [\"allow_calls\"]}\n            });\n\n            function expr_list(closing, allow_trailing_comma, allow_empty, func_call) {\n                var first, a, saw_starargs, tmp, arg;\n                first = true;\n                a = ρσ_list_decorate([]);\n                saw_starargs = false;\n                while (!is_(\"punc\", closing)) {\n                    if (saw_starargs) {\n                        token_error(prev(), \"*args must be the last argument in a function call\");\n                    }\n                    if (first) {\n                        first = false;\n                    } else {\n                        expect(\",\");\n                    }\n                    if (allow_trailing_comma && is_(\"punc\", closing)) {\n                        break;\n                    }\n                    if (is_(\"operator\", \"*\") && func_call) {\n                        saw_starargs = true;\n                        next();\n                    }\n                    if (is_(\"punc\", \",\") && allow_empty) {\n                        a.push(new AST_Hole((function(){\n                            var ρσ_d = Object.create(null);\n                            ρσ_d[\"start\"] = S.token;\n                            ρσ_d[\"end\"] = S.token;\n                            return ρσ_d;\n                        }).call(this)));\n                    } else {\n                        a.push(expression(false));\n                    }\n                }\n                if (func_call) {\n                    tmp = ρσ_list_decorate([]);\n                    tmp.kwargs = ρσ_list_decorate([]);\n                    var ρσ_Iter69 = ρσ_Iterable(a);\n                    for (var ρσ_Index69 = 0; ρσ_Index69 < ρσ_Iter69.length; ρσ_Index69++) {\n                        arg = ρσ_Iter69[ρσ_Index69];\n                        if (is_node_type(arg, AST_Assign)) {\n                            tmp.kwargs.push(ρσ_list_decorate([ arg.left, arg.right ]));\n                        } else {\n                            tmp.push(arg);\n                        }\n                    }\n                    a = tmp;\n                }\n                next();\n                if (saw_starargs) {\n                    a.starargs = true;\n                }\n                return a;\n            };\n            if (!expr_list.__argnames__) Object.defineProperties(expr_list, {\n                __argnames__ : {value: [\"closing\", \"allow_trailing_comma\", \"allow_empty\", \"func_call\"]}\n            });\n\n            function func_call_list(empty) {\n                var a, first, single_comprehension, arg;\n                a = [];\n                first = true;\n                a.kwargs = [];\n                a.kwarg_items = [];\n                a.starargs = false;\n                if (empty) {\n                    return a;\n                }\n                single_comprehension = false;\n                while (!is_(\"punc\", \")\") && !is_(\"eof\")) {\n                    if (!first) {\n                        expect(\",\");\n                        if (is_(\"punc\", \")\")) {\n                            break;\n                        }\n                    }\n                    if (is_(\"operator\", \"*\")) {\n                        next();\n                        arg = expression(false);\n                        arg.is_array = true;\n                        a.push(arg);\n                        a.starargs = true;\n                    } else if (is_(\"operator\", \"**\")) {\n                        next();\n                        a.kwarg_items.push(as_symbol(AST_SymbolRef, false));\n                        a.starargs = true;\n                    } else {\n                        arg = expression(false);\n                        if (is_node_type(arg, AST_Assign)) {\n                            a.kwargs.push(ρσ_list_decorate([ arg.left, arg.right ]));\n                        } else {\n                            if (is_(\"keyword\", \"for\")) {\n                                if (!first) {\n                                    croak(\"Generator expression must be parenthesized if not sole argument\");\n                                }\n                                a.push(read_comprehension(new AST_GeneratorComprehension((function(){\n                                    var ρσ_d = Object.create(null);\n                                    ρσ_d[\"statement\"] = arg;\n                                    return ρσ_d;\n                                }).call(this)), \")\"));\n                                single_comprehension = true;\n                                break;\n                            }\n                            a.push(arg);\n                        }\n                    }\n                    first = false;\n                }\n                if (!single_comprehension) {\n                    next();\n                }\n                return a;\n            };\n            if (!func_call_list.__argnames__) Object.defineProperties(func_call_list, {\n                __argnames__ : {value: [\"empty\"]}\n            });\n\n            \n            var array_ = embed_tokens(function array_() {\n                var expr;\n                expect(\"[\");\n                expr = ρσ_list_decorate([]);\n                if (!is_(\"punc\", \"]\")) {\n                    expr.push(expression(false));\n                    if (is_(\"keyword\", \"for\")) {\n                        return read_comprehension(new AST_ListComprehension((function(){\n                            var ρσ_d = Object.create(null);\n                            ρσ_d[\"statement\"] = expr[0];\n                            return ρσ_d;\n                        }).call(this)), \"]\");\n                    }\n                    if (!is_(\"punc\", \"]\")) {\n                        expect(\",\");\n                    }\n                }\n                return new AST_Array((function(){\n                    var ρσ_d = Object.create(null);\n                    ρσ_d[\"elements\"] = expr.concat(expr_list(\"]\", true, true));\n                    return ρσ_d;\n                }).call(this));\n            });\n\n            \n            var object_ = embed_tokens(function object_() {\n                var first, has_non_const_keys, is_pydict, is_jshash, a, start, ctx, orig, left, end;\n                expect(\"{\");\n                first = true;\n                has_non_const_keys = false;\n                is_pydict = S.scoped_flags.get(\"dict_literals\", false);\n                is_jshash = S.scoped_flags.get(\"hash_literals\", false);\n                a = ρσ_list_decorate([]);\n                while (!is_(\"punc\", \"}\")) {\n                    if (!first) {\n                        expect(\",\");\n                    }\n                    if (is_(\"punc\", \"}\")) {\n                        break;\n                    }\n                    first = false;\n                    start = S.token;\n                    ctx = S.input.context();\n                    orig = ctx.expecting_object_literal_key;\n                    ctx.expecting_object_literal_key = true;\n                    try {\n                        left = expression(false);\n                    } finally {\n                        ctx.expecting_object_literal_key = orig;\n                    }\n                    if (is_(\"keyword\", \"for\")) {\n                        return read_comprehension(new AST_SetComprehension((function(){\n                            var ρσ_d = Object.create(null);\n                            ρσ_d[\"statement\"] = left;\n                            return ρσ_d;\n                        }).call(this)), \"}\");\n                    }\n                    if (a.length === 0 && (is_(\"punc\", \",\") || is_(\"punc\", \"}\"))) {\n                        end = prev();\n                        return set_(start, end, left);\n                    }\n                    if (!is_node_type(left, AST_Constant)) {\n                        has_non_const_keys = true;\n                    }\n                    expect(\":\");\n                    a.push(new AST_ObjectKeyVal((function(){\n                        var ρσ_d = Object.create(null);\n                        ρσ_d[\"start\"] = start;\n                        ρσ_d[\"key\"] = left;\n                        ρσ_d[\"value\"] = expression(false);\n                        ρσ_d[\"end\"] = prev();\n                        return ρσ_d;\n                    }).call(this)));\n                    if (a.length === 1 && is_(\"keyword\", \"for\")) {\n                        return dict_comprehension(a, is_pydict, is_jshash);\n                    }\n                }\n                next();\n                return new ((has_non_const_keys) ? AST_ExpressiveObject : AST_Object)((function(){\n                    var ρσ_d = Object.create(null);\n                    ρσ_d[\"properties\"] = a;\n                    ρσ_d[\"is_pydict\"] = is_pydict;\n                    ρσ_d[\"is_jshash\"] = is_jshash;\n                    return ρσ_d;\n                }).call(this));\n            });\n\n            function set_(start, end, expr) {\n                var ostart, a;\n                ostart = start;\n                a = ρσ_list_decorate([ new AST_SetItem((function(){\n                    var ρσ_d = Object.create(null);\n                    ρσ_d[\"start\"] = start;\n                    ρσ_d[\"end\"] = end;\n                    ρσ_d[\"value\"] = expr;\n                    return ρσ_d;\n                }).call(this)) ]);\n                while (!is_(\"punc\", \"}\")) {\n                    expect(\",\");\n                    start = S.token;\n                    if (is_(\"punc\", \"}\")) {\n                        break;\n                    }\n                    a.push(new AST_SetItem((function(){\n                        var ρσ_d = Object.create(null);\n                        ρσ_d[\"start\"] = start;\n                        ρσ_d[\"value\"] = expression(false);\n                        ρσ_d[\"end\"] = prev();\n                        return ρσ_d;\n                    }).call(this)));\n                }\n                next();\n                return new AST_Set((function(){\n                    var ρσ_d = Object.create(null);\n                    ρσ_d[\"items\"] = a;\n                    ρσ_d[\"start\"] = ostart;\n                    ρσ_d[\"end\"] = prev();\n                    return ρσ_d;\n                }).call(this));\n            };\n            if (!set_.__argnames__) Object.defineProperties(set_, {\n                __argnames__ : {value: [\"start\", \"end\", \"expr\"]}\n            });\n\n            function read_comprehension(obj, terminator) {\n                var forloop;\n                if (is_node_type(obj, AST_GeneratorComprehension)) {\n                    baselib_items[\"yield\"] = true;\n                }\n                S.in_comprehension = true;\n                S.in_parenthesized_expr = false;\n                expect_token(\"keyword\", \"for\");\n                forloop = for_(true);\n                obj.init = forloop.init;\n                obj.name = forloop.name;\n                obj.object = forloop.object;\n                obj.condition = (is_(\"punc\", terminator)) ? null : (expect_token(\"keyword\", \"if\"), \n                expression(true));\n                expect(terminator);\n                S.in_comprehension = false;\n                return obj;\n            };\n            if (!read_comprehension.__argnames__) Object.defineProperties(read_comprehension, {\n                __argnames__ : {value: [\"obj\", \"terminator\"]}\n            });\n\n            function dict_comprehension(a, is_pydict, is_jshash) {\n                var ρσ_unpack, left, right;\n                if (a.length) {\n                    ρσ_unpack = [a[0].key, a[0].value];\n                    left = ρσ_unpack[0];\n                    right = ρσ_unpack[1];\n                } else {\n                    left = expression(false);\n                    if (!is_(\"punc\", \":\")) {\n                        return read_comprehension(new AST_SetComprehension((function(){\n                            var ρσ_d = Object.create(null);\n                            ρσ_d[\"statement\"] = left;\n                            return ρσ_d;\n                        }).call(this)), \"}\");\n                    }\n                    expect(\":\");\n                    right = expression(false);\n                }\n                return read_comprehension(new AST_DictComprehension((function(){\n                    var ρσ_d = Object.create(null);\n                    ρσ_d[\"statement\"] = left;\n                    ρσ_d[\"value_statement\"] = right;\n                    ρσ_d[\"is_pydict\"] = is_pydict;\n                    ρσ_d[\"is_jshash\"] = is_jshash;\n                    return ρσ_d;\n                }).call(this)), \"}\");\n            };\n            if (!dict_comprehension.__argnames__) Object.defineProperties(dict_comprehension, {\n                __argnames__ : {value: [\"a\", \"is_pydict\", \"is_jshash\"]}\n            });\n\n            function as_name() {\n                var tmp, tmp_;\n                tmp = S.token;\n                next();\n                tmp_ = tmp.type;\n                if (tmp_ === \"name\" || tmp_ === \"operator\" || tmp_ === \"keyword\" || tmp_ === \"atom\") {\n                    return tmp.value;\n                } else {\n                    unexpected();\n                }\n            };\n\n            function token_as_symbol(tok, ttype) {\n                var name;\n                name = tok.value;\n                if (RESERVED_WORDS[(typeof name === \"number\" && name < 0) ? RESERVED_WORDS.length + name : name] && name !== \"this\") {\n                    croak(name + \" is a reserved word\");\n                }\n                return new ((name === \"this\") ? AST_This : ttype)((function(){\n                    var ρσ_d = Object.create(null);\n                    ρσ_d[\"name\"] = String(tok.value);\n                    ρσ_d[\"start\"] = tok;\n                    ρσ_d[\"end\"] = tok;\n                    return ρσ_d;\n                }).call(this));\n            };\n            if (!token_as_symbol.__argnames__) Object.defineProperties(token_as_symbol, {\n                __argnames__ : {value: [\"tok\", \"ttype\"]}\n            });\n\n            function as_symbol(ttype, noerror) {\n                var sym;\n                if (!is_(\"name\")) {\n                    if (!noerror) {\n                        croak(\"Name expected\");\n                    }\n                    return null;\n                }\n                sym = token_as_symbol(S.token, ttype);\n                next();\n                return sym;\n            };\n            if (!as_symbol.__argnames__) Object.defineProperties(as_symbol, {\n                __argnames__ : {value: [\"ttype\", \"noerror\"]}\n            });\n\n            function new_symbol(type, name) {\n                var sym;\n                sym = new ((name === \"this\") ? AST_This : type)((function(){\n                    var ρσ_d = Object.create(null);\n                    ρσ_d[\"name\"] = String(name);\n                    ρσ_d[\"start\"] = null;\n                    ρσ_d[\"end\"] = null;\n                    return ρσ_d;\n                }).call(this));\n                return sym;\n            };\n            if (!new_symbol.__argnames__) Object.defineProperties(new_symbol, {\n                __argnames__ : {value: [\"type\", \"name\"]}\n            });\n\n            function is_static_method(cls, method) {\n                if (COMMON_STATIC.indexOf(method) !== -1 || cls.static && cls.static.indexOf(method) !== -1) {\n                    return true;\n                } else {\n                    return false;\n                }\n            };\n            if (!is_static_method.__argnames__) Object.defineProperties(is_static_method, {\n                __argnames__ : {value: [\"cls\", \"method\"]}\n            });\n\n            function getitem(expr, allow_calls) {\n                var start, is_py_sub, slice_bounds, is_slice, i, assignment;\n                start = expr.start;\n                next();\n                is_py_sub = S.scoped_flags.get(\"overload_getitem\", false);\n                slice_bounds = [];\n                is_slice = false;\n                if (is_(\"punc\", \":\")) {\n                    slice_bounds.push(null);\n                } else {\n                    slice_bounds.push(expression(false));\n                }\n                if (is_(\"punc\", \":\")) {\n                    is_slice = true;\n                    next();\n                    if (is_(\"punc\", \":\")) {\n                        slice_bounds.push(null);\n                    } else if (!is_(\"punc\", \"]\")) {\n                        slice_bounds.push(expression(false));\n                    }\n                }\n                if (is_(\"punc\", \":\")) {\n                    next();\n                    if (is_(\"punc\", \"]\")) {\n                        unexpected();\n                    } else {\n                        slice_bounds.push(expression(false));\n                    }\n                }\n                expect(\"]\");\n                if (is_slice) {\n                    if (is_(\"operator\", \"=\")) {\n                        next();\n                        return subscripts(new AST_Splice((function(){\n                            var ρσ_d = Object.create(null);\n                            ρσ_d[\"start\"] = start;\n                            ρσ_d[\"expression\"] = expr;\n                            ρσ_d[\"property\"] = slice_bounds[0] || new AST_Number((function(){\n                                var ρσ_d = Object.create(null);\n                                ρσ_d[\"value\"] = 0;\n                                return ρσ_d;\n                            }).call(this));\n                            ρσ_d[\"property2\"] = slice_bounds[1];\n                            ρσ_d[\"assignment\"] = expression(true);\n                            ρσ_d[\"end\"] = prev();\n                            return ρσ_d;\n                        }).call(this)), allow_calls);\n                    } else if (slice_bounds.length === 3) {\n                        slice_bounds.unshift(slice_bounds.pop());\n                        if (!slice_bounds[slice_bounds.length-1]) {\n                            slice_bounds.pop();\n                            if (!slice_bounds[slice_bounds.length-1]) {\n                                slice_bounds.pop();\n                            }\n                        } else if (!slice_bounds[slice_bounds.length-2]) {\n                            slice_bounds[slice_bounds.length-2] = new AST_Undefined;\n                        }\n                        return subscripts(new AST_Call((function(){\n                            var ρσ_d = Object.create(null);\n                            ρσ_d[\"start\"] = start;\n                            ρσ_d[\"expression\"] = new AST_SymbolRef((function(){\n                                var ρσ_d = Object.create(null);\n                                ρσ_d[\"name\"] = (S.in_delete) ? \"ρσ_delslice\" : \"ρσ_eslice\";\n                                return ρσ_d;\n                            }).call(this));\n                            ρσ_d[\"args\"] = ρσ_list_decorate([ expr ]).concat(slice_bounds);\n                            ρσ_d[\"end\"] = prev();\n                            return ρσ_d;\n                        }).call(this)), allow_calls);\n                    } else {\n                        slice_bounds = (function() {\n                            var ρσ_Iter = ρσ_Iterable(slice_bounds), ρσ_Result = [], i;\n                            for (var ρσ_Index = 0; ρσ_Index < ρσ_Iter.length; ρσ_Index++) {\n                                i = ρσ_Iter[ρσ_Index];\n                                ρσ_Result.push((i === null) ? new AST_Number((function(){\n                                    var ρσ_d = Object.create(null);\n                                    ρσ_d[\"value\"] = 0;\n                                    return ρσ_d;\n                                }).call(this)) : i);\n                            }\n                            ρσ_Result = ρσ_list_constructor(ρσ_Result);\n                            return ρσ_Result;\n                        })();\n                        if (S.in_delete) {\n                            return subscripts(new AST_Call((function(){\n                                var ρσ_d = Object.create(null);\n                                ρσ_d[\"start\"] = start;\n                                ρσ_d[\"expression\"] = new AST_SymbolRef((function(){\n                                    var ρσ_d = Object.create(null);\n                                    ρσ_d[\"name\"] = \"ρσ_delslice\";\n                                    return ρσ_d;\n                                }).call(this));\n                                ρσ_d[\"args\"] = ρσ_list_decorate([ expr, new AST_Number((function(){\n                                    var ρσ_d = Object.create(null);\n                                    ρσ_d[\"value\"] = 1;\n                                    return ρσ_d;\n                                }).call(this)) ]).concat(slice_bounds);\n                                ρσ_d[\"end\"] = prev();\n                                return ρσ_d;\n                            }).call(this)), allow_calls);\n                        }\n                        return subscripts(new AST_Call((function(){\n                            var ρσ_d = Object.create(null);\n                            ρσ_d[\"start\"] = start;\n                            ρσ_d[\"expression\"] = new AST_Dot((function(){\n                                var ρσ_d = Object.create(null);\n                                ρσ_d[\"start\"] = start;\n                                ρσ_d[\"expression\"] = expr;\n                                ρσ_d[\"property\"] = \"slice\";\n                                ρσ_d[\"end\"] = prev();\n                                return ρσ_d;\n                            }).call(this));\n                            ρσ_d[\"args\"] = slice_bounds;\n                            ρσ_d[\"end\"] = prev();\n                            return ρσ_d;\n                        }).call(this)), allow_calls);\n                    }\n                } else {\n                    if (is_py_sub) {\n                        assignment = null;\n                        if (is_(\"operator\") && S.token.value === \"=\") {\n                            next();\n                            assignment = expression(true);\n                        }\n                        return subscripts(new AST_ItemAccess((function(){\n                            var ρσ_d = Object.create(null);\n                            ρσ_d[\"start\"] = start;\n                            ρσ_d[\"expression\"] = expr;\n                            ρσ_d[\"property\"] = slice_bounds[0] || new AST_Number((function(){\n                                var ρσ_d = Object.create(null);\n                                ρσ_d[\"value\"] = 0;\n                                return ρσ_d;\n                            }).call(this));\n                            ρσ_d[\"assignment\"] = assignment;\n                            ρσ_d[\"end\"] = prev();\n                            return ρσ_d;\n                        }).call(this)), allow_calls);\n                    }\n                    return subscripts(new AST_Sub((function(){\n                        var ρσ_d = Object.create(null);\n                        ρσ_d[\"start\"] = start;\n                        ρσ_d[\"expression\"] = expr;\n                        ρσ_d[\"property\"] = slice_bounds[0] || new AST_Number((function(){\n                            var ρσ_d = Object.create(null);\n                            ρσ_d[\"value\"] = 0;\n                            return ρσ_d;\n                        }).call(this));\n                        ρσ_d[\"end\"] = prev();\n                        return ρσ_d;\n                    }).call(this)), allow_calls);\n                }\n            };\n            if (!getitem.__argnames__) Object.defineProperties(getitem, {\n                __argnames__ : {value: [\"expr\", \"allow_calls\"]}\n            });\n\n            function call_(expr) {\n                var start, ret, c, funcname, tmp_, args;\n                start = expr.start;\n                S.in_parenthesized_expr = true;\n                next();\n                if (!expr.parens && get_class_in_scope(expr)) {\n                    ret = subscripts(new AST_New((function(){\n                        var ρσ_d = Object.create(null);\n                        ρσ_d[\"start\"] = start;\n                        ρσ_d[\"expression\"] = expr;\n                        ρσ_d[\"args\"] = func_call_list();\n                        ρσ_d[\"end\"] = prev();\n                        return ρσ_d;\n                    }).call(this)), true);\n                    S.in_parenthesized_expr = false;\n                    return ret;\n                } else {\n                    if (is_node_type(expr, AST_Dot)) {\n                        c = get_class_in_scope(expr.expression);\n                    }\n                    if (c) {\n                        funcname = expr;\n                        ret = subscripts(new AST_ClassCall((function(){\n                            var ρσ_d = Object.create(null);\n                            ρσ_d[\"start\"] = start;\n                            ρσ_d[\"class\"] = expr.expression;\n                            ρσ_d[\"method\"] = funcname.property;\n                            ρσ_d[\"static\"] = is_static_method(c, funcname.property);\n                            ρσ_d[\"args\"] = func_call_list();\n                            ρσ_d[\"end\"] = prev();\n                            return ρσ_d;\n                        }).call(this)), true);\n                        S.in_parenthesized_expr = false;\n                        return ret;\n                    } else if (is_node_type(expr, AST_SymbolRef)) {\n                        tmp_ = expr.name;\n                        if (tmp_ === \"jstype\") {\n                            ret = new AST_UnaryPrefix((function(){\n                                var ρσ_d = Object.create(null);\n                                ρσ_d[\"start\"] = start;\n                                ρσ_d[\"operator\"] = \"typeof\";\n                                ρσ_d[\"expression\"] = func_call_list()[0];\n                                ρσ_d[\"end\"] = prev();\n                                return ρσ_d;\n                            }).call(this));\n                            S.in_parenthesized_expr = false;\n                            return ret;\n                        } else if (tmp_ === \"isinstance\") {\n                            args = func_call_list();\n                            if (args.length !== 2) {\n                                croak(\"isinstance() must be called with exactly two arguments\");\n                            }\n                            ret = new AST_Binary((function(){\n                                var ρσ_d = Object.create(null);\n                                ρσ_d[\"start\"] = start;\n                                ρσ_d[\"left\"] = args[0];\n                                ρσ_d[\"operator\"] = \"instanceof\";\n                                ρσ_d[\"right\"] = args[1];\n                                ρσ_d[\"end\"] = prev();\n                                return ρσ_d;\n                            }).call(this));\n                            S.in_parenthesized_expr = false;\n                            return ret;\n                        }\n                    }\n                    ret = subscripts(new AST_Call((function(){\n                        var ρσ_d = Object.create(null);\n                        ρσ_d[\"start\"] = start;\n                        ρσ_d[\"expression\"] = expr;\n                        ρσ_d[\"args\"] = func_call_list();\n                        ρσ_d[\"end\"] = prev();\n                        return ρσ_d;\n                    }).call(this)), true);\n                    S.in_parenthesized_expr = false;\n                    return ret;\n                }\n            };\n            if (!call_.__argnames__) Object.defineProperties(call_, {\n                __argnames__ : {value: [\"expr\"]}\n            });\n\n            function get_attr(expr, allow_calls) {\n                var prop, c;\n                next();\n                prop = as_name();\n                c = get_class_in_scope(expr);\n                if (c && c.classvars && c.classvars[prop]) {\n                    prop = \"prototype.\" + prop;\n                }\n                return subscripts(new AST_Dot((function(){\n                    var ρσ_d = Object.create(null);\n                    ρσ_d[\"start\"] = expr.start;\n                    ρσ_d[\"expression\"] = expr;\n                    ρσ_d[\"property\"] = prop;\n                    ρσ_d[\"end\"] = prev();\n                    return ρσ_d;\n                }).call(this)), allow_calls);\n            };\n            if (!get_attr.__argnames__) Object.defineProperties(get_attr, {\n                __argnames__ : {value: [\"expr\", \"allow_calls\"]}\n            });\n\n            function existential(expr, allow_calls) {\n                var ans, ttype, val, is_py_sub;\n                ans = new AST_Existential((function(){\n                    var ρσ_d = Object.create(null);\n                    ρσ_d[\"start\"] = expr.start;\n                    ρσ_d[\"end\"] = S.token;\n                    ρσ_d[\"expression\"] = expr;\n                    return ρσ_d;\n                }).call(this));\n                next();\n                ttype = S.token.type;\n                val = S.token.value;\n                if (S.token.nlb || ttype === \"keyword\" || ttype === \"operator\" || ttype === \"eof\") {\n                    ans.after = null;\n                    return ans;\n                }\n                if (ttype === \"punc\") {\n                    if (val === \".\") {\n                        ans.after = \".\";\n                    } else if (val === \"[\") {\n                        is_py_sub = S.scoped_flags.get(\"overload_getitem\", false);\n                        ans.after = (is_py_sub) ? \"g\" : \"[\";\n                    } else if (val === \"(\") {\n                        if (!allow_calls) {\n                            unexpected();\n                        }\n                        ans.after = \"(\";\n                    } else {\n                        ans.after = null;\n                        return ans;\n                    }\n                    return subscripts(ans, allow_calls);\n                }\n                ans.after = expression();\n                return ans;\n            };\n            if (!existential.__argnames__) Object.defineProperties(existential, {\n                __argnames__ : {value: [\"expr\", \"allow_calls\"]}\n            });\n\n            function subscripts(expr, allow_calls) {\n                if (is_(\"punc\", \".\")) {\n                    return get_attr(expr, allow_calls);\n                }\n                if (is_(\"punc\", \"[\") && !S.token.nlb) {\n                    return getitem(expr, allow_calls);\n                }\n                if (allow_calls && is_(\"punc\", \"(\") && !S.token.nlb) {\n                    return call_(expr);\n                }\n                if (is_(\"punc\", \"?\")) {\n                    return existential(expr, allow_calls);\n                }\n                return expr;\n            };\n            if (!subscripts.__argnames__) Object.defineProperties(subscripts, {\n                __argnames__ : {value: [\"expr\", \"allow_calls\"]}\n            });\n\n            function maybe_unary(allow_calls) {\n                var start, expr, ex, val;\n                start = S.token;\n                if (is_(\"operator\", \"@\")) {\n                    if (S.parsing_decorator) {\n                        croak(\"Nested decorators are not allowed\");\n                    }\n                    next();\n                    S.parsing_decorator = true;\n                    expr = expression();\n                    S.parsing_decorator = false;\n                    S.decorators.push(expr);\n                    return new AST_EmptyStatement((function(){\n                        var ρσ_d = Object.create(null);\n                        ρσ_d[\"stype\"] = \"@\";\n                        ρσ_d[\"start\"] = prev();\n                        ρσ_d[\"end\"] = prev();\n                        return ρσ_d;\n                    }).call(this));\n                }\n                if (is_(\"operator\") && UNARY_PREFIX[ρσ_bound_index(start.value, UNARY_PREFIX)]) {\n                    next();\n                    S.in_delete = start.value === \"delete\";\n                    expr = maybe_unary(allow_calls);\n                    S.in_delete = false;\n                    ex = make_unary(AST_UnaryPrefix, start.value, expr);\n                    ex.start = start;\n                    ex.end = prev();\n                    return ex;\n                }\n                val = expr_atom(allow_calls);\n                return val;\n            };\n            if (!maybe_unary.__argnames__) Object.defineProperties(maybe_unary, {\n                __argnames__ : {value: [\"allow_calls\"]}\n            });\n\n            function make_unary(ctor, op, expr) {\n                return new ctor((function(){\n                    var ρσ_d = Object.create(null);\n                    ρσ_d[\"operator\"] = op;\n                    ρσ_d[\"expression\"] = expr;\n                    return ρσ_d;\n                }).call(this));\n            };\n            if (!make_unary.__argnames__) Object.defineProperties(make_unary, {\n                __argnames__ : {value: [\"ctor\", \"op\", \"expr\"]}\n            });\n\n            function expr_op(left, min_prec, no_in) {\n                var op, not_in, prec, right, ret;\n                op = (is_(\"operator\")) ? S.token.value : null;\n                not_in = false;\n                if (op === \"!\" && peek().type === \"operator\" && peek().value === \"in\") {\n                    next();\n                    op = \"in\";\n                    not_in = true;\n                }\n                if (op === \"in\") {\n                    if (no_in) {\n                        op = null;\n                    }\n                }\n                prec = (op !== null) ? PRECEDENCE[(typeof op === \"number\" && op < 0) ? PRECEDENCE.length + op : op] : null;\n                if (prec !== null && prec > min_prec) {\n                    next();\n                    right = expr_op(maybe_unary(true), prec, no_in);\n                    ret = new AST_Binary((function(){\n                        var ρσ_d = Object.create(null);\n                        ρσ_d[\"start\"] = left.start;\n                        ρσ_d[\"left\"] = left;\n                        ρσ_d[\"operator\"] = op;\n                        ρσ_d[\"right\"] = right;\n                        ρσ_d[\"end\"] = right.end;\n                        return ρσ_d;\n                    }).call(this));\n                    if (not_in) {\n                        ret = new AST_UnaryPrefix((function(){\n                            var ρσ_d = Object.create(null);\n                            ρσ_d[\"start\"] = left.start;\n                            ρσ_d[\"operator\"] = \"!\";\n                            ρσ_d[\"expression\"] = ret;\n                            ρσ_d[\"end\"] = right.end;\n                            return ρσ_d;\n                        }).call(this));\n                    }\n                    return expr_op(ret, min_prec, no_in);\n                }\n                return left;\n            };\n            if (!expr_op.__argnames__) Object.defineProperties(expr_op, {\n                __argnames__ : {value: [\"left\", \"min_prec\", \"no_in\"]}\n            });\n\n            function expr_ops(no_in) {\n                return expr_op(maybe_unary(true), 0, no_in);\n            };\n            if (!expr_ops.__argnames__) Object.defineProperties(expr_ops, {\n                __argnames__ : {value: [\"no_in\"]}\n            });\n\n            function maybe_conditional(no_in) {\n                var start, expr, ne, conditional;\n                start = S.token;\n                expr = expr_ops(no_in);\n                if (is_(\"keyword\", \"if\") && (S.in_parenthesized_expr || S.statement_starting_token !== S.token && !S.in_comprehension && !S.token.nlb)) {\n                    next();\n                    ne = expression(false);\n                    expect_token(\"keyword\", \"else\");\n                    conditional = new AST_Conditional((function(){\n                        var ρσ_d = Object.create(null);\n                        ρσ_d[\"start\"] = start;\n                        ρσ_d[\"condition\"] = ne;\n                        ρσ_d[\"consequent\"] = expr;\n                        ρσ_d[\"alternative\"] = expression(false, no_in);\n                        ρσ_d[\"end\"] = peek();\n                        return ρσ_d;\n                    }).call(this));\n                    return conditional;\n                }\n                return expr;\n            };\n            if (!maybe_conditional.__argnames__) Object.defineProperties(maybe_conditional, {\n                __argnames__ : {value: [\"no_in\"]}\n            });\n\n            function create_assign(data) {\n                if (data.right && is_node_type(data.right, AST_Seq) && (is_node_type(data.right.car, AST_Assign) || is_node_type(data.right.cdr, AST_Assign)) && data.operator !== \"=\") {\n                    token_error(data.start, \"Invalid assignment operator for chained assignment: \" + data.operator);\n                }\n                return new AST_Assign(data);\n            };\n            if (!create_assign.__argnames__) Object.defineProperties(create_assign, {\n                __argnames__ : {value: [\"data\"]}\n            });\n\n            function maybe_assign(no_in, only_plain_assignment) {\n                var start, left, val;\n                start = S.token;\n                left = maybe_conditional(no_in);\n                val = S.token.value;\n                if (is_(\"operator\") && ASSIGNMENT[(typeof val === \"number\" && val < 0) ? ASSIGNMENT.length + val : val]) {\n                    if (only_plain_assignment && val !== \"=\") {\n                        croak(\"Invalid assignment operator for chained assignment: \" + val);\n                    }\n                    next();\n                    return create_assign((function(){\n                        var ρσ_d = Object.create(null);\n                        ρσ_d[\"start\"] = start;\n                        ρσ_d[\"left\"] = left;\n                        ρσ_d[\"operator\"] = val;\n                        ρσ_d[\"right\"] = maybe_assign(no_in, true);\n                        ρσ_d[\"end\"] = prev();\n                        return ρσ_d;\n                    }).call(this));\n                }\n                return left;\n            };\n            if (!maybe_assign.__argnames__) Object.defineProperties(maybe_assign, {\n                __argnames__ : {value: [\"no_in\", \"only_plain_assignment\"]}\n            });\n\n            function expression(commas, no_in) {\n                var start, expr, left;\n                start = S.token;\n                expr = maybe_assign(no_in);\n                function build_seq(a) {\n                    if (a.length === 1) {\n                        return a[0];\n                    }\n                    return new AST_Seq((function(){\n                        var ρσ_d = Object.create(null);\n                        ρσ_d[\"start\"] = start;\n                        ρσ_d[\"car\"] = a.shift();\n                        ρσ_d[\"cdr\"] = build_seq(a);\n                        ρσ_d[\"end\"] = peek();\n                        return ρσ_d;\n                    }).call(this));\n                };\n                if (!build_seq.__argnames__) Object.defineProperties(build_seq, {\n                    __argnames__ : {value: [\"a\"]}\n                });\n\n                if (commas) {\n                    left = [ expr ];\n                    while (is_(\"punc\", \",\") && !peek().nlb) {\n                        next();\n                        if (is_node_type(expr, AST_Assign)) {\n                            left[left.length-1] = left[left.length-1].left;\n                            return create_assign((function(){\n                                var ρσ_d = Object.create(null);\n                                ρσ_d[\"start\"] = start;\n                                ρσ_d[\"left\"] = (left.length === 1) ? left[0] : new AST_Array((function(){\n                                    var ρσ_d = Object.create(null);\n                                    ρσ_d[\"elements\"] = left;\n                                    return ρσ_d;\n                                }).call(this));\n                                ρσ_d[\"operator\"] = expr.operator;\n                                ρσ_d[\"right\"] = new AST_Seq((function(){\n                                    var ρσ_d = Object.create(null);\n                                    ρσ_d[\"car\"] = expr.right;\n                                    ρσ_d[\"cdr\"] = expression(true, no_in);\n                                    return ρσ_d;\n                                }).call(this));\n                                ρσ_d[\"end\"] = peek();\n                                return ρσ_d;\n                            }).call(this));\n                        }\n                        expr = maybe_assign(no_in);\n                        left.push(expr);\n                    }\n                    if (left.length > 1 && is_node_type(left[left.length-1], AST_Assign)) {\n                        left[left.length-1] = left[left.length-1].left;\n                        return create_assign((function(){\n                            var ρσ_d = Object.create(null);\n                            ρσ_d[\"start\"] = start;\n                            ρσ_d[\"left\"] = new AST_Array((function(){\n                                var ρσ_d = Object.create(null);\n                                ρσ_d[\"elements\"] = left;\n                                return ρσ_d;\n                            }).call(this));\n                            ρσ_d[\"operator\"] = expr.operator;\n                            ρσ_d[\"right\"] = expr.right;\n                            ρσ_d[\"end\"] = peek();\n                            return ρσ_d;\n                        }).call(this));\n                    }\n                    return build_seq(left);\n                }\n                return expr;\n            };\n            if (!expression.__argnames__) Object.defineProperties(expression, {\n                __argnames__ : {value: [\"commas\", \"no_in\"]}\n            });\n\n            function in_loop(cont) {\n                var ret;\n                S.in_loop += 1;\n                ret = cont();\n                S.in_loop -= 1;\n                return ret;\n            };\n            if (!in_loop.__argnames__) Object.defineProperties(in_loop, {\n                __argnames__ : {value: [\"cont\"]}\n            });\n\n            function run_parser() {\n                var start, body, docstrings, first_token, toplevel, element, shebang, ds, end, seen_exports, item;\n                start = S.token = next();\n                body = [];\n                docstrings = [];\n                first_token = true;\n                toplevel = options.toplevel;\n                while (!is_(\"eof\")) {\n                    element = statement();\n                    if (first_token && is_node_type(element, AST_Directive) && element.value.indexOf(\"#!\") === 0) {\n                        shebang = element.value;\n                    } else {\n                        ds = !toplevel && is_docstring(element);\n                        if (ds) {\n                            docstrings.push(ds);\n                        } else {\n                            body.push(element);\n                        }\n                    }\n                    first_token = false;\n                }\n                end = prev();\n                if (toplevel) {\n                    toplevel.body = toplevel.body.concat(body);\n                    toplevel.end = end;\n                    toplevel.docstrings;\n                } else {\n                    toplevel = new AST_Toplevel((function(){\n                        var ρσ_d = Object.create(null);\n                        ρσ_d[\"start\"] = start;\n                        ρσ_d[\"body\"] = body;\n                        ρσ_d[\"shebang\"] = shebang;\n                        ρσ_d[\"end\"] = end;\n                        ρσ_d[\"docstrings\"] = docstrings;\n                        return ρσ_d;\n                    }).call(this));\n                }\n                toplevel.nonlocalvars = scan_for_nonlocal_defs(toplevel.body).concat(S.globals);\n                toplevel.localvars = ρσ_list_decorate([]);\n                toplevel.exports = ρσ_list_decorate([]);\n                seen_exports = Object.create(null);\n                function add_item(item, isvar) {\n                    var symbol;\n                    if (toplevel.nonlocalvars.indexOf(item) < 0) {\n                        symbol = new_symbol(AST_SymbolVar, item);\n                        if (isvar) {\n                            toplevel.localvars.push(symbol);\n                        }\n                        if (!has_prop(seen_exports, item)) {\n                            toplevel.exports.push(symbol);\n                            seen_exports[(typeof item === \"number\" && item < 0) ? seen_exports.length + item : item] = true;\n                        }\n                    }\n                };\n                if (!add_item.__argnames__) Object.defineProperties(add_item, {\n                    __argnames__ : {value: [\"item\", \"isvar\"]}\n                });\n\n                var ρσ_Iter70 = ρσ_Iterable(scan_for_local_vars(toplevel.body));\n                for (var ρσ_Index70 = 0; ρσ_Index70 < ρσ_Iter70.length; ρσ_Index70++) {\n                    item = ρσ_Iter70[ρσ_Index70];\n                    add_item(item, true);\n                }\n                var ρσ_Iter71 = ρσ_Iterable(scan_for_top_level_callables(toplevel.body));\n                for (var ρσ_Index71 = 0; ρσ_Index71 < ρσ_Iter71.length; ρσ_Index71++) {\n                    item = ρσ_Iter71[ρσ_Index71];\n                    add_item(item, false);\n                }\n                toplevel.filename = options.filename;\n                toplevel.imported_module_ids = imported_module_ids;\n                toplevel.classes = scan_for_classes(toplevel.body);\n                toplevel.import_order = Object.keys(imported_modules).length;\n                toplevel.module_id = module_id;\n                imported_modules[(typeof module_id === \"number\" && module_id < 0) ? imported_modules.length + module_id : module_id] = toplevel;\n                toplevel.imports = imported_modules;\n                toplevel.baselib = baselib_items;\n                toplevel.scoped_flags = S.scoped_flags.stack[0];\n                importing_modules[(typeof module_id === \"number\" && module_id < 0) ? importing_modules.length + module_id : module_id] = false;\n                return toplevel;\n            };\n\n            return run_parser;\n        };\n        if (!create_parser_ctx.__argnames__) Object.defineProperties(create_parser_ctx, {\n            __argnames__ : {value: [\"S\", \"import_dirs\", \"module_id\", \"baselib_items\", \"imported_module_ids\", \"imported_modules\", \"importing_modules\", \"options\"]}\n        });\n\n        function parse(text, options) {\n            var import_dirs, x, location, module_id, baselib_items, imported_module_ids, imported_modules, importing_modules, S, obj, cname;\n            options = defaults(options, (function(){\n                var ρσ_d = Object.create(null);\n                ρσ_d[\"filename\"] = null;\n                ρσ_d[\"module_id\"] = \"__main__\";\n                ρσ_d[\"toplevel\"] = null;\n                ρσ_d[\"for_linting\"] = false;\n                ρσ_d[\"import_dirs\"] = [];\n                ρσ_d[\"classes\"] = undefined;\n                ρσ_d[\"scoped_flags\"] = Object.create(null);\n                ρσ_d[\"discard_asserts\"] = false;\n                ρσ_d[\"module_cache_dir\"] = \"\";\n                return ρσ_d;\n            }).call(this));\n            import_dirs = (function() {\n                var ρσ_Iter = ρσ_Iterable(options.import_dirs), ρσ_Result = [], x;\n                for (var ρσ_Index = 0; ρσ_Index < ρσ_Iter.length; ρσ_Index++) {\n                    x = ρσ_Iter[ρσ_Index];\n                    ρσ_Result.push(x);\n                }\n                ρσ_Result = ρσ_list_constructor(ρσ_Result);\n                return ρσ_Result;\n            })();\n            var ρσ_Iter72 = ρσ_Iterable([options.libdir, options.basedir]);\n            for (var ρσ_Index72 = 0; ρσ_Index72 < ρσ_Iter72.length; ρσ_Index72++) {\n                location = ρσ_Iter72[ρσ_Index72];\n                if (location) {\n                    import_dirs.push(location);\n                }\n            }\n            module_id = options.module_id;\n            baselib_items = Object.create(null);\n            imported_module_ids = ρσ_list_decorate([]);\n            imported_modules = options.imported_modules || Object.create(null);\n            importing_modules = options.importing_modules || Object.create(null);\n            importing_modules[(typeof module_id === \"number\" && module_id < 0) ? importing_modules.length + module_id : module_id] = true;\n            S = (function(){\n                var ρσ_d = Object.create(null);\n                ρσ_d[\"input\"] = (typeof text === \"string\") ? tokenizer(text, options.filename) : text;\n                ρσ_d[\"token\"] = null;\n                ρσ_d[\"prev\"] = null;\n                ρσ_d[\"peeked\"] = ρσ_list_decorate([]);\n                ρσ_d[\"in_function\"] = 0;\n                ρσ_d[\"statement_starting_token\"] = null;\n                ρσ_d[\"in_comprehension\"] = false;\n                ρσ_d[\"in_parenthesized_expr\"] = false;\n                ρσ_d[\"in_delete\"] = false;\n                ρσ_d[\"in_loop\"] = 0;\n                ρσ_d[\"in_class\"] = ρσ_list_decorate([ false ]);\n                ρσ_d[\"classes\"] = ρσ_list_decorate([ Object.create(null) ]);\n                ρσ_d[\"functions\"] = ρσ_list_decorate([ Object.create(null) ]);\n                ρσ_d[\"labels\"] = ρσ_list_decorate([]);\n                ρσ_d[\"decorators\"] = [];\n                ρσ_d[\"parsing_decorator\"] = false;\n                ρσ_d[\"globals\"] = [];\n                ρσ_d[\"scoped_flags\"] = (function(){\n                    var ρσ_d = Object.create(null);\n                    ρσ_d[\"stack\"] = [options.scoped_flags || Object.create(null)];\n                    ρσ_d[\"push\"] = function () {\n                        this.stack.push(Object.create(null));\n                    };\n                    ρσ_d[\"pop\"] = function () {\n                        this.stack.pop();\n                    };\n                    ρσ_d[\"get\"] = (function() {\n                        var ρσ_anonfunc = function (name, defval) {\n                            var d, q;\n                            for (var i = this.stack.length - 1; i >= 0; i--) {\n                                d = (ρσ_expr_temp = this.stack)[(typeof i === \"number\" && i < 0) ? ρσ_expr_temp.length + i : i];\n                                q = d[(typeof name === \"number\" && name < 0) ? d.length + name : name];\n                                if (q) {\n                                    return q;\n                                }\n                            }\n                            return defval;\n                        };\n                        if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                            __argnames__ : {value: [\"name\", \"defval\"]}\n                        });\n                        return ρσ_anonfunc;\n                    })();\n                    ρσ_d[\"set\"] = (function() {\n                        var ρσ_anonfunc = function (name, val) {\n                            (ρσ_expr_temp = (ρσ_expr_temp = this.stack)[ρσ_expr_temp.length-1])[(typeof name === \"number\" && name < 0) ? ρσ_expr_temp.length + name : name] = val;\n                        };\n                        if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                            __argnames__ : {value: [\"name\", \"val\"]}\n                        });\n                        return ρσ_anonfunc;\n                    })();\n                    return ρσ_d;\n                }).call(this);\n                return ρσ_d;\n            }).call(this);\n            if (options.classes) {\n                var ρσ_Iter73 = ρσ_Iterable(options.classes);\n                for (var ρσ_Index73 = 0; ρσ_Index73 < ρσ_Iter73.length; ρσ_Index73++) {\n                    cname = ρσ_Iter73[ρσ_Index73];\n                    obj = (ρσ_expr_temp = options.classes)[(typeof cname === \"number\" && cname < 0) ? ρσ_expr_temp.length + cname : cname];\n                    (ρσ_expr_temp = S.classes[0])[(typeof cname === \"number\" && cname < 0) ? ρσ_expr_temp.length + cname : cname] = (function(){\n                        var ρσ_d = Object.create(null);\n                        ρσ_d[\"static\"] = obj.static;\n                        ρσ_d[\"bound\"] = obj.bound;\n                        ρσ_d[\"classvars\"] = obj.classvars;\n                        return ρσ_d;\n                    }).call(this);\n                }\n            }\n            return create_parser_ctx(S, import_dirs, module_id, baselib_items, imported_module_ids, imported_modules, importing_modules, options)();\n        };\n        if (!parse.__argnames__) Object.defineProperties(parse, {\n            __argnames__ : {value: [\"text\", \"options\"]}\n        });\n\n        ρσ_modules.parse.COMPILER_VERSION = COMPILER_VERSION;\n        ρσ_modules.parse.PYTHON_FLAGS = PYTHON_FLAGS;\n        ρσ_modules.parse.NATIVE_CLASSES = NATIVE_CLASSES;\n        ρσ_modules.parse.ERROR_CLASSES = ERROR_CLASSES;\n        ρσ_modules.parse.COMMON_STATIC = COMMON_STATIC;\n        ρσ_modules.parse.FORBIDDEN_CLASS_VARS = FORBIDDEN_CLASS_VARS;\n        ρσ_modules.parse.UNARY_PREFIX = UNARY_PREFIX;\n        ρσ_modules.parse.ASSIGNMENT = ASSIGNMENT;\n        ρσ_modules.parse.PRECEDENCE = PRECEDENCE;\n        ρσ_modules.parse.STATEMENTS_WITH_LABELS = STATEMENTS_WITH_LABELS;\n        ρσ_modules.parse.ATOMIC_START_TOKEN = ATOMIC_START_TOKEN;\n        ρσ_modules.parse.compile_time_decorators = compile_time_decorators;\n        ρσ_modules.parse.has_simple_decorator = has_simple_decorator;\n        ρσ_modules.parse.has_setter_decorator = has_setter_decorator;\n        ρσ_modules.parse.create_parser_ctx = create_parser_ctx;\n        ρσ_modules.parse.parse = parse;\n    })();\n\n    (function(){\n        var __name__ = \"output\";\n\n    })();\n\n    (function(){\n        var __name__ = \"output.stream\";\n        var DANGEROUS, require_semi_colon_chars;\n        var make_predicate = ρσ_modules.utils.make_predicate;\n        var defaults = ρσ_modules.utils.defaults;\n        var repeat_string = ρσ_modules.utils.repeat_string;\n\n        var is_identifier_char = ρσ_modules.tokenizer.is_identifier_char;\n\n        DANGEROUS = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g;\n        function to_ascii(str_, identifier) {\n            return str_.replace(/[\\u0080-\\uffff]/g, (function() {\n                var ρσ_anonfunc = function (ch) {\n                    var code;\n                    code = ch.charCodeAt(0).toString(16);\n                    if (code.length <= 2 && !identifier) {\n                        while (code.length < 2) {\n                            code = \"0\" + code;\n                        }\n                        return \"\\\\x\" + code;\n                    } else {\n                        while (code.length < 4) {\n                            code = \"0\" + code;\n                        }\n                        return \"\\\\u\" + code;\n                    }\n                };\n                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                    __argnames__ : {value: [\"ch\"]}\n                });\n                return ρσ_anonfunc;\n            })());\n        };\n        if (!to_ascii.__argnames__) Object.defineProperties(to_ascii, {\n            __argnames__ : {value: [\"str_\", \"identifier\"]}\n        });\n\n        function encode_string(str_) {\n            return JSON.stringify(str_).replace(DANGEROUS, (function() {\n                var ρσ_anonfunc = function (a) {\n                    return \"\\\\u\" + a.charCodeAt(0).toString(16);\n                };\n                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                    __argnames__ : {value: [\"a\"]}\n                });\n                return ρσ_anonfunc;\n            })());\n        };\n        if (!encode_string.__argnames__) Object.defineProperties(encode_string, {\n            __argnames__ : {value: [\"str_\"]}\n        });\n\n        require_semi_colon_chars = make_predicate(\"( [ + * / - , .\");\n        function OutputStream() {\n            if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n            OutputStream.prototype.__init__.apply(this, arguments);\n        }\n        OutputStream.prototype.__init__ = function __init__(options) {\n            var self = this;\n            self.options = defaults(options, (function(){\n                var ρσ_d = Object.create(null);\n                ρσ_d[\"indent_start\"] = 0;\n                ρσ_d[\"indent_level\"] = 4;\n                ρσ_d[\"quote_keys\"] = false;\n                ρσ_d[\"space_colon\"] = true;\n                ρσ_d[\"ascii_only\"] = false;\n                ρσ_d[\"width\"] = 80;\n                ρσ_d[\"max_line_len\"] = 32e3;\n                ρσ_d[\"ie_proof\"] = true;\n                ρσ_d[\"beautify\"] = false;\n                ρσ_d[\"source_map\"] = null;\n                ρσ_d[\"bracketize\"] = false;\n                ρσ_d[\"semicolons\"] = true;\n                ρσ_d[\"comments\"] = false;\n                ρσ_d[\"preserve_line\"] = false;\n                ρσ_d[\"omit_baselib\"] = false;\n                ρσ_d[\"baselib_plain\"] = null;\n                ρσ_d[\"private_scope\"] = true;\n                ρσ_d[\"keep_docstrings\"] = false;\n                ρσ_d[\"discard_asserts\"] = false;\n                ρσ_d[\"module_cache_dir\"] = \"\";\n                ρσ_d[\"js_version\"] = 5;\n                ρσ_d[\"write_name\"] = true;\n                return ρσ_d;\n            }).call(this), true);\n            self._indentation = 0;\n            self.current_col = 0;\n            self.current_line = 1;\n            self.current_pos = 0;\n            self.OUTPUT = \"\";\n            self.IMPORTED = Object.create(null);\n            self.might_need_space = false;\n            self.might_need_semicolon = false;\n            self._last = null;\n            self._stack = ρσ_list_decorate([]);\n            self.index_counter = 0;\n            self.with_counter = 0;\n        };\n        if (!OutputStream.prototype.__init__.__argnames__) Object.defineProperties(OutputStream.prototype.__init__, {\n            __argnames__ : {value: [\"options\"]}\n        });\n        OutputStream.__argnames__ = OutputStream.prototype.__init__.__argnames__;\n        OutputStream.__handles_kwarg_interpolation__ = OutputStream.prototype.__init__.__handles_kwarg_interpolation__;\n        OutputStream.prototype.make_name = function make_name(name) {\n            var self = this;\n            name = name.toString();\n            if (self.options.ascii_only) {\n                name = to_ascii(name, true);\n            }\n            return name;\n        };\n        if (!OutputStream.prototype.make_name.__argnames__) Object.defineProperties(OutputStream.prototype.make_name, {\n            __argnames__ : {value: [\"name\"]}\n        });\n        OutputStream.prototype.print_name = function print_name(name) {\n            var self = this;\n            self.print(self.make_name(name));\n        };\n        if (!OutputStream.prototype.print_name.__argnames__) Object.defineProperties(OutputStream.prototype.print_name, {\n            __argnames__ : {value: [\"name\"]}\n        });\n        OutputStream.prototype.make_indent = function make_indent(back) {\n            var self = this;\n            return repeat_string(\" \", self.options.indent_start + self._indentation - back * self.options.indent_level);\n        };\n        if (!OutputStream.prototype.make_indent.__argnames__) Object.defineProperties(OutputStream.prototype.make_indent, {\n            __argnames__ : {value: [\"back\"]}\n        });\n        OutputStream.prototype.last_char = function last_char() {\n            var self = this;\n            return self._last.charAt(self._last.length - 1);\n        };\n        if (!OutputStream.prototype.last_char.__argnames__) Object.defineProperties(OutputStream.prototype.last_char, {\n            __argnames__ : {value: []}\n        });\n        OutputStream.prototype.maybe_newline = function maybe_newline() {\n            var self = this;\n            if (self.options.max_line_len && self.current_col > self.options.max_line_len) {\n                self.print(\"\\n\");\n            }\n        };\n        if (!OutputStream.prototype.maybe_newline.__argnames__) Object.defineProperties(OutputStream.prototype.maybe_newline, {\n            __argnames__ : {value: []}\n        });\n        OutputStream.prototype.print = function print(str_) {\n            var self = this;\n            var ch, target_line, prev, a, n;\n            str_ = String(str_);\n            ch = str_.charAt(0);\n            if (self.might_need_semicolon) {\n                if ((!ch || \";}\".indexOf(ch) < 0) && !/[;]$/.test(self._last)) {\n                    if (self.options.semicolons || require_semi_colon_chars[(typeof ch === \"number\" && ch < 0) ? require_semi_colon_chars.length + ch : ch]) {\n                        self.OUTPUT += \";\";\n                        self.current_col += 1;\n                        self.current_pos += 1;\n                    } else {\n                        self.OUTPUT += \"\\n\";\n                        self.current_pos += 1;\n                        self.current_line += 1;\n                        self.current_col = 0;\n                    }\n                    if (!self.options.beautify) {\n                        self.might_need_space = false;\n                    }\n                }\n                self.might_need_semicolon = false;\n                self.maybe_newline();\n            }\n            if (!self.options.beautify && self.options.preserve_line && (ρσ_expr_temp = self._stack)[ρσ_bound_index(self._stack.length - 1, ρσ_expr_temp)]) {\n                target_line = (ρσ_expr_temp = self._stack)[ρσ_bound_index(self._stack.length - 1, ρσ_expr_temp)].start.line;\n                while (self.current_line < target_line) {\n                    self.OUTPUT += \"\\n\";\n                    self.current_pos += 1;\n                    self.current_line += 1;\n                    self.current_col = 0;\n                    self.might_need_space = false;\n                }\n            }\n            if (self.might_need_space) {\n                prev = self.last_char();\n                if (is_identifier_char(prev) && (is_identifier_char(ch) || ch === \"\\\\\") || /^[\\+\\-\\/]$/.test(ch) && ch === prev) {\n                    self.OUTPUT += \" \";\n                    self.current_col += 1;\n                    self.current_pos += 1;\n                }\n                self.might_need_space = false;\n            }\n            a = str_.split(/\\r?\\n/);\n            n = a.length - 1;\n            self.current_line += n;\n            if (n === 0) {\n                self.current_col += a[(typeof n === \"number\" && n < 0) ? a.length + n : n].length;\n            } else {\n                self.current_col = a[(typeof n === \"number\" && n < 0) ? a.length + n : n].length;\n            }\n            self.current_pos += str_.length;\n            self._last = str_;\n            self.OUTPUT += str_;\n        };\n        if (!OutputStream.prototype.print.__argnames__) Object.defineProperties(OutputStream.prototype.print, {\n            __argnames__ : {value: [\"str_\"]}\n        });\n        OutputStream.prototype.space = function space() {\n            var self = this;\n            if (self.options.beautify) {\n                self.print(\" \");\n            } else {\n                self.might_need_space = true;\n            }\n        };\n        if (!OutputStream.prototype.space.__argnames__) Object.defineProperties(OutputStream.prototype.space, {\n            __argnames__ : {value: []}\n        });\n        OutputStream.prototype.indent = function indent(half) {\n            var self = this;\n            if (self.options.beautify) {\n                self.print(self.make_indent((half) ? .5 : 0));\n            }\n        };\n        if (!OutputStream.prototype.indent.__argnames__) Object.defineProperties(OutputStream.prototype.indent, {\n            __argnames__ : {value: [\"half\"]}\n        });\n        OutputStream.prototype.with_indent = function with_indent(col, proceed) {\n            var self = this;\n            var save_indentation, ret;\n            if (self.options.beautify) {\n                if (col === true) {\n                    col = self.next_indent();\n                }\n                save_indentation = self._indentation;\n                self._indentation = col;\n                ret = proceed();\n                self._indentation = save_indentation;\n                return ret;\n            } else {\n                return proceed();\n            }\n        };\n        if (!OutputStream.prototype.with_indent.__argnames__) Object.defineProperties(OutputStream.prototype.with_indent, {\n            __argnames__ : {value: [\"col\", \"proceed\"]}\n        });\n        OutputStream.prototype.indentation = function indentation() {\n            var self = this;\n            return self._indentation;\n        };\n        if (!OutputStream.prototype.indentation.__argnames__) Object.defineProperties(OutputStream.prototype.indentation, {\n            __argnames__ : {value: []}\n        });\n        OutputStream.prototype.set_indentation = function set_indentation(val) {\n            var self = this;\n            if (self.options.beautify) {\n                self._indentation = val;\n            }\n        };\n        if (!OutputStream.prototype.set_indentation.__argnames__) Object.defineProperties(OutputStream.prototype.set_indentation, {\n            __argnames__ : {value: [\"val\"]}\n        });\n        OutputStream.prototype.newline = function newline() {\n            var self = this;\n            if (self.options.beautify) {\n                self.print(\"\\n\");\n            }\n        };\n        if (!OutputStream.prototype.newline.__argnames__) Object.defineProperties(OutputStream.prototype.newline, {\n            __argnames__ : {value: []}\n        });\n        OutputStream.prototype.semicolon = function semicolon() {\n            var self = this;\n            if (self.options.beautify) {\n                self.print(\";\");\n            } else {\n                self.might_need_semicolon = true;\n            }\n        };\n        if (!OutputStream.prototype.semicolon.__argnames__) Object.defineProperties(OutputStream.prototype.semicolon, {\n            __argnames__ : {value: []}\n        });\n        OutputStream.prototype.force_semicolon = function force_semicolon() {\n            var self = this;\n            self.might_need_semicolon = false;\n            self.print(\";\");\n        };\n        if (!OutputStream.prototype.force_semicolon.__argnames__) Object.defineProperties(OutputStream.prototype.force_semicolon, {\n            __argnames__ : {value: []}\n        });\n        OutputStream.prototype.next_indent = function next_indent() {\n            var self = this;\n            return self._indentation + self.options.indent_level;\n        };\n        if (!OutputStream.prototype.next_indent.__argnames__) Object.defineProperties(OutputStream.prototype.next_indent, {\n            __argnames__ : {value: []}\n        });\n        OutputStream.prototype.spaced = function spaced() {\n            var self = this;\n            for (var i=0; i < arguments.length; i++) {\n                if (i > 0) {\n                    self.space();\n                }\n                if (typeof arguments[(typeof i === \"number\" && i < 0) ? arguments.length + i : i].print === \"function\") {\n                    arguments[(typeof i === \"number\" && i < 0) ? arguments.length + i : i].print(self);\n                } else {\n                    self.print(arguments[(typeof i === \"number\" && i < 0) ? arguments.length + i : i]);\n                }\n            }\n        };\n        if (!OutputStream.prototype.spaced.__argnames__) Object.defineProperties(OutputStream.prototype.spaced, {\n            __argnames__ : {value: []}\n        });\n        OutputStream.prototype.end_statement = function end_statement() {\n            var self = this;\n            self.semicolon();\n            self.newline();\n        };\n        if (!OutputStream.prototype.end_statement.__argnames__) Object.defineProperties(OutputStream.prototype.end_statement, {\n            __argnames__ : {value: []}\n        });\n        OutputStream.prototype.with_block = function with_block(cont) {\n            var self = this;\n            var ret;\n            ret = null;\n            self.print(\"{\");\n            self.newline();\n            self.with_indent(self.next_indent(), function () {\n                ret = cont();\n            });\n            self.indent();\n            self.print(\"}\");\n            return ret;\n        };\n        if (!OutputStream.prototype.with_block.__argnames__) Object.defineProperties(OutputStream.prototype.with_block, {\n            __argnames__ : {value: [\"cont\"]}\n        });\n        OutputStream.prototype.with_parens = function with_parens(cont) {\n            var self = this;\n            var ret;\n            self.print(\"(\");\n            ret = cont();\n            self.print(\")\");\n            return ret;\n        };\n        if (!OutputStream.prototype.with_parens.__argnames__) Object.defineProperties(OutputStream.prototype.with_parens, {\n            __argnames__ : {value: [\"cont\"]}\n        });\n        OutputStream.prototype.with_square = function with_square(cont) {\n            var self = this;\n            var ret;\n            self.print(\"[\");\n            ret = cont();\n            self.print(\"]\");\n            return ret;\n        };\n        if (!OutputStream.prototype.with_square.__argnames__) Object.defineProperties(OutputStream.prototype.with_square, {\n            __argnames__ : {value: [\"cont\"]}\n        });\n        OutputStream.prototype.comma = function comma() {\n            var self = this;\n            self.print(\",\");\n            self.space();\n        };\n        if (!OutputStream.prototype.comma.__argnames__) Object.defineProperties(OutputStream.prototype.comma, {\n            __argnames__ : {value: []}\n        });\n        OutputStream.prototype.colon = function colon() {\n            var self = this;\n            self.print(\":\");\n            if (self.options.space_colon) {\n                self.space();\n            }\n        };\n        if (!OutputStream.prototype.colon.__argnames__) Object.defineProperties(OutputStream.prototype.colon, {\n            __argnames__ : {value: []}\n        });\n        OutputStream.prototype.dump_yield = function dump_yield() {\n            var self = this;\n            var code, ci;\n            self.indent();\n            self.spaced(\"var\", \"ρσ_regenerator\", \"=\", \"{}\");\n            self.end_statement();\n            code = regenerate(false, self.options.beautify);\n            if (self.options.beautify) {\n                code = code.replace(/\\/\\/.*$/gm, \"\\n\").replace(/^\\s*$/gm, \"\");\n                ci = self.make_indent(0);\n                code = (function() {\n                    var ρσ_Iter = ρσ_Iterable(code.split(\"\\n\")), ρσ_Result = [], x;\n                    for (var ρσ_Index = 0; ρσ_Index < ρσ_Iter.length; ρσ_Index++) {\n                        x = ρσ_Iter[ρσ_Index];\n                        ρσ_Result.push(ci + x);\n                    }\n                    ρσ_Result = ρσ_list_constructor(ρσ_Result);\n                    return ρσ_Result;\n                })().join(\"\\n\");\n            }\n            self.print(code + \"(ρσ_regenerator)\");\n            self.end_statement();\n        };\n        if (!OutputStream.prototype.dump_yield.__argnames__) Object.defineProperties(OutputStream.prototype.dump_yield, {\n            __argnames__ : {value: []}\n        });\n        OutputStream.prototype.get = function get() {\n            var self = this;\n            return self.OUTPUT;\n        };\n        if (!OutputStream.prototype.get.__argnames__) Object.defineProperties(OutputStream.prototype.get, {\n            __argnames__ : {value: []}\n        });\n        OutputStream.prototype.toString = function toString() {\n            var self = this;\n            return self.OUTPUT;\n        };\n        if (!OutputStream.prototype.toString.__argnames__) Object.defineProperties(OutputStream.prototype.toString, {\n            __argnames__ : {value: []}\n        });\n        OutputStream.prototype.assign = function assign(name) {\n            var self = this;\n            if (typeof name === \"string\") {\n                self.print(name);\n            } else {\n                name.print(self);\n            }\n            self.space();\n            self.print(\"=\");\n            self.space();\n        };\n        if (!OutputStream.prototype.assign.__argnames__) Object.defineProperties(OutputStream.prototype.assign, {\n            __argnames__ : {value: [\"name\"]}\n        });\n        OutputStream.prototype.current_width = function current_width() {\n            var self = this;\n            return self.current_col - self._indentation;\n        };\n        if (!OutputStream.prototype.current_width.__argnames__) Object.defineProperties(OutputStream.prototype.current_width, {\n            __argnames__ : {value: []}\n        });\n        OutputStream.prototype.should_break = function should_break() {\n            var self = this;\n            return self.options.width && self.current_width() >= self.options.width;\n        };\n        if (!OutputStream.prototype.should_break.__argnames__) Object.defineProperties(OutputStream.prototype.should_break, {\n            __argnames__ : {value: []}\n        });\n        OutputStream.prototype.last = function last() {\n            var self = this;\n            return self._last;\n        };\n        if (!OutputStream.prototype.last.__argnames__) Object.defineProperties(OutputStream.prototype.last, {\n            __argnames__ : {value: []}\n        });\n        OutputStream.prototype.print_string = function print_string(str_) {\n            var self = this;\n            self.print(encode_string(str_));\n        };\n        if (!OutputStream.prototype.print_string.__argnames__) Object.defineProperties(OutputStream.prototype.print_string, {\n            __argnames__ : {value: [\"str_\"]}\n        });\n        OutputStream.prototype.import_ = function import_(module) {\n            var self = this;\n            if (!Object.prototype.hasOwnProperty.call(self.IMPORTED, module.key)) {\n                (ρσ_expr_temp = self.IMPORTED)[ρσ_bound_index(module.key, ρσ_expr_temp)] = module;\n            }\n        };\n        if (!OutputStream.prototype.import_.__argnames__) Object.defineProperties(OutputStream.prototype.import_, {\n            __argnames__ : {value: [\"module\"]}\n        });\n        OutputStream.prototype.is_main = function is_main() {\n            var self = this;\n            return self.OUTPUT.length === 0;\n        };\n        if (!OutputStream.prototype.is_main.__argnames__) Object.defineProperties(OutputStream.prototype.is_main, {\n            __argnames__ : {value: []}\n        });\n        OutputStream.prototype.option = function option(opt) {\n            var self = this;\n            return (ρσ_expr_temp = self.options)[(typeof opt === \"number\" && opt < 0) ? ρσ_expr_temp.length + opt : opt];\n        };\n        if (!OutputStream.prototype.option.__argnames__) Object.defineProperties(OutputStream.prototype.option, {\n            __argnames__ : {value: [\"opt\"]}\n        });\n        OutputStream.prototype.line = function line() {\n            var self = this;\n            return self.current_line;\n        };\n        if (!OutputStream.prototype.line.__argnames__) Object.defineProperties(OutputStream.prototype.line, {\n            __argnames__ : {value: []}\n        });\n        OutputStream.prototype.col = function col() {\n            var self = this;\n            return self.current_col;\n        };\n        if (!OutputStream.prototype.col.__argnames__) Object.defineProperties(OutputStream.prototype.col, {\n            __argnames__ : {value: []}\n        });\n        OutputStream.prototype.pos = function pos() {\n            var self = this;\n            return self.current_pos;\n        };\n        if (!OutputStream.prototype.pos.__argnames__) Object.defineProperties(OutputStream.prototype.pos, {\n            __argnames__ : {value: []}\n        });\n        OutputStream.prototype.push_node = function push_node(node) {\n            var self = this;\n            self._stack.push(node);\n        };\n        if (!OutputStream.prototype.push_node.__argnames__) Object.defineProperties(OutputStream.prototype.push_node, {\n            __argnames__ : {value: [\"node\"]}\n        });\n        OutputStream.prototype.pop_node = function pop_node() {\n            var self = this;\n            return self._stack.pop();\n        };\n        if (!OutputStream.prototype.pop_node.__argnames__) Object.defineProperties(OutputStream.prototype.pop_node, {\n            __argnames__ : {value: []}\n        });\n        OutputStream.prototype.stack = function stack() {\n            var self = this;\n            return self._stack;\n        };\n        if (!OutputStream.prototype.stack.__argnames__) Object.defineProperties(OutputStream.prototype.stack, {\n            __argnames__ : {value: []}\n        });\n        OutputStream.prototype.parent = function parent(n) {\n            var self = this;\n            return (ρσ_expr_temp = self._stack)[ρσ_bound_index(self._stack.length - 2 - (n || 0), ρσ_expr_temp)];\n        };\n        if (!OutputStream.prototype.parent.__argnames__) Object.defineProperties(OutputStream.prototype.parent, {\n            __argnames__ : {value: [\"n\"]}\n        });\n        OutputStream.prototype.__repr__ = function __repr__ () {\n                        return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n        };\n        OutputStream.prototype.__str__ = function __str__ () {\n            return this.__repr__();\n        };\n        Object.defineProperty(OutputStream.prototype, \"__bases__\", {value: []});\n\n        ρσ_modules[\"output.stream\"].DANGEROUS = DANGEROUS;\n        ρσ_modules[\"output.stream\"].require_semi_colon_chars = require_semi_colon_chars;\n        ρσ_modules[\"output.stream\"].to_ascii = to_ascii;\n        ρσ_modules[\"output.stream\"].encode_string = encode_string;\n        ρσ_modules[\"output.stream\"].OutputStream = OutputStream;\n    })();\n\n    (function(){\n        var __name__ = \"output.statements\";\n        var AST_Definitions = ρσ_modules.ast.AST_Definitions;\n        var AST_Scope = ρσ_modules.ast.AST_Scope;\n        var AST_Method = ρσ_modules.ast.AST_Method;\n        var AST_Except = ρσ_modules.ast.AST_Except;\n        var AST_EmptyStatement = ρσ_modules.ast.AST_EmptyStatement;\n        var AST_Statement = ρσ_modules.ast.AST_Statement;\n        var AST_Seq = ρσ_modules.ast.AST_Seq;\n        var AST_BaseCall = ρσ_modules.ast.AST_BaseCall;\n        var AST_Dot = ρσ_modules.ast.AST_Dot;\n        var AST_Sub = ρσ_modules.ast.AST_Sub;\n        var AST_ItemAccess = ρσ_modules.ast.AST_ItemAccess;\n        var AST_Conditional = ρσ_modules.ast.AST_Conditional;\n        var AST_Binary = ρσ_modules.ast.AST_Binary;\n        var AST_BlockStatement = ρσ_modules.ast.AST_BlockStatement;\n        var is_node_type = ρσ_modules.ast.is_node_type;\n\n        function force_statement(stat, output) {\n            if (output.option(\"bracketize\")) {\n                if (!stat || is_node_type(stat, AST_EmptyStatement)) {\n                    output.print(\"{}\");\n                } else if (is_node_type(stat, AST_BlockStatement)) {\n                    stat.print(output);\n                } else {\n                    output.with_block(function () {\n                        output.indent();\n                        stat.print(output);\n                        output.newline();\n                    });\n                }\n            } else {\n                if (!stat || is_node_type(stat, AST_EmptyStatement)) {\n                    output.force_semicolon();\n                } else {\n                    stat.print(output);\n                }\n            }\n        };\n        if (!force_statement.__argnames__) Object.defineProperties(force_statement, {\n            __argnames__ : {value: [\"stat\", \"output\"]}\n        });\n\n        function first_in_statement(output) {\n            var a, i, node, p;\n            a = output.stack();\n            i = a.length;\n            node = a[ρσ_bound_index(i -= 1, a)];\n            p = a[ρσ_bound_index(i -= 1, a)];\n            while (i > 0) {\n                if (is_node_type(p, AST_Statement) && p.body === node) {\n                    return true;\n                }\n                if (is_node_type(p, AST_Seq) && p.car === node || is_node_type(p, AST_BaseCall) && p.expression === node || is_node_type(p, AST_Dot) && p.expression === node || is_node_type(p, AST_Sub) && p.expression === node || is_node_type(p, AST_ItemAccess) && p.expression === node || is_node_type(p, AST_Conditional) && p.condition === node || is_node_type(p, AST_Binary) && p.left === node) {\n                    node = p;\n                    p = a[ρσ_bound_index(i -= 1, a)];\n                } else {\n                    return false;\n                }\n            }\n        };\n        if (!first_in_statement.__argnames__) Object.defineProperties(first_in_statement, {\n            __argnames__ : {value: [\"output\"]}\n        });\n\n        function declare_vars(vars, output) {\n            var ρσ_unpack, i, arg;\n            if (vars.length) {\n                output.indent();\n                output.print(\"var\");\n                output.space();\n                var ρσ_Iter74 = ρσ_Iterable(enumerate(vars));\n                for (var ρσ_Index74 = 0; ρσ_Index74 < ρσ_Iter74.length; ρσ_Index74++) {\n                    ρσ_unpack = ρσ_Iter74[ρσ_Index74];\n                    i = ρσ_unpack[0];\n                    arg = ρσ_unpack[1];\n                    if (i) {\n                        output.comma();\n                    }\n                    arg.print(output);\n                }\n                output.semicolon();\n                output.newline();\n            }\n        };\n        if (!declare_vars.__argnames__) Object.defineProperties(declare_vars, {\n            __argnames__ : {value: [\"vars\", \"output\"]}\n        });\n\n        function display_body(body, is_toplevel, output) {\n            var last, ρσ_unpack, i, stmt;\n            last = body.length - 1;\n            var ρσ_Iter75 = ρσ_Iterable(enumerate(body));\n            for (var ρσ_Index75 = 0; ρσ_Index75 < ρσ_Iter75.length; ρσ_Index75++) {\n                ρσ_unpack = ρσ_Iter75[ρσ_Index75];\n                i = ρσ_unpack[0];\n                stmt = ρσ_unpack[1];\n                if (!is_node_type(stmt, AST_EmptyStatement) && !is_node_type(stmt, AST_Definitions)) {\n                    output.indent();\n                    stmt.print(output);\n                    if (!(i === last && is_toplevel)) {\n                        output.newline();\n                    }\n                }\n            }\n        };\n        if (!display_body.__argnames__) Object.defineProperties(display_body, {\n            __argnames__ : {value: [\"body\", \"is_toplevel\", \"output\"]}\n        });\n\n        function display_complex_body(node, is_toplevel, output, function_preamble) {\n            var offset;\n            offset = 0;\n            if (is_node_type(node, AST_Method) && !node.static) {\n                output.indent();\n                output.print(\"var\");\n                output.space();\n                output.assign(node.argnames[0]);\n                output.print(\"this\");\n                output.semicolon();\n                output.newline();\n                offset += 1;\n            }\n            if (is_node_type(node, AST_Scope)) {\n                function_preamble(node, output, offset);\n                declare_vars(node.localvars, output);\n            } else if (is_node_type(node, AST_Except)) {\n                if (node.argname) {\n                    output.indent();\n                    output.print(\"var\");\n                    output.space();\n                    output.assign(node.argname);\n                    output.print(\"ρσ_Exception\");\n                    output.semicolon();\n                    output.newline();\n                }\n            }\n            display_body(node.body, is_toplevel, output);\n        };\n        if (!display_complex_body.__argnames__) Object.defineProperties(display_complex_body, {\n            __argnames__ : {value: [\"node\", \"is_toplevel\", \"output\", \"function_preamble\"]}\n        });\n\n        function print_bracketed(node, output, complex, function_preamble) {\n            if (node.body.length > 0) {\n                output.with_block(function () {\n                    if (complex) {\n                        display_complex_body(node, false, output, function_preamble);\n                    } else {\n                        display_body(node.body, false, output, function_preamble);\n                    }\n                });\n            } else {\n                output.print(\"{}\");\n            }\n        };\n        if (!print_bracketed.__argnames__) Object.defineProperties(print_bracketed, {\n            __argnames__ : {value: [\"node\", \"output\", \"complex\", \"function_preamble\"]}\n        });\n\n        function print_with(self, output) {\n            var exits, clause_name, clause;\n            exits = [];\n            [output.assign(\"ρσ_with_exception\"), output.print(\"undefined\"), output.end_statement()];\n            var ρσ_Iter76 = ρσ_Iterable(self.clauses);\n            for (var ρσ_Index76 = 0; ρσ_Index76 < ρσ_Iter76.length; ρσ_Index76++) {\n                clause = ρσ_Iter76[ρσ_Index76];\n                output.with_counter += 1;\n                clause_name = \"ρσ_with_clause_\" + output.with_counter;\n                exits.push(clause_name);\n                [output.indent(), output.print(\"var \"), output.assign(clause_name)];\n                clause.expression.print(output);\n                output.end_statement();\n                output.indent();\n                if (clause.alias) {\n                    output.assign(clause.alias.name);\n                }\n                output.print(clause_name + \".__enter__()\");\n                output.end_statement();\n            }\n            [output.indent(), output.print(\"try\"), output.space()];\n            output.with_block(function () {\n                output.indent();\n                self._do_print_body(output);\n                output.newline();\n            });\n            [output.space(), output.print(\"catch(e)\")];\n            output.with_block(function () {\n                [output.indent(), output.assign(\"ρσ_with_exception\"), output.print(\"e\"), output.end_statement()];\n            });\n            [output.newline(), output.indent(), output.spaced(\"if\", \"(ρσ_with_exception\", \"===\", \"undefined)\")];\n            output.with_block(function () {\n                var clause;\n                var ρσ_Iter77 = ρσ_Iterable(exits);\n                for (var ρσ_Index77 = 0; ρσ_Index77 < ρσ_Iter77.length; ρσ_Index77++) {\n                    clause = ρσ_Iter77[ρσ_Index77];\n                    [output.indent(), output.print(clause + \".__exit__()\"), output.end_statement()];\n                }\n            });\n            [output.space(), output.print(\"else\"), output.space()];\n            output.with_block(function () {\n                var clause;\n                [output.indent(), output.assign(\"ρσ_with_suppress\"), output.print(\"false\"), output.end_statement()];\n                var ρσ_Iter78 = ρσ_Iterable(exits);\n                for (var ρσ_Index78 = 0; ρσ_Index78 < ρσ_Iter78.length; ρσ_Index78++) {\n                    clause = ρσ_Iter78[ρσ_Index78];\n                    output.indent();\n                    output.spaced(\"ρσ_with_suppress\", \"|=\", \"ρσ_bool(\" + clause + \".__exit__(ρσ_with_exception.constructor,\", \"ρσ_with_exception,\", \"ρσ_with_exception.stack))\");\n                    output.end_statement();\n                }\n                [output.indent(), output.spaced(\"if\", \"(!ρσ_with_suppress)\", \"throw ρσ_with_exception\"), \n                output.end_statement()];\n            });\n        };\n        if (!print_with.__argnames__) Object.defineProperties(print_with, {\n            __argnames__ : {value: [\"self\", \"output\"]}\n        });\n\n        function print_assert(self, output) {\n            if (output.options.discard_asserts) {\n                return;\n            }\n            [output.spaced(\"if\", \"(!\"), self.condition.print(output), output.spaced(\")\", \"throw new AssertionError\")];\n            if (self.message) {\n                output.print(\"(\");\n                self.message.print(output);\n                output.print(\")\");\n            }\n            output.end_statement();\n        };\n        if (!print_assert.__argnames__) Object.defineProperties(print_assert, {\n            __argnames__ : {value: [\"self\", \"output\"]}\n        });\n\n        ρσ_modules[\"output.statements\"].force_statement = force_statement;\n        ρσ_modules[\"output.statements\"].first_in_statement = first_in_statement;\n        ρσ_modules[\"output.statements\"].declare_vars = declare_vars;\n        ρσ_modules[\"output.statements\"].display_body = display_body;\n        ρσ_modules[\"output.statements\"].display_complex_body = display_complex_body;\n        ρσ_modules[\"output.statements\"].print_bracketed = print_bracketed;\n        ρσ_modules[\"output.statements\"].print_with = print_with;\n        ρσ_modules[\"output.statements\"].print_assert = print_assert;\n    })();\n\n    (function(){\n        var __name__ = \"output.exceptions\";\n        var print_bracketed = ρσ_modules[\"output.statements\"].print_bracketed;\n\n        function print_try(self, output) {\n            output.print(\"try\");\n            output.space();\n            print_bracketed(self, output);\n            if (self.bcatch) {\n                output.space();\n                self.bcatch.print(output);\n            }\n            if (self.bfinally) {\n                output.space();\n                self.bfinally.print(output);\n            }\n        };\n        if (!print_try.__argnames__) Object.defineProperties(print_try, {\n            __argnames__ : {value: [\"self\", \"output\"]}\n        });\n\n        function print_catch(self, output) {\n            output.print(\"catch\");\n            output.space();\n            output.with_parens(function () {\n                output.print(\"ρσ_Exception\");\n            });\n            output.space();\n            output.with_block(function () {\n                var no_default, ρσ_unpack, i, exception;\n                output.indent();\n                [output.spaced(\"ρσ_last_exception\", \"=\", \"ρσ_Exception\"), output.end_statement()];\n                output.indent();\n                no_default = true;\n                var ρσ_Iter79 = ρσ_Iterable(enumerate(self.body));\n                for (var ρσ_Index79 = 0; ρσ_Index79 < ρσ_Iter79.length; ρσ_Index79++) {\n                    ρσ_unpack = ρσ_Iter79[ρσ_Index79];\n                    i = ρσ_unpack[0];\n                    exception = ρσ_unpack[1];\n                    if (i) {\n                        output.print(\"else \");\n                    }\n                    if (exception.errors.length) {\n                        output.print(\"if\");\n                        output.space();\n                        output.with_parens(function () {\n                            var ρσ_unpack, i, err;\n                            var ρσ_Iter80 = ρσ_Iterable(enumerate(exception.errors));\n                            for (var ρσ_Index80 = 0; ρσ_Index80 < ρσ_Iter80.length; ρσ_Index80++) {\n                                ρσ_unpack = ρσ_Iter80[ρσ_Index80];\n                                i = ρσ_unpack[0];\n                                err = ρσ_unpack[1];\n                                if (i) {\n                                    output.newline();\n                                    output.indent();\n                                    output.print(\"||\");\n                                    output.space();\n                                }\n                                output.print(\"ρσ_Exception\");\n                                output.space();\n                                output.print(\"instanceof\");\n                                output.space();\n                                if (err.name === \"Exception\") {\n                                    output.print(\"Error\");\n                                } else {\n                                    err.print(output);\n                                }\n                            }\n                        });\n                        output.space();\n                    } else {\n                        no_default = false;\n                    }\n                    print_bracketed(exception, output, true);\n                    output.space();\n                }\n                if (no_default) {\n                    output.print(\"else\");\n                    output.space();\n                    output.with_block(function () {\n                        output.indent();\n                        output.print(\"throw\");\n                        output.space();\n                        output.print(\"ρσ_Exception\");\n                        output.semicolon();\n                        output.newline();\n                    });\n                }\n                output.newline();\n            });\n        };\n        if (!print_catch.__argnames__) Object.defineProperties(print_catch, {\n            __argnames__ : {value: [\"self\", \"output\"]}\n        });\n\n        function print_finally(self, output) {\n            output.print(\"finally\");\n            output.space();\n            print_bracketed(self, output);\n        };\n        if (!print_finally.__argnames__) Object.defineProperties(print_finally, {\n            __argnames__ : {value: [\"self\", \"output\"]}\n        });\n\n        ρσ_modules[\"output.exceptions\"].print_try = print_try;\n        ρσ_modules[\"output.exceptions\"].print_catch = print_catch;\n        ρσ_modules[\"output.exceptions\"].print_finally = print_finally;\n    })();\n\n    (function(){\n        var __name__ = \"output.utils\";\n        var AST_BlockStatement = ρσ_modules.ast.AST_BlockStatement;\n        var is_node_type = ρσ_modules.ast.is_node_type;\n\n        function best_of(a) {\n            var best, len_, i;\n            best = a[0];\n            len_ = best.length;\n            for (var ρσ_Index81 = 1; ρσ_Index81 < a.length; ρσ_Index81++) {\n                i = ρσ_Index81;\n                if (a[(typeof i === \"number\" && i < 0) ? a.length + i : i].length < len_) {\n                    best = a[(typeof i === \"number\" && i < 0) ? a.length + i : i];\n                    len_ = best.length;\n                }\n            }\n            return best;\n        };\n        if (!best_of.__argnames__) Object.defineProperties(best_of, {\n            __argnames__ : {value: [\"a\"]}\n        });\n\n        function make_num(num) {\n            var str_, a, m;\n            str_ = num.toString(10);\n            a = ρσ_list_decorate([ str_.replace(/^0\\./, \".\").replace(\"e+\", \"e\") ]);\n            m = null;\n            if (Math.floor(num) === num) {\n                if (num >= 0) {\n                    a.push(\"0x\" + num.toString(16).toLowerCase(), \"0\" + num.toString(8));\n                } else {\n                    a.push(\"-0x\" + (-num).toString(16).toLowerCase(), \"-0\" + (-num).toString(8));\n                }\n                if (m = /^(.*?)(0+)$/.exec(num)) {\n                    a.push(m[1] + \"e\" + m[2].length);\n                }\n            } else if (m = /^0?\\.(0+)(.*)$/.exec(num)) {\n                a.push(m[2] + \"e-\" + (m[1].length + m[2].length), str_.substr(str_.indexOf(\".\")));\n            }\n            return best_of(a);\n        };\n        if (!make_num.__argnames__) Object.defineProperties(make_num, {\n            __argnames__ : {value: [\"num\"]}\n        });\n\n        function make_block(stmt, output) {\n            if (is_node_type(stmt, AST_BlockStatement)) {\n                stmt.print(output);\n                return;\n            }\n            output.with_block(function () {\n                output.indent();\n                stmt.print(output);\n                output.newline();\n            });\n        };\n        if (!make_block.__argnames__) Object.defineProperties(make_block, {\n            __argnames__ : {value: [\"stmt\", \"output\"]}\n        });\n\n        function create_doctring(docstrings) {\n            var ans, ds, lines, min_leading_whitespace, r, leading_whitespace, line, lw, ρσ_unpack, l;\n            ans = [];\n            var ρσ_Iter82 = ρσ_Iterable(docstrings);\n            for (var ρσ_Index82 = 0; ρσ_Index82 < ρσ_Iter82.length; ρσ_Index82++) {\n                ds = ρσ_Iter82[ρσ_Index82];\n                ds = str.rstrip(ds.value);\n                lines = [];\n                min_leading_whitespace = \"\";\n                var ρσ_Iter83 = ρσ_Iterable(ds.split(/$/gm));\n                for (var ρσ_Index83 = 0; ρσ_Index83 < ρσ_Iter83.length; ρσ_Index83++) {\n                    line = ρσ_Iter83[ρσ_Index83];\n                    r = /^\\s+/.exec(line);\n                    leading_whitespace = \"\";\n                    if (r) {\n                        leading_whitespace = (r) ? r[0].replace(/[\\n\\r]/g, \"\") : \"\";\n                        line = line.slice(r[0].length);\n                    }\n                    if (!str.strip(line)) {\n                        lines.push([\"\", \"\"]);\n                    } else {\n                        leading_whitespace = leading_whitespace.replace(/\\t/g, \"    \");\n                        if (leading_whitespace && (!min_leading_whitespace || leading_whitespace.length < min_leading_whitespace.length)) {\n                            min_leading_whitespace = leading_whitespace;\n                        }\n                        lines.push([leading_whitespace, line]);\n                    }\n                }\n                var ρσ_Iter84 = ρσ_Iterable(lines);\n                for (var ρσ_Index84 = 0; ρσ_Index84 < ρσ_Iter84.length; ρσ_Index84++) {\n                    ρσ_unpack = ρσ_Iter84[ρσ_Index84];\n                    lw = ρσ_unpack[0];\n                    l = ρσ_unpack[1];\n                    if (min_leading_whitespace) {\n                        lw = lw.slice(min_leading_whitespace.length);\n                    }\n                    ans.push(lw + l);\n                }\n                ans.push(\"\");\n            }\n            return str.rstrip(ans.join(\"\\n\"));\n        };\n        if (!create_doctring.__argnames__) Object.defineProperties(create_doctring, {\n            __argnames__ : {value: [\"docstrings\"]}\n        });\n\n        ρσ_modules[\"output.utils\"].best_of = best_of;\n        ρσ_modules[\"output.utils\"].make_num = make_num;\n        ρσ_modules[\"output.utils\"].make_block = make_block;\n        ρσ_modules[\"output.utils\"].create_doctring = create_doctring;\n    })();\n\n    (function(){\n        var __name__ = \"output.loops\";\n        var AST_BaseCall = ρσ_modules.ast.AST_BaseCall;\n        var AST_SymbolRef = ρσ_modules.ast.AST_SymbolRef;\n        var AST_Array = ρσ_modules.ast.AST_Array;\n        var AST_Unary = ρσ_modules.ast.AST_Unary;\n        var AST_Number = ρσ_modules.ast.AST_Number;\n        var has_calls = ρσ_modules.ast.has_calls;\n        var AST_Seq = ρσ_modules.ast.AST_Seq;\n        var AST_ListComprehension = ρσ_modules.ast.AST_ListComprehension;\n        var is_node_type = ρσ_modules.ast.is_node_type;\n\n        var OutputStream = ρσ_modules[\"output.stream\"].OutputStream;\n\n        function unpack_tuple(elems, output, in_statement) {\n            var ρσ_unpack, i, elem;\n            var ρσ_Iter85 = ρσ_Iterable(enumerate(elems));\n            for (var ρσ_Index85 = 0; ρσ_Index85 < ρσ_Iter85.length; ρσ_Index85++) {\n                ρσ_unpack = ρσ_Iter85[ρσ_Index85];\n                i = ρσ_unpack[0];\n                elem = ρσ_unpack[1];\n                output.indent();\n                output.assign(elem);\n                output.print(\"ρσ_unpack\");\n                output.with_square(function () {\n                    output.print(i);\n                });\n                if (!in_statement || i < elems.length - 1) {\n                    output.semicolon();\n                    output.newline();\n                }\n            }\n        };\n        if (!unpack_tuple.__argnames__) Object.defineProperties(unpack_tuple, {\n            __argnames__ : {value: [\"elems\", \"output\", \"in_statement\"]}\n        });\n\n        function print_do_loop(self, output) {\n            output.print(\"do\");\n            output.space();\n            self._do_print_body(output);\n            output.space();\n            output.print(\"while\");\n            output.space();\n            output.with_parens(function () {\n                self.condition.print(output);\n            });\n            output.semicolon();\n        };\n        if (!print_do_loop.__argnames__) Object.defineProperties(print_do_loop, {\n            __argnames__ : {value: [\"self\", \"output\"]}\n        });\n\n        function print_while_loop(self, output) {\n            output.print(\"while\");\n            output.space();\n            output.with_parens(function () {\n                self.condition.print(output);\n            });\n            output.space();\n            self._do_print_body(output);\n        };\n        if (!print_while_loop.__argnames__) Object.defineProperties(print_while_loop, {\n            __argnames__ : {value: [\"self\", \"output\"]}\n        });\n\n        function is_simple_for_in(self) {\n            if (is_node_type(self.object, AST_BaseCall) && is_node_type(self.object.expression, AST_SymbolRef) && self.object.expression.name === \"dir\" && self.object.args.length === 1) {\n                return true;\n            }\n            return false;\n        };\n        if (!is_simple_for_in.__argnames__) Object.defineProperties(is_simple_for_in, {\n            __argnames__ : {value: [\"self\"]}\n        });\n\n        function is_simple_for(self) {\n            var a, l;\n            if (is_node_type(self.object, AST_BaseCall) && is_node_type(self.object.expression, AST_SymbolRef) && self.object.expression.name === \"range\" && !is_node_type(self.init, AST_Array)) {\n                a = self.object.args;\n                l = a.length;\n                if (l < 3 || is_node_type(a[2], AST_Number) || is_node_type(a[2], AST_Unary) && a[2].operator === \"-\" && is_node_type(a[2].expression, AST_Number)) {\n                    if (l === 1 && !has_calls(a[0]) || l > 1 && !has_calls(a[1])) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        };\n        if (!is_simple_for.__argnames__) Object.defineProperties(is_simple_for, {\n            __argnames__ : {value: [\"self\"]}\n        });\n\n        function print_for_loop_body(output) {\n            var self;\n            self = this;\n            output.with_block(function () {\n                var itervar, flat, stmt;\n                if (!(self.simple_for_index || is_simple_for_in(self))) {\n                    output.indent();\n                    if (output.option(\"js_version\") === 5) {\n                        itervar = \"ρσ_Iter\" + output.index_counter + \"[ρσ_Index\" + output.index_counter + \"]\";\n                    } else {\n                        itervar = \"ρσ_Index\" + output.index_counter;\n                    }\n                    if (is_node_type(self.init, AST_Array)) {\n                        flat = self.init.flatten();\n                        output.assign(\"ρσ_unpack\");\n                        if (flat.length > self.init.elements.length) {\n                            output.print(\"ρσ_flatten(\" + itervar + \")\");\n                        } else {\n                            output.print(itervar);\n                        }\n                        output.end_statement();\n                        unpack_tuple(flat, output);\n                    } else {\n                        output.assign(self.init);\n                        output.print(itervar);\n                        output.end_statement();\n                    }\n                    output.index_counter += 1;\n                }\n                if (self.simple_for_index) {\n                    output.indent();\n                    output.assign(self.init);\n                    output.print(self.simple_for_index);\n                    output.end_statement();\n                }\n                var ρσ_Iter86 = ρσ_Iterable(self.body.body);\n                for (var ρσ_Index86 = 0; ρσ_Index86 < ρσ_Iter86.length; ρσ_Index86++) {\n                    stmt = ρσ_Iter86[ρσ_Index86];\n                    output.indent();\n                    stmt.print(output);\n                    output.newline();\n                }\n            });\n        };\n        if (!print_for_loop_body.__argnames__) Object.defineProperties(print_for_loop_body, {\n            __argnames__ : {value: [\"output\"]}\n        });\n\n        function init_es6_itervar(output, itervar) {\n            output.indent();\n            output.spaced(itervar, \"=\", \"((typeof\", itervar + \"[Symbol.iterator]\", \"===\", \"\\\"function\\\")\", \"?\", \"(\" + itervar, \"instanceof\", \"Map\", \"?\", itervar + \".keys()\", \":\", itervar + \")\", \":\", \"Object.keys(\" + itervar + \"))\");\n            output.end_statement();\n        };\n        if (!init_es6_itervar.__argnames__) Object.defineProperties(init_es6_itervar, {\n            __argnames__ : {value: [\"output\", \"itervar\"]}\n        });\n\n        function print_for_in(self, output) {\n            var increment, args, tmp_, start, end, idx, itervar;\n            function write_object() {\n                if (self.object.constructor === AST_Seq) {\n                    new AST_Array((function(){\n                        var ρσ_d = Object.create(null);\n                        ρσ_d[\"elements\"] = self.object.to_array();\n                        return ρσ_d;\n                    }).call(this)).print(output);\n                } else {\n                    self.object.print(output);\n                }\n            };\n\n            if (is_simple_for(self)) {\n                increment = null;\n                args = self.object.args;\n                tmp_ = args.length;\n                if (tmp_ === 1) {\n                    start = 0;\n                    end = args[0];\n                } else if (tmp_ === 2) {\n                    start = args[0];\n                    end = args[1];\n                } else if (tmp_ === 3) {\n                    start = args[0];\n                    end = args[1];\n                    increment = args[2];\n                }\n                self.simple_for_index = idx = \"ρσ_Index\" + output.index_counter;\n                output.index_counter += 1;\n                output.print(\"for\");\n                output.space();\n                output.with_parens(function () {\n                    [output.spaced(\"var\", idx, \"=\"), output.space()];\n                    (start.print) ? start.print(output) : output.print(start);\n                    output.semicolon();\n                    output.space();\n                    output.print(idx);\n                    output.space();\n                    (is_node_type(increment, AST_Unary)) ? output.print(\">\") : output.print(\"<\");\n                    output.space();\n                    end.print(output);\n                    output.semicolon();\n                    output.space();\n                    output.print(idx);\n                    if (increment && (!is_node_type(increment, AST_Unary) || increment.expression.value !== \"1\")) {\n                        if (is_node_type(increment, AST_Unary)) {\n                            output.print(\"-=\");\n                            increment.expression.print(output);\n                        } else {\n                            output.print(\"+=\");\n                            increment.print(output);\n                        }\n                    } else {\n                        if (is_node_type(increment, AST_Unary)) {\n                            output.print(\"--\");\n                        } else {\n                            output.print(\"++\");\n                        }\n                    }\n                });\n            } else if (is_simple_for_in(self)) {\n                output.print(\"for\");\n                output.space();\n                output.with_parens(function () {\n                    self.init.print(output);\n                    output.space();\n                    output.print(\"in\");\n                    output.space();\n                    self.object.args[0].print(output);\n                });\n            } else {\n                if (output.options.js_version === 5) {\n                    output.assign(\"var ρσ_Iter\" + output.index_counter);\n                    output.print(\"ρσ_Iterable\");\n                    output.with_parens(write_object);\n                    output.semicolon();\n                    output.newline();\n                    output.indent();\n                    output.print(\"for\");\n                    output.space();\n                    output.with_parens(function () {\n                        output.print(\"var\");\n                        output.space();\n                        output.assign(\"ρσ_Index\" + output.index_counter);\n                        output.print(\"0\");\n                        output.semicolon();\n                        output.space();\n                        output.print(\"ρσ_Index\" + output.index_counter);\n                        output.space();\n                        output.print(\"<\");\n                        output.space();\n                        output.print(\"ρσ_Iter\" + output.index_counter + \".length\");\n                        output.semicolon();\n                        output.space();\n                        output.print(\"ρσ_Index\" + output.index_counter + \"++\");\n                    });\n                } else {\n                    itervar = \"ρσ_Iter\" + output.index_counter;\n                    output.assign(\"var \" + itervar);\n                    write_object();\n                    output.end_statement();\n                    init_es6_itervar(output, itervar);\n                    output.indent();\n                    output.spaced(\"for\", \"(var\", \"ρσ_Index\" + output.index_counter, \"of\", itervar + \")\");\n                }\n            }\n            output.space();\n            self._do_print_body(output);\n        };\n        if (!print_for_in.__argnames__) Object.defineProperties(print_for_in, {\n            __argnames__ : {value: [\"self\", \"output\"]}\n        });\n\n        function print_list_comprehension(self, output) {\n            var tname, result_obj, is_generator, es5, add_to_result, push_func;\n            tname = self.constructor.name.slice(4);\n            result_obj = (ρσ_expr_temp = (function(){\n                var ρσ_d = Object.create(null);\n                ρσ_d[\"ListComprehension\"] = \"[]\";\n                ρσ_d[\"DictComprehension\"] = (self.is_jshash) ? \"Object.create(null)\" : \"{}\";\n                ρσ_d[\"SetComprehension\"] = \"ρσ_set()\";\n                return ρσ_d;\n            }).call(this))[(typeof tname === \"number\" && tname < 0) ? ρσ_expr_temp.length + tname : tname];\n            is_generator = tname === \"GeneratorComprehension\";\n            es5 = output.option(\"js_version\") === 5;\n            if (tname === \"DictComprehension\") {\n                if (self.is_pydict) {\n                    result_obj = \"ρσ_dict()\";\n                    add_to_result = (function() {\n                        var ρσ_anonfunc = function (output) {\n                            output.indent();\n                            output.print(\"ρσ_Result.set\");\n                            output.with_parens(function () {\n                                self.statement.print(output);\n                                [output.space(), output.print(\",\"), output.space()];\n                                output.with_parens(function () {\n                                    if (self.value_statement.constructor === AST_Seq) {\n                                        output.with_square(function () {\n                                            self.value_statement.print(output);\n                                        });\n                                    } else {\n                                        self.value_statement.print(output);\n                                    }\n                                });\n                            });\n                            output.end_statement();\n                        };\n                        if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                            __argnames__ : {value: [\"output\"]}\n                        });\n                        return ρσ_anonfunc;\n                    })();\n                } else {\n                    add_to_result = (function() {\n                        var ρσ_anonfunc = function (output) {\n                            output.indent();\n                            output.print(\"ρσ_Result\");\n                            output.with_square(function () {\n                                self.statement.print(output);\n                            });\n                            [output.space(), output.print(\"=\"), output.space()];\n                            output.with_parens(function () {\n                                if (self.value_statement.constructor === AST_Seq) {\n                                    output.with_square(function () {\n                                        self.value_statement.print(output);\n                                    });\n                                } else {\n                                    self.value_statement.print(output);\n                                }\n                            });\n                            output.end_statement();\n                        };\n                        if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                            __argnames__ : {value: [\"output\"]}\n                        });\n                        return ρσ_anonfunc;\n                    })();\n                }\n            } else {\n                push_func = \"ρσ_Result.\" + ((self.constructor === AST_ListComprehension) ? \"push\" : \"add\");\n                if (is_generator) {\n                    push_func = \"yield \";\n                }\n                add_to_result = (function() {\n                    var ρσ_anonfunc = function (output) {\n                        output.indent();\n                        output.print(push_func);\n                        output.with_parens(function () {\n                            if (self.statement.constructor === AST_Seq) {\n                                output.with_square(function () {\n                                    self.statement.print(output);\n                                });\n                            } else {\n                                self.statement.print(output);\n                            }\n                        });\n                        output.end_statement();\n                    };\n                    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                        __argnames__ : {value: [\"output\"]}\n                    });\n                    return ρσ_anonfunc;\n                })();\n            }\n            output.with_parens(function () {\n                output.print(\"function\");\n                output.print(\"()\");\n                output.space();\n                output.with_block(function () {\n                    var body_out, previous_indentation, i, transpiled, ci;\n                    body_out = output;\n                    if (is_generator) {\n                        if (es5) {\n                            body_out = new OutputStream((function(){\n                                var ρσ_d = Object.create(null);\n                                ρσ_d[\"beautify\"] = true;\n                                return ρσ_d;\n                            }).call(this));\n                        }\n                        body_out.indent();\n                        [body_out.print(\"function* js_generator()\"), body_out.space(), body_out.print(\"{\")];\n                        body_out.newline();\n                        previous_indentation = output.indentation();\n                        output.set_indentation(output.next_indent());\n                    }\n                    body_out.indent();\n                    body_out.assign(\"var ρσ_Iter\");\n                    if (es5) {\n                        body_out.print(\"ρσ_Iterable\");\n                        body_out.with_parens(function () {\n                            self.object.print(body_out);\n                        });\n                    } else {\n                        self.object.print(body_out);\n                    }\n                    if (result_obj) {\n                        body_out.comma();\n                        body_out.assign(\"ρσ_Result\");\n                        body_out.print(result_obj);\n                    }\n                    if (is_node_type(self.init, AST_Array)) {\n                        var ρσ_Iter87 = ρσ_Iterable(self.init.elements);\n                        for (var ρσ_Index87 = 0; ρσ_Index87 < ρσ_Iter87.length; ρσ_Index87++) {\n                            i = ρσ_Iter87[ρσ_Index87];\n                            body_out.comma();\n                            i.print(body_out);\n                        }\n                    } else {\n                        body_out.comma();\n                        self.init.print(body_out);\n                    }\n                    body_out.end_statement();\n                    if (!es5) {\n                        init_es6_itervar(body_out, \"ρσ_Iter\");\n                    }\n                    body_out.indent();\n                    body_out.print(\"for\");\n                    body_out.space();\n                    body_out.with_parens(function () {\n                        if (es5) {\n                            body_out.print(\"var\");\n                            body_out.space();\n                            body_out.assign(\"ρσ_Index\");\n                            body_out.print(\"0\");\n                            body_out.semicolon();\n                            body_out.space();\n                            body_out.print(\"ρσ_Index\");\n                            body_out.space();\n                            body_out.print(\"<\");\n                            body_out.space();\n                            body_out.print(\"ρσ_Iter.length\");\n                            body_out.semicolon();\n                            body_out.space();\n                            body_out.print(\"ρσ_Index++\");\n                        } else {\n                            body_out.spaced(\"var\", \"ρσ_Index\", \"of\", \"ρσ_Iter\");\n                        }\n                    });\n                    body_out.space();\n                    body_out.with_block(function () {\n                        var itervar, flat;\n                        body_out.indent();\n                        itervar = (es5) ? \"ρσ_Iter[ρσ_Index]\" : \"ρσ_Index\";\n                        if (is_node_type(self.init, AST_Array)) {\n                            flat = self.init.flatten();\n                            body_out.assign(\"ρσ_unpack\");\n                            if (flat.length > self.init.elements.length) {\n                                body_out.print(\"ρσ_flatten(\" + itervar + \")\");\n                            } else {\n                                body_out.print(itervar);\n                            }\n                            body_out.end_statement();\n                            unpack_tuple(flat, body_out);\n                        } else {\n                            body_out.assign(self.init);\n                            body_out.print(itervar);\n                            body_out.end_statement();\n                        }\n                        if (self.condition) {\n                            body_out.indent();\n                            body_out.print(\"if\");\n                            body_out.space();\n                            body_out.with_parens(function () {\n                                self.condition.print(body_out);\n                            });\n                            body_out.space();\n                            body_out.with_block(function () {\n                                add_to_result(body_out);\n                            });\n                            body_out.newline();\n                        } else {\n                            add_to_result(body_out);\n                        }\n                    });\n                    body_out.newline();\n                    if (self.constructor === AST_ListComprehension) {\n                        body_out.indent();\n                        body_out.spaced(\"ρσ_Result\", \"=\", \"ρσ_list_constructor(ρσ_Result)\");\n                        body_out.end_statement();\n                    }\n                    if (!is_generator) {\n                        body_out.indent();\n                        body_out.print(\"return ρσ_Result\");\n                        body_out.end_statement();\n                    }\n                    if (is_generator) {\n                        output.set_indentation(previous_indentation);\n                        [body_out.newline(), body_out.indent(), body_out.print(\"}\")];\n                        if (es5) {\n                            transpiled = regenerate(body_out.get(), output.options.beautify).replace(/regeneratorRuntime.(wrap|mark)/g, \"ρσ_regenerator.regeneratorRuntime.$1\");\n                            if (output.options.beautify) {\n                                ci = output.make_indent(0);\n                                transpiled = (function() {\n                                    var ρσ_Iter = ρσ_Iterable(transpiled.split(\"\\n\")), ρσ_Result = [], x;\n                                    for (var ρσ_Index = 0; ρσ_Index < ρσ_Iter.length; ρσ_Index++) {\n                                        x = ρσ_Iter[ρσ_Index];\n                                        ρσ_Result.push(ci + x);\n                                    }\n                                    ρσ_Result = ρσ_list_constructor(ρσ_Result);\n                                    return ρσ_Result;\n                                })().join(\"\\n\");\n                            }\n                            output.print(transpiled);\n                        }\n                        [output.newline(), output.indent()];\n                        output.spaced(\"var\", \"result\", \"=\", \"js_generator.call(this)\");\n                        output.end_statement();\n                        output.indent();\n                        output.spaced(\"result.send\", \"=\", \"result.next\");\n                        output.end_statement();\n                        output.indent();\n                        output.spaced(\"return\", \"result\");\n                        output.end_statement();\n                    }\n                });\n            });\n            output.print(\"()\");\n        };\n        if (!print_list_comprehension.__argnames__) Object.defineProperties(print_list_comprehension, {\n            __argnames__ : {value: [\"self\", \"output\"]}\n        });\n\n        ρσ_modules[\"output.loops\"].unpack_tuple = unpack_tuple;\n        ρσ_modules[\"output.loops\"].print_do_loop = print_do_loop;\n        ρσ_modules[\"output.loops\"].print_while_loop = print_while_loop;\n        ρσ_modules[\"output.loops\"].is_simple_for_in = is_simple_for_in;\n        ρσ_modules[\"output.loops\"].is_simple_for = is_simple_for;\n        ρσ_modules[\"output.loops\"].print_for_loop_body = print_for_loop_body;\n        ρσ_modules[\"output.loops\"].init_es6_itervar = init_es6_itervar;\n        ρσ_modules[\"output.loops\"].print_for_in = print_for_in;\n        ρσ_modules[\"output.loops\"].print_list_comprehension = print_list_comprehension;\n    })();\n\n    (function(){\n        var __name__ = \"output.operators\";\n        var after_map;\n        var AST_Number = ρσ_modules.ast.AST_Number;\n        var AST_Unary = ρσ_modules.ast.AST_Unary;\n        var AST_Seq = ρσ_modules.ast.AST_Seq;\n        var AST_Array = ρσ_modules.ast.AST_Array;\n        var AST_Binary = ρσ_modules.ast.AST_Binary;\n        var AST_Set = ρσ_modules.ast.AST_Set;\n        var AST_Object = ρσ_modules.ast.AST_Object;\n        var AST_Statement = ρσ_modules.ast.AST_Statement;\n        var AST_Conditional = ρσ_modules.ast.AST_Conditional;\n        var AST_BaseCall = ρσ_modules.ast.AST_BaseCall;\n        var AST_Symbol = ρσ_modules.ast.AST_Symbol;\n        var AST_SymbolRef = ρσ_modules.ast.AST_SymbolRef;\n        var AST_Assign = ρσ_modules.ast.AST_Assign;\n        var AST_Return = ρσ_modules.ast.AST_Return;\n        var AST_SimpleStatement = ρσ_modules.ast.AST_SimpleStatement;\n        var AST_String = ρσ_modules.ast.AST_String;\n        var AST_Sub = ρσ_modules.ast.AST_Sub;\n        var AST_ItemAccess = ρσ_modules.ast.AST_ItemAccess;\n        var is_node_type = ρσ_modules.ast.is_node_type;\n\n        var unpack_tuple = ρσ_modules[\"output.loops\"].unpack_tuple;\n\n        function print_getattr(self, output, skip_expression) {\n            var expr;\n            if (!skip_expression) {\n                expr = self.expression;\n                expr.print(output);\n            }\n            if (is_node_type(expr, AST_Number) && expr.value >= 0) {\n                if (!/[xa-f.]/i.test(output.last())) {\n                    output.print(\".\");\n                }\n            }\n            output.print(\".\");\n            output.print_name(self.property);\n        };\n        if (!print_getattr.__argnames__) Object.defineProperties(print_getattr, {\n            __argnames__ : {value: [\"self\", \"output\", \"skip_expression\"]}\n        });\n\n        function print_getitem(self, output) {\n            var expr, prop, is_negative_number, is_repeatable;\n            expr = self.expression;\n            prop = self.property;\n            if (is_node_type(prop, AST_Number) || is_node_type(prop, AST_String) || is_node_type(prop, AST_SymbolRef) && prop.name && prop.name.startsWith(\"ρσ_\")) {\n                expr.print(output);\n                [output.print(\"[\"), prop.print(output), output.print(\"]\")];\n                return;\n            }\n            is_negative_number = is_node_type(prop, AST_Unary) && prop.operator === \"-\" && is_node_type(prop.expression, AST_Number);\n            is_repeatable = is_node_type(expr, AST_SymbolRef);\n            if (is_repeatable) {\n                expr.print(output);\n            } else {\n                [output.spaced(\"(ρσ_expr_temp\", \"=\", expr), output.print(\")\")];\n                expr = (function(){\n                    var ρσ_d = Object.create(null);\n                    ρσ_d[\"print\"] = function () {\n                        output.print(\"ρσ_expr_temp\");\n                    };\n                    return ρσ_d;\n                }).call(this);\n            }\n            if (is_negative_number) {\n                [output.print(\"[\"), expr.print(output), output.print(\".length\"), prop.print(output), \n                output.print(\"]\")];\n                return;\n            }\n            is_repeatable = is_node_type(prop, AST_SymbolRef);\n            if (is_repeatable) {\n                output.spaced(\"[(typeof\", prop, \"===\", \"\\\"number\\\"\", \"&&\", prop);\n                [output.spaced(\"\", \"<\", \"0)\", \"?\", expr), output.spaced(\".length\", \"+\", prop, \":\", prop)];\n                output.print(\"]\");\n            } else {\n                [output.print(\"[ρσ_bound_index(\"), prop.print(output), output.comma(), expr.print(output), \n                output.print(\")]\")];\n            }\n        };\n        if (!print_getitem.__argnames__) Object.defineProperties(print_getitem, {\n            __argnames__ : {value: [\"self\", \"output\"]}\n        });\n\n        function print_rich_getitem(self, output) {\n            var func;\n            func = \"ρσ_\" + ((self.assignment) ? \"setitem\" : \"getitem\");\n            output.print(func + \"(\");\n            [self.expression.print(output), output.comma(), self.property.print(output)];\n            if (self.assignment) {\n                [output.comma(), self.assignment.print(output)];\n            }\n            output.print(\")\");\n        };\n        if (!print_rich_getitem.__argnames__) Object.defineProperties(print_rich_getitem, {\n            __argnames__ : {value: [\"self\", \"output\"]}\n        });\n\n        function print_splice_assignment(self, output) {\n            output.print(\"ρσ_splice(\");\n            [self.expression.print(output), output.comma(), self.assignment.print(output), output.comma()];\n            (self.property) ? self.property.print(output) : output.print(\"0\");\n            if (self.property2) {\n                output.comma();\n                self.property2.print(output);\n            }\n            output.print(\")\");\n        };\n        if (!print_splice_assignment.__argnames__) Object.defineProperties(print_splice_assignment, {\n            __argnames__ : {value: [\"self\", \"output\"]}\n        });\n\n        function print_delete(self, output) {\n            if (is_node_type(self, AST_Symbol)) {\n                [output.assign(self), output.print(\"undefined\")];\n            } else if (is_node_type(self, AST_Sub) || is_node_type(self, AST_ItemAccess)) {\n                [output.print(\"ρσ_delitem(\"), self.expression.print(output), output.comma(), self.property.print(output), \n                output.print(\")\")];\n            } else {\n                output.spaced(\"delete\", self);\n            }\n        };\n        if (!print_delete.__argnames__) Object.defineProperties(print_delete, {\n            __argnames__ : {value: [\"self\", \"output\"]}\n        });\n\n        function print_unary_prefix(self, output) {\n            var op;\n            op = self.operator;\n            if (op === \"delete\") {\n                return print_delete(self.expression, output);\n            }\n            output.print(op);\n            if (/^[a-z]/i.test(op)) {\n                output.space();\n            }\n            self.expression.print(output);\n        };\n        if (!print_unary_prefix.__argnames__) Object.defineProperties(print_unary_prefix, {\n            __argnames__ : {value: [\"self\", \"output\"]}\n        });\n\n        function write_instanceof(left, right, output) {\n            function do_many(vals) {\n                [output.print(\"ρσ_instanceof.apply(null,\"), output.space()];\n                [output.print(\"[\"), left.print(output), output.comma()];\n                for (var i = 0; i < vals.length; i++) {\n                    vals[(typeof i === \"number\" && i < 0) ? vals.length + i : i].print(output);\n                    if (i !== vals.length - 1) {\n                        output.comma();\n                    }\n                }\n                output.print(\"])\");\n            };\n            if (!do_many.__argnames__) Object.defineProperties(do_many, {\n                __argnames__ : {value: [\"vals\"]}\n            });\n\n            if (is_node_type(right, AST_Seq)) {\n                do_many(right.to_array());\n            } else if (is_node_type(right, AST_Array)) {\n                do_many(right.elements);\n            } else {\n                output.print(\"ρσ_instanceof(\");\n                [left.print(output), output.comma(), right.print(output), output.print(\")\")];\n            }\n        };\n        if (!write_instanceof.__argnames__) Object.defineProperties(write_instanceof, {\n            __argnames__ : {value: [\"left\", \"right\", \"output\"]}\n        });\n\n        function write_smart_equality(self, output) {\n            function is_ok(x) {\n                return !(is_node_type(x, AST_Array) || is_node_type(x, AST_Set) || is_node_type(x, AST_Object) || is_node_type(x, AST_Statement) || is_node_type(x, AST_Binary) || is_node_type(x, AST_Conditional) || is_node_type(x, AST_BaseCall));\n            };\n            if (!is_ok.__argnames__) Object.defineProperties(is_ok, {\n                __argnames__ : {value: [\"x\"]}\n            });\n\n            if (is_ok(self.left) && is_ok(self.right)) {\n                if (self.operator === \"==\") {\n                    output.print(\"(\");\n                    output.spaced(self.left, \"===\", self.right, \"||\", \"typeof\", self.left, \"===\", \"\\\"object\\\"\", \"&&\", \"ρσ_equals(\");\n                    [self.left.print(output), output.print(\",\"), output.space(), self.right.print(output), \n                    output.print(\"))\")];\n                } else {\n                    output.print(\"(\");\n                    output.spaced(self.left, \"!==\", self.right, \"&&\", \"(typeof\", self.left, \"!==\", \"\\\"object\\\"\", \"||\", \"ρσ_not_equals(\");\n                    [self.left.print(output), output.print(\",\"), output.space(), self.right.print(output), \n                    output.print(\")))\")];\n                }\n            } else {\n                output.print(\"ρσ_\" + ((self.operator === \"==\") ? \"equals(\" : \"not_equals(\"));\n                [self.left.print(output), output.print(\",\"), output.space(), self.right.print(output), \n                output.print(\")\")];\n            }\n        };\n        if (!write_smart_equality.__argnames__) Object.defineProperties(write_smart_equality, {\n            __argnames__ : {value: [\"self\", \"output\"]}\n        });\n\n        function print_binary_op(self, output) {\n            var comparators, function_ops, leftvar;\n            comparators = (function(){\n                var ρσ_d = Object.create(null);\n                ρσ_d[\"<\"] = true;\n                ρσ_d[\">\"] = true;\n                ρσ_d[\"<=\"] = true;\n                ρσ_d[\">=\"] = true;\n                ρσ_d[\"==\"] = true;\n                ρσ_d[\"!=\"] = true;\n                return ρσ_d;\n            }).call(this);\n            function_ops = (function(){\n                var ρσ_d = Object.create(null);\n                ρσ_d[\"in\"] = \"ρσ_in\";\n                return ρσ_d;\n            }).call(this);\n            if (function_ops[ρσ_bound_index(self.operator, function_ops)]) {\n                output.print(function_ops[ρσ_bound_index(self.operator, function_ops)]);\n                output.with_parens(function () {\n                    self.left.print(output);\n                    output.comma();\n                    self.right.print(output);\n                });\n            } else if (comparators[ρσ_bound_index(self.operator, comparators)] && is_node_type(self.left, AST_Binary) && comparators[ρσ_bound_index(self.left.operator, comparators)]) {\n                if (is_node_type(self.left.right, AST_Symbol)) {\n                    self.left.print(output);\n                    leftvar = self.left.right.name;\n                } else {\n                    self.left.left.print(output);\n                    output.space();\n                    output.print(self.left.operator);\n                    output.space();\n                    output.with_parens(function () {\n                        output.assign(\"ρσ_cond_temp\");\n                        self.left.right.print(output);\n                        leftvar = \"ρσ_cond_temp\";\n                    });\n                }\n                output.space();\n                output.print(\"&&\");\n                output.space();\n                output.print(leftvar);\n                output.space();\n                output.print(self.operator);\n                output.space();\n                self.right.print(output);\n            } else if (self.operator === \"//\") {\n                output.print(\"Math.floor\");\n                output.with_parens(function () {\n                    self.left.print(output);\n                    output.space();\n                    output.print(\"/\");\n                    output.space();\n                    self.right.print(output);\n                });\n            } else if (self.operator === \"**\") {\n                if (is_node_type(self.left, AST_Unary)) {\n                    output.print(self.left.operator + \"Math.pow(\");\n                    [self.left.expression.print(output), output.comma()];\n                    [self.right.print(output), output.print(\")\")];\n                } else {\n                    [output.print(\"Math.pow(\"), self.left.print(output), output.comma(), self.right.print(output), \n                    output.print(\")\")];\n                }\n            } else if (self.operator === \"==\" || self.operator === \"!=\") {\n                write_smart_equality(self, output);\n            } else if (self.operator === \"instanceof\") {\n                write_instanceof(self.left, self.right, output);\n            } else if (self.operator === \"*\" && is_node_type(self.left, AST_String)) {\n                [self.left.print(output), output.print(\".repeat(\"), self.right.print(output), output.print(\")\")];\n            } else {\n                output.spaced(self.left, self.operator, self.right);\n            }\n        };\n        if (!print_binary_op.__argnames__) Object.defineProperties(print_binary_op, {\n            __argnames__ : {value: [\"self\", \"output\"]}\n        });\n\n        after_map = (function(){\n            var ρσ_d = Object.create(null);\n            ρσ_d[\".\"] = \"d\";\n            ρσ_d[\"(\"] = \"c\";\n            ρσ_d[\"[\"] = \"d\";\n            ρσ_d[\"g\"] = \"g\";\n            ρσ_d[\"null\"] = \"n\";\n            return ρσ_d;\n        }).call(this);\n        function print_existential(self, output) {\n            var key, after;\n            key = (self.after === null || typeof self.after === \"string\") ? after_map[ρσ_bound_index(self.after, after_map)] : \"e\";\n            if (is_node_type(self.expression, AST_SymbolRef)) {\n                if (key === \"n\") {\n                    output.spaced(\"(typeof\", self.expression, \"!==\", \"\\\"undefined\\\"\", \"&&\", self.expression, \"!==\", \"null)\");\n                    return;\n                }\n                if (key === \"c\") {\n                    output.spaced(\"(typeof\", self.expression, \"===\", \"\\\"function\\\"\", \"?\", self.expression, \":\", \"(function(){return undefined;}))\");\n                    return;\n                }\n                after = self.after;\n                if (key === \"d\") {\n                    after = \"Object.create(null)\";\n                } else if (key === \"g\") {\n                    after = \"{__getitem__:function(){return undefined;}}\";\n                }\n                output.spaced(\"(typeof\", self.expression, \"!==\", \"\\\"undefined\\\"\", \"&&\", self.expression, \"!==\", \"null\", \"?\", self.expression, \":\", after);\n                output.print(\")\");\n                return;\n            }\n            output.print(\"ρσ_exists.\" + key + \"(\");\n            self.expression.print(output);\n            if (key === \"e\") {\n                [output.comma(), self.after.print(output)];\n            }\n            output.print(\")\");\n        };\n        if (!print_existential.__argnames__) Object.defineProperties(print_existential, {\n            __argnames__ : {value: [\"self\", \"output\"]}\n        });\n\n        function print_assignment(self, output) {\n            var flattened, left, flat;\n            flattened = false;\n            left = self.left;\n            if (is_node_type(left, AST_Seq)) {\n                left = new AST_Array((function(){\n                    var ρσ_d = Object.create(null);\n                    ρσ_d[\"elements\"] = [left.car, left.cdr];\n                    return ρσ_d;\n                }).call(this));\n            }\n            if (is_node_type(left, AST_Array)) {\n                flat = left.flatten();\n                flattened = flat.length > left.elements.length;\n                output.print(\"ρσ_unpack\");\n            } else {\n                left.print(output);\n            }\n            output.space();\n            output.print(self.operator);\n            output.space();\n            if (flattened) {\n                output.print(\"ρσ_flatten\");\n                output.with_parens(function () {\n                    self.right.print(output);\n                });\n            } else {\n                self.right.print(output);\n            }\n            if (is_node_type(left, AST_Array)) {\n                output.end_statement();\n                if (!is_node_type(self.right, AST_Seq) && !is_node_type(self.right, AST_Array)) {\n                    output.assign(\"ρσ_unpack\");\n                    [output.print(\"ρσ_unpack_asarray(\" + flat.length), output.comma(), output.print(\"ρσ_unpack)\")];\n                    output.end_statement();\n                }\n                unpack_tuple(flat, output, true);\n            }\n        };\n        if (!print_assignment.__argnames__) Object.defineProperties(print_assignment, {\n            __argnames__ : {value: [\"self\", \"output\"]}\n        });\n\n        function print_assign(self, output) {\n            var ρσ_unpack, left_hand_sides, rhs, is_compound_assign, lhs, temp_rhs;\n            if (self.operator === \"//=\") {\n                output.assign(self.left);\n                output.print(\"Math.floor\");\n                output.with_parens(function () {\n                    self.left.print(output);\n                    output.space();\n                    output.print(\"/\");\n                    output.space();\n                    self.right.print(output);\n                });\n                return;\n            }\n            if (self.operator === \"=\" && self.is_chained()) {\n                ρσ_unpack = self.traverse_chain();\nρσ_unpack = ρσ_unpack_asarray(2, ρσ_unpack);\n                left_hand_sides = ρσ_unpack[0];\n                rhs = ρσ_unpack[1];\n                is_compound_assign = false;\n                var ρσ_Iter88 = ρσ_Iterable(left_hand_sides);\n                for (var ρσ_Index88 = 0; ρσ_Index88 < ρσ_Iter88.length; ρσ_Index88++) {\n                    lhs = ρσ_Iter88[ρσ_Index88];\n                    if (is_node_type(lhs, AST_Seq) || is_node_type(lhs, AST_Array)) {\n                        is_compound_assign = true;\n                        break;\n                    }\n                }\n                if (is_compound_assign) {\n                    temp_rhs = new AST_SymbolRef((function(){\n                        var ρσ_d = Object.create(null);\n                        ρσ_d[\"name\"] = \"ρσ_chain_assign_temp\";\n                        return ρσ_d;\n                    }).call(this));\n                    print_assignment(new AST_Assign((function(){\n                        var ρσ_d = Object.create(null);\n                        ρσ_d[\"left\"] = temp_rhs;\n                        ρσ_d[\"operator\"] = \"=\";\n                        ρσ_d[\"right\"] = rhs;\n                        return ρσ_d;\n                    }).call(this)), output);\n                    var ρσ_Iter89 = ρσ_Iterable(left_hand_sides);\n                    for (var ρσ_Index89 = 0; ρσ_Index89 < ρσ_Iter89.length; ρσ_Index89++) {\n                        lhs = ρσ_Iter89[ρσ_Index89];\n                        [output.end_statement(), output.indent()];\n                        print_assignment(new AST_Assign((function(){\n                            var ρσ_d = Object.create(null);\n                            ρσ_d[\"left\"] = lhs;\n                            ρσ_d[\"right\"] = temp_rhs;\n                            ρσ_d[\"operator\"] = self.operator;\n                            return ρσ_d;\n                        }).call(this)), output);\n                    }\n                } else {\n                    var ρσ_Iter90 = ρσ_Iterable(left_hand_sides);\n                    for (var ρσ_Index90 = 0; ρσ_Index90 < ρσ_Iter90.length; ρσ_Index90++) {\n                        lhs = ρσ_Iter90[ρσ_Index90];\n                        output.spaced(lhs, \"=\", \"\");\n                    }\n                    rhs.print(output);\n                }\n            } else {\n                print_assignment(self, output);\n            }\n        };\n        if (!print_assign.__argnames__) Object.defineProperties(print_assign, {\n            __argnames__ : {value: [\"self\", \"output\"]}\n        });\n\n        function print_conditional(self, output, condition, consequent, alternative) {\n            var ρσ_unpack;\n            ρσ_unpack = [self.condition, self.consequent, self.alternative];\n            condition = ρσ_unpack[0];\n            consequent = ρσ_unpack[1];\n            alternative = ρσ_unpack[2];\n            output.with_parens(function () {\n                condition.print(output);\n            });\n            output.space();\n            output.print(\"?\");\n            output.space();\n            consequent.print(output);\n            output.space();\n            output.colon();\n            alternative.print(output);\n        };\n        if (!print_conditional.__argnames__) Object.defineProperties(print_conditional, {\n            __argnames__ : {value: [\"self\", \"output\", \"condition\", \"consequent\", \"alternative\"]}\n        });\n\n        function print_seq(output) {\n            var self, p, print_seq;\n            self = this;\n            p = output.parent();\n            print_seq = function () {\n                self.car.print(output);\n                if (self.cdr) {\n                    output.comma();\n                    if (output.should_break()) {\n                        output.newline();\n                        output.indent();\n                    }\n                    self.cdr.print(output);\n                }\n            };\n            if (is_node_type(p, AST_Binary) || is_node_type(p, AST_Return) || is_node_type(p, AST_Array) || is_node_type(p, AST_BaseCall) || is_node_type(p, AST_SimpleStatement)) {\n                output.with_square(print_seq);\n            } else {\n                print_seq();\n            }\n        };\n        if (!print_seq.__argnames__) Object.defineProperties(print_seq, {\n            __argnames__ : {value: [\"output\"]}\n        });\n\n        ρσ_modules[\"output.operators\"].after_map = after_map;\n        ρσ_modules[\"output.operators\"].print_getattr = print_getattr;\n        ρσ_modules[\"output.operators\"].print_getitem = print_getitem;\n        ρσ_modules[\"output.operators\"].print_rich_getitem = print_rich_getitem;\n        ρσ_modules[\"output.operators\"].print_splice_assignment = print_splice_assignment;\n        ρσ_modules[\"output.operators\"].print_delete = print_delete;\n        ρσ_modules[\"output.operators\"].print_unary_prefix = print_unary_prefix;\n        ρσ_modules[\"output.operators\"].write_instanceof = write_instanceof;\n        ρσ_modules[\"output.operators\"].write_smart_equality = write_smart_equality;\n        ρσ_modules[\"output.operators\"].print_binary_op = print_binary_op;\n        ρσ_modules[\"output.operators\"].print_existential = print_existential;\n        ρσ_modules[\"output.operators\"].print_assignment = print_assignment;\n        ρσ_modules[\"output.operators\"].print_assign = print_assign;\n        ρσ_modules[\"output.operators\"].print_conditional = print_conditional;\n        ρσ_modules[\"output.operators\"].print_seq = print_seq;\n    })();\n\n    (function(){\n        var __name__ = \"output.functions\";\n        var anonfunc;\n        var AST_ClassCall = ρσ_modules.ast.AST_ClassCall;\n        var AST_New = ρσ_modules.ast.AST_New;\n        var has_calls = ρσ_modules.ast.has_calls;\n        var AST_Dot = ρσ_modules.ast.AST_Dot;\n        var AST_SymbolRef = ρσ_modules.ast.AST_SymbolRef;\n        var is_node_type = ρσ_modules.ast.is_node_type;\n\n        var OutputStream = ρσ_modules[\"output.stream\"].OutputStream;\n\n        var print_bracketed = ρσ_modules[\"output.statements\"].print_bracketed;\n\n        var create_doctring = ρσ_modules[\"output.utils\"].create_doctring;\n\n        var print_getattr = ρσ_modules[\"output.operators\"].print_getattr;\n\n        anonfunc = \"ρσ_anonfunc\";\n        function decorate(decorators, output, func) {\n            var pos;\n            pos = 0;\n            function wrap() {\n                if (pos < decorators.length) {\n                    decorators[(typeof pos === \"number\" && pos < 0) ? decorators.length + pos : pos].expression.print(output);\n                    pos += 1;\n                    output.with_parens(function () {\n                        wrap();\n                    });\n                } else {\n                    func();\n                }\n            };\n\n            wrap();\n        };\n        if (!decorate.__argnames__) Object.defineProperties(decorate, {\n            __argnames__ : {value: [\"decorators\", \"output\", \"func\"]}\n        });\n\n        function function_args(argnames, output, strip_first) {\n            output.with_parens(function () {\n                var ρσ_unpack, i, arg;\n                if (argnames && argnames.length && (argnames.is_simple_func === true || argnames.is_simple_func === undefined)) {\n                    var ρσ_Iter91 = ρσ_Iterable(enumerate((strip_first) ? argnames.slice(1) : argnames));\n                    for (var ρσ_Index91 = 0; ρσ_Index91 < ρσ_Iter91.length; ρσ_Index91++) {\n                        ρσ_unpack = ρσ_Iter91[ρσ_Index91];\n                        i = ρσ_unpack[0];\n                        arg = ρσ_unpack[1];\n                        if (i) {\n                            output.comma();\n                        }\n                        arg.print(output);\n                    }\n                }\n            });\n            output.space();\n        };\n        if (!function_args.__argnames__) Object.defineProperties(function_args, {\n            __argnames__ : {value: [\"argnames\", \"output\", \"strip_first\"]}\n        });\n\n        function function_preamble(node, output, offset) {\n            var a, fname, kw, i, ρσ_unpack, c, arg, dname, nargs;\n            a = node.argnames;\n            if (!a || a.is_simple_func) {\n                return;\n            }\n            fname = (node.name) ? node.name.name : anonfunc;\n            kw = \"arguments[arguments.length-1]\";\n            var ρσ_Iter92 = ρσ_Iterable(enumerate(a));\n            for (var ρσ_Index92 = 0; ρσ_Index92 < ρσ_Iter92.length; ρσ_Index92++) {\n                ρσ_unpack = ρσ_Iter92[ρσ_Index92];\n                c = ρσ_unpack[0];\n                arg = ρσ_unpack[1];\n                i = c - offset;\n                if (i >= 0) {\n                    output.indent();\n                    output.print(\"var\");\n                    output.space();\n                    output.assign(arg);\n                    if (Object.prototype.hasOwnProperty.call(a.defaults, arg.name)) {\n                        output.spaced(\"(arguments[\" + i + \"]\", \"===\", \"undefined\", \"||\", \"(\", i, \"===\", \"arguments.length-1\", \"&&\", kw, \"!==\", \"null\", \"&&\", \"typeof\", kw, \"===\", \"\\\"object\\\"\", \"&&\", kw, \"[ρσ_kwargs_symbol]\", \"===\", \"true))\", \"?\", \"\");\n                        [output.print(fname + \".__defaults__.\"), arg.print(output)];\n                        [output.space(), output.print(\":\"), output.space()];\n                    } else {\n                        output.spaced(\"(\", i, \"===\", \"arguments.length-1\", \"&&\", kw, \"!==\", \"null\", \"&&\", \"typeof\", kw, \"===\", \"\\\"object\\\"\", \"&&\", kw, \"[ρσ_kwargs_symbol]\", \"===\", \"true)\", \"?\", \"undefined\", \":\", \"\");\n                    }\n                    output.print(\"arguments[\" + i + \"]\");\n                    output.end_statement();\n                }\n            }\n            if (a.kwargs || a.has_defaults) {\n                kw = (a.kwargs) ? a.kwargs.name : \"ρσ_kwargs_obj\";\n                output.indent();\n                output.spaced(\"var\", kw, \"=\", \"arguments[arguments.length-1]\");\n                output.end_statement();\n                output.indent();\n                output.spaced(\"if\", \"(\" + kw, \"===\", \"null\", \"||\", \"typeof\", kw, \"!==\", \"\\\"object\\\"\", \"||\", kw, \"[ρσ_kwargs_symbol]\", \"!==\", \"true)\", kw, \"=\", \"{}\");\n                output.end_statement();\n                if (a.has_defaults) {\n                    var ρσ_Iter93 = ρσ_Iterable(Object.keys(a.defaults));\n                    for (var ρσ_Index93 = 0; ρσ_Index93 < ρσ_Iter93.length; ρσ_Index93++) {\n                        dname = ρσ_Iter93[ρσ_Index93];\n                        output.indent();\n                        output.spaced(\"if\", \"(Object.prototype.hasOwnProperty.call(\" + kw + \",\", \"\\\"\" + dname + \"\\\"))\");\n                        output.with_block(function () {\n                            output.indent();\n                            output.spaced(dname, \"=\", kw + \".\" + dname);\n                            output.end_statement();\n                            if (a.kwargs) {\n                                output.indent();\n                                output.spaced(\"delete\", kw + \".\" + dname);\n                                output.end_statement();\n                            }\n                        });\n                        output.newline();\n                    }\n                }\n            }\n            if (a.starargs !== undefined) {\n                nargs = a.length - offset;\n                output.indent();\n                output.spaced(\"var\", a.starargs.name, \"=\", \"Array.prototype.slice.call(arguments,\", nargs + \")\");\n                output.end_statement();\n                output.indent();\n                output.spaced(\"if\", \"(\" + kw, \"!==\", \"null\", \"&&\", \"typeof\", kw, \"===\", \"\\\"object\\\"\", \"&&\", kw, \"[ρσ_kwargs_symbol]\", \"===\", \"true)\", a.starargs.name);\n                output.print(\".pop()\");\n                output.end_statement();\n            }\n        };\n        if (!function_preamble.__argnames__) Object.defineProperties(function_preamble, {\n            __argnames__ : {value: [\"node\", \"output\", \"offset\"]}\n        });\n\n        function has_annotations(self) {\n            var arg;\n            if (self.return_annotation) {\n                return true;\n            }\n            var ρσ_Iter94 = ρσ_Iterable(self.argnames);\n            for (var ρσ_Index94 = 0; ρσ_Index94 < ρσ_Iter94.length; ρσ_Index94++) {\n                arg = ρσ_Iter94[ρσ_Index94];\n                if (arg.annotation) {\n                    return true;\n                }\n            }\n            return false;\n        };\n        if (!has_annotations.__argnames__) Object.defineProperties(has_annotations, {\n            __argnames__ : {value: [\"self\"]}\n        });\n\n        function function_annotation(self, output, strip_first, name) {\n            var fname, props, defaults, dkeys, names;\n            fname = name || ((self.name) ? self.name.name : anonfunc);\n            props = Object.create(null);\n            if (has_annotations(self)) {\n                props.__annotations__ = function () {\n                    var ρσ_unpack, i, arg;\n                    output.print(\"{\");\n                    if (self.argnames && self.argnames.length) {\n                        var ρσ_Iter95 = ρσ_Iterable(enumerate(self.argnames));\n                        for (var ρσ_Index95 = 0; ρσ_Index95 < ρσ_Iter95.length; ρσ_Index95++) {\n                            ρσ_unpack = ρσ_Iter95[ρσ_Index95];\n                            i = ρσ_unpack[0];\n                            arg = ρσ_unpack[1];\n                            if (arg.annotation) {\n                                arg.print(output);\n                                [output.print(\":\"), output.space()];\n                                arg.annotation.print(output);\n                                if (i < self.argnames.length - 1 || self.return_annotation) {\n                                    output.comma();\n                                }\n                            }\n                        }\n                    }\n                    if (self.return_annotation) {\n                        [output.print(\"return:\"), output.space()];\n                        self.return_annotation.print(output);\n                    }\n                    output.print(\"}\");\n                };\n            }\n            defaults = self.argnames.defaults;\n            dkeys = Object.keys(self.argnames.defaults);\n            if (dkeys.length) {\n                props.__defaults__ = function () {\n                    var ρσ_unpack, i, k;\n                    output.print(\"{\");\n                    var ρσ_Iter96 = ρσ_Iterable(enumerate(dkeys));\n                    for (var ρσ_Index96 = 0; ρσ_Index96 < ρσ_Iter96.length; ρσ_Index96++) {\n                        ρσ_unpack = ρσ_Iter96[ρσ_Index96];\n                        i = ρσ_unpack[0];\n                        k = ρσ_unpack[1];\n                        [output.print(k + \":\"), defaults[(typeof k === \"number\" && k < 0) ? defaults.length + k : k].print(output)];\n                        if (i !== dkeys.length - 1) {\n                            output.comma();\n                        }\n                    }\n                    output.print(\"}\");\n                };\n            }\n            if (!self.argnames.is_simple_func) {\n                props.__handles_kwarg_interpolation__ = function () {\n                    output.print(\"true\");\n                };\n            }\n            if (self.argnames.length) {\n                props.__argnames__ = function () {\n                    var ρσ_unpack, i, arg;\n                    output.print(\"[\");\n                    var ρσ_Iter97 = ρσ_Iterable(enumerate(self.argnames));\n                    for (var ρσ_Index97 = 0; ρσ_Index97 < ρσ_Iter97.length; ρσ_Index97++) {\n                        ρσ_unpack = ρσ_Iter97[ρσ_Index97];\n                        i = ρσ_unpack[0];\n                        arg = ρσ_unpack[1];\n                        if (strip_first && i === 0) {\n                            continue;\n                        }\n                        output.print(JSON.stringify(arg.name));\n                        if (i !== self.argnames.length - 1) {\n                            output.comma();\n                        }\n                    }\n                    output.print(\"]\");\n                };\n            }\n            if (output.options.keep_docstrings && self.docstrings && self.docstrings.length) {\n                props.__doc__ = function () {\n                    output.print(JSON.stringify(create_doctring(self.docstrings)));\n                };\n            }\n            names = Object.keys(props);\n            if (names.length) {\n                output.indent();\n                output.spaced(\"if\", \"(!\" + fname + \".\" + names[0] + \")\", \"Object.defineProperties(\" + fname);\n                output.comma();\n                output.with_block(function () {\n                    var name;\n                    for (var i = 0; i < names.length; i++) {\n                        name = names[(typeof i === \"number\" && i < 0) ? names.length + i : i];\n                        [output.indent(), output.spaced(name, \":\", \"{value:\", \"\"), props[(typeof name === \"number\" && name < 0) ? props.length + name : name](), \n                        output.print(\"}\")];\n                        if (i < names.length - 1) {\n                            output.print(\",\");\n                        }\n                        output.newline();\n                    }\n                });\n                [output.print(\")\"), output.end_statement()];\n            }\n        };\n        if (!function_annotation.__argnames__) Object.defineProperties(function_annotation, {\n            __argnames__ : {value: [\"self\", \"output\", \"strip_first\", \"name\"]}\n        });\n\n        function function_definition(self, output, strip_first, as_expression) {\n            var orig_indent;\n            as_expression = as_expression || self.is_expression || self.is_anonymous;\n            if (!self.argnames.length && !self.return_annotation && (!output.options.keep_docstrings || !self.docstrings || !self.docstrings.length)) {\n                as_expression = false;\n            }\n            if (as_expression) {\n                orig_indent = output.indentation();\n                output.set_indentation(output.next_indent());\n                [output.spaced(\"(function()\", \"{\"), output.newline()];\n                [output.indent(), output.spaced(\"var\", anonfunc, \"=\"), output.space()];\n            }\n            [output.print(\"function\"), output.space()];\n            if (self.name) {\n                self.name.print(output);\n            }\n            if (self.is_generator) {\n                [output.print(\"()\"), output.space()];\n                output.with_block(function () {\n                    var temp, transpiled, ci;\n                    if (output.options.js_version >= 6) {\n                        output.indent();\n                        output.print(\"function* js_generator\");\n                        function_args(self.argnames, output, strip_first);\n                        print_bracketed(self, output, true, function_preamble);\n                    } else {\n                        temp = new OutputStream((function(){\n                            var ρσ_d = Object.create(null);\n                            ρσ_d[\"beautify\"] = true;\n                            return ρσ_d;\n                        }).call(this));\n                        temp.print(\"function* js_generator\");\n                        function_args(self.argnames, temp, strip_first);\n                        print_bracketed(self, temp, true, function_preamble);\n                        transpiled = regenerate(temp.get(), output.options.beautify).replace(/regeneratorRuntime.(wrap|mark)/g, \"ρσ_regenerator.regeneratorRuntime.$1\");\n                        if (output.options.beautify) {\n                            ci = output.make_indent(0);\n                            transpiled = (function() {\n                                var ρσ_Iter = ρσ_Iterable(transpiled.split(\"\\n\")), ρσ_Result = [], x;\n                                for (var ρσ_Index = 0; ρσ_Index < ρσ_Iter.length; ρσ_Index++) {\n                                    x = ρσ_Iter[ρσ_Index];\n                                    ρσ_Result.push(ci + x);\n                                }\n                                ρσ_Result = ρσ_list_constructor(ρσ_Result);\n                                return ρσ_Result;\n                            })().join(\"\\n\");\n                        }\n                        output.print(transpiled);\n                    }\n                    output.newline();\n                    output.indent();\n                    output.spaced(\"var\", \"result\", \"=\", \"js_generator.apply(this,\", \"arguments)\");\n                    output.end_statement();\n                    output.indent();\n                    output.spaced(\"result.send\", \"=\", \"result.next\");\n                    output.end_statement();\n                    output.indent();\n                    output.spaced(\"return\", \"result\");\n                    output.end_statement();\n                });\n            } else {\n                function_args(self.argnames, output, strip_first);\n                print_bracketed(self, output, true, function_preamble);\n            }\n            if (as_expression) {\n                output.end_statement();\n                function_annotation(self, output, strip_first, anonfunc);\n                [output.indent(), output.spaced(\"return\", anonfunc), output.end_statement()];\n                output.set_indentation(orig_indent);\n                [output.indent(), output.print(\"})()\")];\n            }\n        };\n        if (!function_definition.__argnames__) Object.defineProperties(function_definition, {\n            __argnames__ : {value: [\"self\", \"output\", \"strip_first\", \"as_expression\"]}\n        });\n\n        function print_function(output) {\n            var self;\n            self = this;\n            if (self.decorators && self.decorators.length) {\n                output.print(\"var\");\n                output.space();\n                output.assign(self.name.name);\n                decorate(self.decorators, output, function () {\n                    function_definition(self, output, false, true);\n                });\n                output.end_statement();\n            } else {\n                function_definition(self, output, false);\n                if (!self.is_expression && !self.is_anonymous) {\n                    output.end_statement();\n                    function_annotation(self, output, false);\n                }\n            }\n        };\n        if (!print_function.__argnames__) Object.defineProperties(print_function, {\n            __argnames__ : {value: [\"output\"]}\n        });\n\n        function find_this(expression) {\n            if (is_node_type(expression, AST_Dot)) {\n                return expression.expression;\n            }\n            if (!is_node_type(expression, AST_SymbolRef)) {\n                return expression;\n            }\n        };\n        if (!find_this.__argnames__) Object.defineProperties(find_this, {\n            __argnames__ : {value: [\"expression\"]}\n        });\n\n        function print_this(expression, output) {\n            var obj;\n            obj = find_this(expression);\n            if (obj) {\n                obj.print(output);\n            } else {\n                output.print(\"this\");\n            }\n        };\n        if (!print_this.__argnames__) Object.defineProperties(print_this, {\n            __argnames__ : {value: [\"expression\", \"output\"]}\n        });\n\n        function print_function_call(self, output) {\n            var has_kwarg_items, has_kwarg_formals, has_kwargs, is_new, is_repeatable;\n            function print_function_name(no_call) {\n                if (is_node_type(self, AST_ClassCall)) {\n                    if (self.static) {\n                        self.class.print(output);\n                        output.print(\".\");\n                        output.print(self.method);\n                    } else {\n                        self.class.print(output);\n                        output.print(\".prototype.\");\n                        output.print(self.method);\n                        if (!no_call) {\n                            output.print(\".call\");\n                        }\n                    }\n                } else {\n                    if (!is_repeatable) {\n                        output.print(\"ρσ_expr_temp\");\n                        if (is_node_type(self.expression, AST_Dot)) {\n                            print_getattr(self.expression, output, true);\n                        }\n                    } else {\n                        self.expression.print(output);\n                    }\n                }\n            };\n            if (!print_function_name.__argnames__) Object.defineProperties(print_function_name, {\n                __argnames__ : {value: [\"no_call\"]}\n            });\n\n            function print_kwargs() {\n                var ρσ_unpack, i, kwname, pair;\n                output.print(\"ρσ_desugar_kwargs(\");\n                if (has_kwarg_items) {\n                    var ρσ_Iter98 = ρσ_Iterable(enumerate(self.args.kwarg_items));\n                    for (var ρσ_Index98 = 0; ρσ_Index98 < ρσ_Iter98.length; ρσ_Index98++) {\n                        ρσ_unpack = ρσ_Iter98[ρσ_Index98];\n                        i = ρσ_unpack[0];\n                        kwname = ρσ_unpack[1];\n                        if (i > 0) {\n                            output.print(\",\");\n                            output.space();\n                        }\n                        kwname.print(output);\n                    }\n                    if (has_kwarg_formals) {\n                        output.print(\",\");\n                        output.space();\n                    }\n                }\n                if (has_kwarg_formals) {\n                    output.print(\"{\");\n                    var ρσ_Iter99 = ρσ_Iterable(enumerate(self.args.kwargs));\n                    for (var ρσ_Index99 = 0; ρσ_Index99 < ρσ_Iter99.length; ρσ_Index99++) {\n                        ρσ_unpack = ρσ_Iter99[ρσ_Index99];\n                        i = ρσ_unpack[0];\n                        pair = ρσ_unpack[1];\n                        if (i) {\n                            output.comma();\n                        }\n                        pair[0].print(output);\n                        output.print(\":\");\n                        output.space();\n                        pair[1].print(output);\n                    }\n                    output.print(\"}\");\n                }\n                output.print(\")\");\n            };\n\n            function print_new(apply) {\n                output.print(\"ρσ_interpolate_kwargs_constructor.call(\");\n                [output.print(\"Object.create(\"), self.expression.print(output), output.print(\".prototype)\")];\n                output.comma();\n                output.print((apply) ? \"true\" : \"false\");\n                output.comma();\n            };\n            if (!print_new.__argnames__) Object.defineProperties(print_new, {\n                __argnames__ : {value: [\"apply\"]}\n            });\n\n            function do_print_this() {\n                if (!is_repeatable) {\n                    output.print(\"ρσ_expr_temp\");\n                } else {\n                    print_this(self.expression, output);\n                }\n                output.comma();\n            };\n\n            function print_positional_args() {\n                var i, expr, is_first;\n                i = 0;\n                while (i < self.args.length) {\n                    expr = (ρσ_expr_temp = self.args)[(typeof i === \"number\" && i < 0) ? ρσ_expr_temp.length + i : i];\n                    is_first = i === 0;\n                    if (!is_first) {\n                        output.print(\".concat(\");\n                    }\n                    if (expr.is_array) {\n                        expr.print(output);\n                        i += 1;\n                    } else {\n                        output.print(\"[\");\n                        while (i < self.args.length && !(ρσ_expr_temp = self.args)[(typeof i === \"number\" && i < 0) ? ρσ_expr_temp.length + i : i].is_array) {\n                            (ρσ_expr_temp = self.args)[(typeof i === \"number\" && i < 0) ? ρσ_expr_temp.length + i : i].print(output);\n                            if (i + 1 < self.args.length && !(ρσ_expr_temp = self.args)[ρσ_bound_index(i + 1, ρσ_expr_temp)].is_array) {\n                                output.print(\",\");\n                                output.space();\n                            }\n                            i += 1;\n                        }\n                        output.print(\"]\");\n                    }\n                    if (!is_first) {\n                        output.print(\")\");\n                    }\n                }\n            };\n\n            has_kwarg_items = self.args.kwarg_items && self.args.kwarg_items.length;\n            has_kwarg_formals = self.args.kwargs && self.args.kwargs.length;\n            has_kwargs = has_kwarg_items || has_kwarg_formals;\n            is_new = is_node_type(self, AST_New);\n            is_repeatable = true;\n            if (is_new && !self.args.length && !has_kwargs && !self.args.starargs) {\n                [output.print(\"new\"), output.space()];\n                print_function_name();\n                return;\n            }\n            if (!has_kwargs && !self.args.starargs) {\n                if (is_new) {\n                    [output.print(\"new\"), output.space()];\n                }\n                print_function_name();\n                output.with_parens(function () {\n                    var ρσ_unpack, i, a;\n                    var ρσ_Iter100 = ρσ_Iterable(enumerate(self.args));\n                    for (var ρσ_Index100 = 0; ρσ_Index100 < ρσ_Iter100.length; ρσ_Index100++) {\n                        ρσ_unpack = ρσ_Iter100[ρσ_Index100];\n                        i = ρσ_unpack[0];\n                        a = ρσ_unpack[1];\n                        if (i) {\n                            output.comma();\n                        }\n                        a.print(output);\n                    }\n                });\n                return;\n            }\n            is_repeatable = is_new || !has_calls(self.expression);\n            if (!is_repeatable) {\n                [output.assign(\"(ρσ_expr_temp\"), print_this(self.expression, output), output.comma()];\n            }\n            if (has_kwargs) {\n                if (is_new) {\n                    print_new(false);\n                } else {\n                    output.print(\"ρσ_interpolate_kwargs.call(\");\n                    do_print_this();\n                }\n                print_function_name(true);\n                output.comma();\n            } else {\n                if (is_new) {\n                    print_new(true);\n                    print_function_name(true);\n                    output.comma();\n                } else {\n                    print_function_name(true);\n                    output.print(\".apply(\");\n                    do_print_this();\n                }\n            }\n            print_positional_args();\n            if (has_kwargs) {\n                if (self.args.length) {\n                    output.print(\".concat(\");\n                }\n                output.print(\"[\");\n                print_kwargs();\n                output.print(\"]\");\n                if (self.args.length) {\n                    output.print(\")\");\n                }\n            }\n            output.print(\")\");\n            if (!is_repeatable) {\n                output.print(\")\");\n            }\n        };\n        if (!print_function_call.__argnames__) Object.defineProperties(print_function_call, {\n            __argnames__ : {value: [\"self\", \"output\"]}\n        });\n\n        ρσ_modules[\"output.functions\"].anonfunc = anonfunc;\n        ρσ_modules[\"output.functions\"].decorate = decorate;\n        ρσ_modules[\"output.functions\"].function_args = function_args;\n        ρσ_modules[\"output.functions\"].function_preamble = function_preamble;\n        ρσ_modules[\"output.functions\"].has_annotations = has_annotations;\n        ρσ_modules[\"output.functions\"].function_annotation = function_annotation;\n        ρσ_modules[\"output.functions\"].function_definition = function_definition;\n        ρσ_modules[\"output.functions\"].print_function = print_function;\n        ρσ_modules[\"output.functions\"].find_this = find_this;\n        ρσ_modules[\"output.functions\"].print_this = print_this;\n        ρσ_modules[\"output.functions\"].print_function_call = print_function_call;\n    })();\n\n    (function(){\n        var __name__ = \"output.classes\";\n        var AST_Class = ρσ_modules.ast.AST_Class;\n        var AST_Method = ρσ_modules.ast.AST_Method;\n        var is_node_type = ρσ_modules.ast.is_node_type;\n\n        var decorate = ρσ_modules[\"output.functions\"].decorate;\n        var function_definition = ρσ_modules[\"output.functions\"].function_definition;\n        var function_annotation = ρσ_modules[\"output.functions\"].function_annotation;\n\n        var create_doctring = ρσ_modules[\"output.utils\"].create_doctring;\n\n        function print_class(output) {\n            var self, seen_methods, property_names, defined_methods, sname, attr, stmt;\n            self = this;\n            if (self.external) {\n                return;\n            }\n            function class_def(method, is_var) {\n                output.indent();\n                self.name.print(output);\n                if (!is_var && method && self.static.indexOf(method) !== -1) {\n                    output.assign(\".\" + method);\n                } else {\n                    if (is_var) {\n                        output.assign(\".prototype[\" + method + \"]\");\n                    } else {\n                        output.assign(\".prototype\" + ((method) ? \".\" + method : \"\"));\n                    }\n                }\n            };\n            if (!class_def.__argnames__) Object.defineProperties(class_def, {\n                __argnames__ : {value: [\"method\", \"is_var\"]}\n            });\n\n            function define_method(stmt, is_property) {\n                var name, is_static, strip_first, fname;\n                name = stmt.name.name;\n                if (!is_property) {\n                    class_def(name);\n                }\n                is_static = self.static.indexOf(name) !== -1;\n                strip_first = !is_static;\n                if (stmt.decorators && stmt.decorators.length) {\n                    decorate(stmt.decorators, output, function () {\n                        function_definition(stmt, output, strip_first, true);\n                    });\n                    output.end_statement();\n                } else {\n                    function_definition(stmt, output, strip_first);\n                    if (!is_property) {\n                        output.end_statement();\n                        fname = self.name.name + ((is_static) ? \".\" : \".prototype.\") + name;\n                        function_annotation(stmt, output, strip_first, fname);\n                    }\n                }\n            };\n            if (!define_method.__argnames__) Object.defineProperties(define_method, {\n                __argnames__ : {value: [\"stmt\", \"is_property\"]}\n            });\n\n            function define_default_method(name, body) {\n                class_def(name);\n                output.spaced(\"function\", name, \"()\", \"\");\n                output.with_block(function () {\n                    [output.indent(), body()];\n                });\n                output.end_statement();\n            };\n            if (!define_default_method.__argnames__) Object.defineProperties(define_default_method, {\n                __argnames__ : {value: [\"name\", \"body\"]}\n            });\n\n            function add_hidden_property(name, proceed) {\n                [output.indent(), output.print(\"Object.defineProperty(\")];\n                [self.name.print(output), output.print(\".prototype\"), output.comma(), output.print(JSON.stringify(name)), \n                output.comma()];\n                [output.spaced(\"{value:\", \"\"), proceed(), output.print(\"})\"), output.end_statement()];\n            };\n            if (!add_hidden_property.__argnames__) Object.defineProperties(add_hidden_property, {\n                __argnames__ : {value: [\"name\", \"proceed\"]}\n            });\n\n            function write_constructor() {\n                output.print(\"function\");\n                output.space();\n                self.name.print(output);\n                output.print(\"()\");\n                output.space();\n                output.with_block(function () {\n                    output.indent();\n                    output.spaced(\"if\", \"(this.ρσ_object_id\", \"===\", \"undefined)\", \"Object.defineProperty(this,\", \"\\\"ρσ_object_id\\\",\", \"{\\\"value\\\":++ρσ_object_counter})\");\n                    output.end_statement();\n                    if (self.bound.length) {\n                        output.indent();\n                        [self.name.print(output), output.print(\".prototype.__bind_methods__.call(this)\")];\n                        output.end_statement();\n                    }\n                    output.indent();\n                    self.name.print(output);\n                    [output.print(\".prototype.__init__.apply(this\"), output.comma(), output.print(\"arguments)\")];\n                    output.end_statement();\n                });\n            };\n\n            if (self.decorators && self.decorators.length) {\n                output.print(\"var \");\n                output.assign(self.name);\n                decorate(self.decorators, output, write_constructor);\n                output.semicolon();\n            } else {\n                write_constructor();\n            }\n            output.newline();\n            if (self.parent) {\n                output.indent();\n                output.print(\"ρσ_extends\");\n                output.with_parens(function () {\n                    self.name.print(output);\n                    output.comma();\n                    self.parent.print(output);\n                });\n                output.end_statement();\n            }\n            if (self.bound.length) {\n                seen_methods = Object.create(null);\n                add_hidden_property(\"__bind_methods__\", function () {\n                    output.spaced(\"function\", \"()\", \"\");\n                    output.with_block(function () {\n                        var base, bname;\n                        if (self.bases.length) {\n                            for (var i = self.bases.length - 1; i >= 0; i--) {\n                                base = (ρσ_expr_temp = self.bases)[(typeof i === \"number\" && i < 0) ? ρσ_expr_temp.length + i : i];\n                                [output.indent(), base.print(output), output.spaced(\".prototype.__bind_methods__\", \"&&\", \"\")];\n                                [base.print(output), output.print(\".prototype.__bind_methods__.call(this)\")];\n                                output.end_statement();\n                            }\n                        }\n                        var ρσ_Iter101 = ρσ_Iterable(self.bound);\n                        for (var ρσ_Index101 = 0; ρσ_Index101 < ρσ_Iter101.length; ρσ_Index101++) {\n                            bname = ρσ_Iter101[ρσ_Index101];\n                            if (seen_methods[(typeof bname === \"number\" && bname < 0) ? seen_methods.length + bname : bname] || (ρσ_expr_temp = self.dynamic_properties)[(typeof bname === \"number\" && bname < 0) ? ρσ_expr_temp.length + bname : bname]) {\n                                continue;\n                            }\n                            seen_methods[(typeof bname === \"number\" && bname < 0) ? seen_methods.length + bname : bname] = true;\n                            [output.indent(), output.assign(\"this.\" + bname)];\n                            [self.name.print(output), output.print(\".prototype.\" + bname + \".bind(this)\")];\n                            output.end_statement();\n                        }\n                    });\n                });\n            }\n            property_names = Object.keys(self.dynamic_properties);\n            if (property_names.length) {\n                output.indent();\n                output.print(\"Object.defineProperties\");\n                output.with_parens(function () {\n                    [self.name.print(output), output.print(\".prototype\"), output.comma(), output.space(), \n                    output.with_block(function () {\n                        var prop, name;\n                        var ρσ_Iter102 = ρσ_Iterable(property_names);\n                        for (var ρσ_Index102 = 0; ρσ_Index102 < ρσ_Iter102.length; ρσ_Index102++) {\n                            name = ρσ_Iter102[ρσ_Index102];\n                            prop = (ρσ_expr_temp = self.dynamic_properties)[(typeof name === \"number\" && name < 0) ? ρσ_expr_temp.length + name : name];\n                            [output.indent(), output.print(JSON.stringify(name) + \":\"), output.space()];\n                            output.with_block(function () {\n                                [output.indent(), output.print(\"\\\"enumerable\\\":\"), output.space(), output.print(\"true\"), \n                                output.comma(), output.newline()];\n                                if (prop.getter) {\n                                    [output.indent(), output.print(\"\\\"get\\\":\"), output.space()];\n                                    [define_method(prop.getter, true), output.comma(), output.newline()];\n                                }\n                                [output.indent(), output.print(\"\\\"set\\\":\"), output.space()];\n                                if (prop.setter) {\n                                    [define_method(prop.setter, true), output.newline()];\n                                } else {\n                                    [output.spaced(\"function\", \"()\", \"{\", \"throw new AttributeError(\\\"can't set attribute\\\")\", \"}\"), \n                                    output.newline()];\n                                }\n                            });\n                            [output.comma(), output.newline()];\n                        }\n                    })];\n                });\n                output.end_statement();\n            }\n            if (!self.init) {\n                define_default_method(\"__init__\", function () {\n                    if (self.parent) {\n                        self.parent.print(output);\n                        output.spaced(\".prototype.__init__\", \"&&\");\n                        [output.space(), self.parent.print(output)];\n                        output.print(\".prototype.__init__.apply\");\n                        output.with_parens(function () {\n                            output.print(\"this\");\n                            output.comma();\n                            output.print(\"arguments\");\n                        });\n                        output.end_statement();\n                    }\n                });\n            }\n            defined_methods = Object.create(null);\n            var ρσ_Iter103 = ρσ_Iterable(self.body);\n            for (var ρσ_Index103 = 0; ρσ_Index103 < ρσ_Iter103.length; ρσ_Index103++) {\n                stmt = ρσ_Iter103[ρσ_Index103];\n                if (is_node_type(stmt, AST_Method)) {\n                    if (stmt.is_getter || stmt.is_setter) {\n                        continue;\n                    }\n                    define_method(stmt);\n                    defined_methods[ρσ_bound_index(stmt.name.name, defined_methods)] = true;\n                    sname = stmt.name.name;\n                    if (sname === \"__init__\") {\n                        var ρσ_Iter104 = ρσ_Iterable(ρσ_list_decorate([ \".__argnames__\", \".__handles_kwarg_interpolation__\" ]));\n                        for (var ρσ_Index104 = 0; ρσ_Index104 < ρσ_Iter104.length; ρσ_Index104++) {\n                            attr = ρσ_Iter104[ρσ_Index104];\n                            [output.indent(), self.name.print(output), output.assign(attr)];\n                            [self.name.print(output), output.print(\".prototype.__init__\" + attr), output.end_statement()];\n                        }\n                    }\n                    if (sname === \"__iter__\") {\n                        class_def(\"ρσ_iterator_symbol\", true);\n                        self.name.print(output);\n                        output.print(\".prototype.\" + stmt.name.name);\n                        output.end_statement();\n                    }\n                } else if (is_node_type(stmt, AST_Class)) {\n                    console.error(\"Nested classes aren't supported yet\");\n                }\n            }\n            if (!defined_methods[\"__repr__\"]) {\n                define_default_method(\"__repr__\", function () {\n                    if (self.parent) {\n                        [output.print(\"if(\"), self.parent.print(output), output.spaced(\".prototype.__repr__)\", \"return\", self.parent)];\n                        [output.print(\".prototype.__repr__.call(this)\"), output.end_statement()];\n                    }\n                    [output.indent(), output.spaced(\"return\", \"\\\"<\\\"\", \"+\", \"__name__\", \"+\", \"\\\".\\\"\", \"+\", \"this.constructor.name\", \"\")];\n                    output.spaced(\"+\", \"\\\" #\\\"\", \"+\", \"this.ρσ_object_id\", \"+\", \"\\\">\\\"\");\n                    output.end_statement();\n                });\n            }\n            if (!defined_methods[\"__str__\"]) {\n                define_default_method(\"__str__\", function () {\n                    if (self.parent) {\n                        [output.print(\"if(\"), self.parent.print(output), output.spaced(\".prototype.__str__)\", \"return\", self.parent)];\n                        [output.print(\".prototype.__str__.call(this)\"), output.end_statement()];\n                    }\n                    output.spaced(\"return\", \"this.__repr__()\");\n                    output.end_statement();\n                });\n            }\n            add_hidden_property(\"__bases__\", function () {\n                output.print(\"[\");\n                for (var i = 0; i < self.bases.length; i++) {\n                    (ρσ_expr_temp = self.bases)[(typeof i === \"number\" && i < 0) ? ρσ_expr_temp.length + i : i].print(output);\n                    if (i < self.bases.length - 1) {\n                        output.comma();\n                    }\n                }\n                output.print(\"]\");\n            });\n            if (self.bases.length > 1) {\n                output.indent();\n                output.print(\"ρσ_mixin(\");\n                self.name.print(output);\n                for (var i = 1; i < self.bases.length; i++) {\n                    output.comma();\n                    (ρσ_expr_temp = self.bases)[(typeof i === \"number\" && i < 0) ? ρσ_expr_temp.length + i : i].print(output);\n                }\n                [output.print(\")\"), output.end_statement()];\n            }\n            if (self.docstrings && self.docstrings.length && output.options.keep_docstrings) {\n                add_hidden_property(\"__doc__\", function () {\n                    output.print(JSON.stringify(create_doctring(self.docstrings)));\n                });\n            }\n            var ρσ_Iter105 = ρσ_Iterable(self.statements);\n            for (var ρσ_Index105 = 0; ρσ_Index105 < ρσ_Iter105.length; ρσ_Index105++) {\n                stmt = ρσ_Iter105[ρσ_Index105];\n                if (!is_node_type(stmt, AST_Method)) {\n                    output.indent();\n                    stmt.print(output);\n                    output.newline();\n                }\n            }\n        };\n        if (!print_class.__argnames__) Object.defineProperties(print_class, {\n            __argnames__ : {value: [\"output\"]}\n        });\n\n        ρσ_modules[\"output.classes\"].print_class = print_class;\n    })();\n\n    (function(){\n        var __name__ = \"output.literals\";\n        var AST_Binary = ρσ_modules.ast.AST_Binary;\n        var is_node_type = ρσ_modules.ast.is_node_type;\n\n        function print_array(self, output) {\n            output.print(\"ρσ_list_decorate\");\n            output.with_parens(function () {\n                output.with_square(function () {\n                    var a, len_, ρσ_unpack, i, exp;\n                    a = self.elements;\n                    len_ = a.length;\n                    if (len_ > 0) {\n                        output.space();\n                    }\n                    var ρσ_Iter106 = ρσ_Iterable(enumerate(a));\n                    for (var ρσ_Index106 = 0; ρσ_Index106 < ρσ_Iter106.length; ρσ_Index106++) {\n                        ρσ_unpack = ρσ_Iter106[ρσ_Index106];\n                        i = ρσ_unpack[0];\n                        exp = ρσ_unpack[1];\n                        if (i) {\n                            output.comma();\n                        }\n                        exp.print(output);\n                    }\n                    if (len_ > 0) {\n                        output.space();\n                    }\n                });\n            });\n        };\n        if (!print_array.__argnames__) Object.defineProperties(print_array, {\n            __argnames__ : {value: [\"self\", \"output\"]}\n        });\n\n        function print_obj_literal(self, output) {\n            output.with_parens(function () {\n                output.print(\"function()\");\n                output.with_block(function () {\n                    var ρσ_unpack, i, prop;\n                    output.indent();\n                    if (self.is_pydict) {\n                        output.spaced.apply(output, \"var ρσ_d = ρσ_dict()\".split(\" \"));\n                    } else {\n                        output.spaced(\"var\", \"ρσ_d\", \"=\", (self.is_jshash) ? \"Object.create(null)\" : \"{}\");\n                    }\n                    output.end_statement();\n                    var ρσ_Iter107 = ρσ_Iterable(enumerate(self.properties));\n                    for (var ρσ_Index107 = 0; ρσ_Index107 < ρσ_Iter107.length; ρσ_Index107++) {\n                        ρσ_unpack = ρσ_Iter107[ρσ_Index107];\n                        i = ρσ_unpack[0];\n                        prop = ρσ_unpack[1];\n                        output.indent();\n                        if (self.is_pydict) {\n                            output.print(\"ρσ_d.set\");\n                            output.with_parens(function () {\n                                prop.key.print(output);\n                                [output.print(\",\"), output.space()];\n                                prop.value.print(output);\n                            });\n                        } else {\n                            output.print(\"ρσ_d\");\n                            output.with_square(function () {\n                                prop.key.print(output);\n                            });\n                            [output.space(), output.print(\"=\"), output.space()];\n                            prop.value.print(output);\n                        }\n                        output.end_statement();\n                    }\n                    output.indent();\n                    output.spaced(\"return\", \"ρσ_d\");\n                    output.end_statement();\n                });\n            });\n            output.print(\".call(this)\");\n        };\n        if (!print_obj_literal.__argnames__) Object.defineProperties(print_obj_literal, {\n            __argnames__ : {value: [\"self\", \"output\"]}\n        });\n\n        function print_object(self, output) {\n            if (self.is_pydict) {\n                if (self.properties.length > 0) {\n                    print_obj_literal(self, output);\n                } else {\n                    output.print(\"ρσ_dict()\");\n                }\n            } else {\n                if (self.properties.length > 0) {\n                    print_obj_literal(self, output);\n                } else {\n                    output.print((self.is_jshash) ? \"Object.create(null)\" : \"{}\");\n                }\n            }\n        };\n        if (!print_object.__argnames__) Object.defineProperties(print_object, {\n            __argnames__ : {value: [\"self\", \"output\"]}\n        });\n\n        function print_set(self, output) {\n            if (self.items.length === 0) {\n                output.print(\"ρσ_set()\");\n                return;\n            }\n            output.with_parens(function () {\n                output.print(\"function()\");\n                output.with_block(function () {\n                    var item;\n                    output.indent();\n                    output.spaced.apply(output, \"var s = ρσ_set()\".split(\" \"));\n                    output.end_statement();\n                    var ρσ_Iter108 = ρσ_Iterable(self.items);\n                    for (var ρσ_Index108 = 0; ρσ_Index108 < ρσ_Iter108.length; ρσ_Index108++) {\n                        item = ρσ_Iter108[ρσ_Index108];\n                        output.indent();\n                        output.print(\"s.jsset.add\");\n                        output.with_parens(function () {\n                            item.value.print(output);\n                        });\n                        output.end_statement();\n                    }\n                    output.indent();\n                    output.spaced(\"return\", \"s\");\n                    output.end_statement();\n                });\n            });\n            output.print(\"()\");\n        };\n        if (!print_set.__argnames__) Object.defineProperties(print_set, {\n            __argnames__ : {value: [\"self\", \"output\"]}\n        });\n\n        function print_regexp(self, output) {\n            var str_, p;\n            str_ = self.value.toString();\n            if (output.option(\"ascii_only\")) {\n                str_ = output.to_ascii(str_);\n            }\n            output.print(str_);\n            p = output.parent();\n            if (is_node_type(p, AST_Binary) && /^in/.test(p.operator) && p.left === self) {\n                output.print(\" \");\n            }\n        };\n        if (!print_regexp.__argnames__) Object.defineProperties(print_regexp, {\n            __argnames__ : {value: [\"self\", \"output\"]}\n        });\n\n        ρσ_modules[\"output.literals\"].print_array = print_array;\n        ρσ_modules[\"output.literals\"].print_obj_literal = print_obj_literal;\n        ρσ_modules[\"output.literals\"].print_object = print_object;\n        ρσ_modules[\"output.literals\"].print_set = print_set;\n        ρσ_modules[\"output.literals\"].print_regexp = print_regexp;\n    })();\n\n    (function(){\n        var __name__ = \"output.modules\";\n        var COMPILER_VERSION = ρσ_modules.parse.COMPILER_VERSION;\n\n        var cache_file_name = ρσ_modules.utils.cache_file_name;\n\n        var declare_vars = ρσ_modules[\"output.statements\"].declare_vars;\n        var display_body = ρσ_modules[\"output.statements\"].display_body;\n\n        var OutputStream = ρσ_modules[\"output.stream\"].OutputStream;\n\n        var create_doctring = ρσ_modules[\"output.utils\"].create_doctring;\n\n        function write_imports(module, output) {\n            var imports, import_id, nonlocalvars, name, module_, module_id;\n            imports = ρσ_list_decorate([]);\n            var ρσ_Iter109 = ρσ_Iterable(Object.keys(module.imports));\n            for (var ρσ_Index109 = 0; ρσ_Index109 < ρσ_Iter109.length; ρσ_Index109++) {\n                import_id = ρσ_Iter109[ρσ_Index109];\n                imports.push((ρσ_expr_temp = module.imports)[(typeof import_id === \"number\" && import_id < 0) ? ρσ_expr_temp.length + import_id : import_id]);\n            }\n            imports.sort((function() {\n                var ρσ_anonfunc = function (a, b) {\n                    var ρσ_unpack;\n                    ρσ_unpack = [a.import_order, b.import_order];\n                    a = ρσ_unpack[0];\n                    b = ρσ_unpack[1];\n                    return (a < b) ? -1 : (a > b) ? 1 : 0;\n                };\n                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                    __argnames__ : {value: [\"a\", \"b\"]}\n                });\n                return ρσ_anonfunc;\n            })());\n            if (imports.length > 1) {\n                output.indent();\n                output.print(\"var ρσ_modules = {};\");\n                output.newline();\n            }\n            nonlocalvars = Object.create(null);\n            var ρσ_Iter110 = ρσ_Iterable(imports);\n            for (var ρσ_Index110 = 0; ρσ_Index110 < ρσ_Iter110.length; ρσ_Index110++) {\n                module_ = ρσ_Iter110[ρσ_Index110];\n                var ρσ_Iter111 = ρσ_Iterable(module_.nonlocalvars);\n                for (var ρσ_Index111 = 0; ρσ_Index111 < ρσ_Iter111.length; ρσ_Index111++) {\n                    name = ρσ_Iter111[ρσ_Index111];\n                    nonlocalvars[(typeof name === \"number\" && name < 0) ? nonlocalvars.length + name : name] = true;\n                }\n            }\n            nonlocalvars = Object.getOwnPropertyNames(nonlocalvars).join(\", \");\n            if (nonlocalvars.length) {\n                output.indent();\n                output.print(\"var \" + nonlocalvars);\n                output.semicolon();\n                output.newline();\n            }\n            var ρσ_Iter112 = ρσ_Iterable(imports);\n            for (var ρσ_Index112 = 0; ρσ_Index112 < ρσ_Iter112.length; ρσ_Index112++) {\n                module_ = ρσ_Iter112[ρσ_Index112];\n                module_id = module_.module_id;\n                if (module_id !== \"__main__\") {\n                    output.indent();\n                    if (module_id.indexOf(\".\") === -1) {\n                        output.print(\"ρσ_modules.\" + module_id);\n                    } else {\n                        output.print(\"ρσ_modules[\\\"\" + module_id + \"\\\"]\");\n                    }\n                    [output.space(), output.print(\"=\"), output.space(), output.print(\"{}\")];\n                    output.end_statement();\n                }\n            }\n            var ρσ_Iter113 = ρσ_Iterable(imports);\n            for (var ρσ_Index113 = 0; ρσ_Index113 < ρσ_Iter113.length; ρσ_Index113++) {\n                module_ = ρσ_Iter113[ρσ_Index113];\n                if (module_.module_id !== \"__main__\") {\n                    print_module(module_, output);\n                }\n            }\n        };\n        if (!write_imports.__argnames__) Object.defineProperties(write_imports, {\n            __argnames__ : {value: [\"module\", \"output\"]}\n        });\n\n        function write_main_name(output) {\n            if (output.option(\"write_name\")) {\n                output.newline();\n                output.indent();\n                output.print(\"var __name__ = \\\"__main__\\\"\");\n                output.semicolon();\n                output.newline();\n                output.newline();\n            }\n        };\n        if (!write_main_name.__argnames__) Object.defineProperties(write_main_name, {\n            __argnames__ : {value: [\"output\"]}\n        });\n\n        function const_decl(js_version) {\n            return \"var\";\n        };\n        if (!const_decl.__argnames__) Object.defineProperties(const_decl, {\n            __argnames__ : {value: [\"js_version\"]}\n        });\n\n        function declare_exports(module_id, exports, output, docstrings) {\n            var seen, v, symbol;\n            seen = Object.create(null);\n            if (output.option(\"keep_docstrings\") && docstrings && docstrings.length) {\n                exports.push((function(){\n                    var ρσ_d = Object.create(null);\n                    ρσ_d[\"name\"] = \"__doc__\";\n                    ρσ_d[\"refname\"] = \"ρσ_module_doc__\";\n                    return ρσ_d;\n                }).call(this));\n                [output.newline(), output.indent()];\n                v = const_decl(output.js_version);\n                [output.assign(v + \" ρσ_module_doc__\"), output.print(JSON.stringify(create_doctring(docstrings)))];\n                output.end_statement();\n            }\n            output.newline();\n            var ρσ_Iter114 = ρσ_Iterable(exports);\n            for (var ρσ_Index114 = 0; ρσ_Index114 < ρσ_Iter114.length; ρσ_Index114++) {\n                symbol = ρσ_Iter114[ρσ_Index114];\n                if (!Object.prototype.hasOwnProperty.call(seen, symbol.name)) {\n                    output.indent();\n                    if (module_id.indexOf(\".\") === -1) {\n                        output.print(\"ρσ_modules.\" + module_id + \".\" + symbol.name);\n                    } else {\n                        output.print(\"ρσ_modules[\\\"\" + module_id + \"\\\"].\" + symbol.name);\n                    }\n                    [output.space(), output.print(\"=\"), output.space(), output.print(symbol.refname || symbol.name)];\n                    seen[ρσ_bound_index(symbol.name, seen)] = true;\n                    output.end_statement();\n                }\n            }\n        };\n        if (!declare_exports.__argnames__) Object.defineProperties(declare_exports, {\n            __argnames__ : {value: [\"module_id\", \"exports\", \"output\", \"docstrings\"]}\n        });\n\n        function prologue(module, output) {\n            var v, needs_yield;\n            if (output.options.omit_baselib) {\n                return;\n            }\n            output.indent();\n            v = const_decl(output.js_version);\n            [output.print(v), output.space()];\n            output.spaced.apply(output, \"ρσ_iterator_symbol = (typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\") ? Symbol.iterator : \\\"iterator-Symbol-5d0927e5554349048cf0e3762a228256\\\"\".split(\" \"));\n            output.end_statement();\n            [output.indent(), output.print(v), output.space()];\n            output.spaced.apply(output, \"ρσ_kwargs_symbol = (typeof Symbol === \\\"function\\\") ? Symbol(\\\"kwargs-object\\\") : \\\"kwargs-object-Symbol-5d0927e5554349048cf0e3762a228256\\\"\".split(\" \"));\n            output.end_statement();\n            [output.indent(), output.spaced(\"var\", \"ρσ_cond_temp,\", \"ρσ_expr_temp,\", \"ρσ_last_exception\"), \n            output.end_statement()];\n            [output.indent(), output.spaced(\"var\", \"ρσ_object_counter\", \"=\", \"0\"), output.end_statement()];\n            if (output.options.js_version > 5) {\n                [output.indent(), output.spaced(\"if(\", \"typeof\", \"HTMLCollection\", \"!==\", \"\\\"undefined\\\"\", \"&&\", \"typeof\", \"Symbol\", \"===\", \"\\\"function\\\")\", \"NodeList.prototype[Symbol.iterator]\", \"=\", \"HTMLCollection.prototype[Symbol.iterator]\", \"=\", \"NamedNodeMap.prototype[Symbol.iterator]\", \"=\", \"Array.prototype[Symbol.iterator]\")];\n                output.end_statement();\n            }\n            needs_yield = output.options.js_version < 6 && module.baselib[\"yield\"];\n            if (needs_yield) {\n                output.dump_yield();\n            }\n            if (!output.options.baselib_plain) {\n                throw new ValueError(\"The baselib is missing! Remember to set the baselib_plain field on the options for OutputStream\");\n            }\n            output.print(output.options.baselib_plain);\n            output.end_statement();\n        };\n        if (!prologue.__argnames__) Object.defineProperties(prologue, {\n            __argnames__ : {value: [\"module\", \"output\"]}\n        });\n\n        function print_top_level(self, output) {\n            var is_main;\n            is_main = output.is_main();\n            function write_docstrings() {\n                var v;\n                if (is_main && output.option(\"keep_docstrings\") && self.docstrings && self.docstrings.length) {\n                    [output.newline(), output.indent()];\n                    v = const_decl(output.js_version);\n                    [output.assign(v + \" ρσ_module_doc__\"), output.print(JSON.stringify(create_doctring(self.docstrings)))];\n                    output.end_statement();\n                }\n            };\n\n            if (output.option(\"private_scope\") && is_main) {\n                output.with_parens(function () {\n                    output.print(\"function()\");\n                    output.with_block(function () {\n                        output.indent();\n                        output.print(\"\\\"use strict\\\"\");\n                        output.end_statement();\n                        prologue(self, output);\n                        write_imports(self, output);\n                        output.newline();\n                        output.indent();\n                        output.with_parens(function () {\n                            output.print(\"function()\");\n                            output.with_block(function () {\n                                write_main_name(output);\n                                output.newline();\n                                declare_vars(self.localvars, output);\n                                display_body(self.body, true, output);\n                                output.newline();\n                                write_docstrings();\n                            });\n                        });\n                        output.print(\"();\");\n                        output.newline();\n                    });\n                });\n                output.print(\"();\");\n                output.print(\"\");\n            } else {\n                if (is_main) {\n                    prologue(self, output);\n                    write_imports(self, output);\n                    write_main_name(output);\n                }\n                declare_vars(self.localvars, output);\n                display_body(self.body, true, output);\n            }\n        };\n        if (!print_top_level.__argnames__) Object.defineProperties(print_top_level, {\n            __argnames__ : {value: [\"self\", \"output\"]}\n        });\n\n        function print_module(self, output) {\n            function output_module(output) {\n                declare_vars(self.localvars, output);\n                display_body(self.body, true, output);\n                declare_exports(self.module_id, self.exports, output, self.docstrings);\n            };\n            if (!output_module.__argnames__) Object.defineProperties(output_module, {\n                __argnames__ : {value: [\"output\"]}\n            });\n\n            output.newline();\n            output.indent();\n            output.with_parens(function () {\n                output.print(\"function()\");\n                output.with_block(function () {\n                    var okey, cached, cobj, cname, symdef, co, raw, js_version, keep_docstrings, beautify;\n                    if (output.option(\"write_name\")) {\n                        output.indent();\n                        output.print(\"var \");\n                        output.assign(\"__name__\");\n                        output.print(\"\\\"\" + self.module_id + \"\\\"\");\n                        output.semicolon();\n                        output.newline();\n                    }\n                    function output_key(beautify, keep_docstrings, js_version) {\n                        return \"beautify:\" + beautify + \" keep_docstrings:\" + keep_docstrings + \" js_version:\" + js_version;\n                    };\n                    if (!output_key.__argnames__) Object.defineProperties(output_key, {\n                        __argnames__ : {value: [\"beautify\", \"keep_docstrings\", \"js_version\"]}\n                    });\n\n                    okey = output_key(output.option(\"beautify\"), output.option(\"keep_docstrings\"), output.option(\"js_version\"));\n                    if (self.is_cached && ρσ_in(okey, self.outputs)) {\n                        output.print((ρσ_expr_temp = self.outputs)[(typeof okey === \"number\" && okey < 0) ? ρσ_expr_temp.length + okey : okey]);\n                    } else {\n                        output_module(output);\n                        if (self.srchash && self.filename) {\n                            cached = (function(){\n                                var ρσ_d = Object.create(null);\n                                ρσ_d[\"version\"] = COMPILER_VERSION;\n                                ρσ_d[\"signature\"] = self.srchash;\n                                ρσ_d[\"classes\"] = Object.create(null);\n                                ρσ_d[\"baselib\"] = self.baselib;\n                                ρσ_d[\"nonlocalvars\"] = self.nonlocalvars;\n                                ρσ_d[\"imported_module_ids\"] = self.imported_module_ids;\n                                ρσ_d[\"exports\"] = ρσ_list_decorate([]);\n                                ρσ_d[\"outputs\"] = Object.create(null);\n                                ρσ_d[\"discard_asserts\"] = output.options.discard_asserts;\n                                return ρσ_d;\n                            }).call(this);\n                            var ρσ_Iter115 = ρσ_Iterable(Object.keys(self.classes));\n                            for (var ρσ_Index115 = 0; ρσ_Index115 < ρσ_Iter115.length; ρσ_Index115++) {\n                                cname = ρσ_Iter115[ρσ_Index115];\n                                cobj = (ρσ_expr_temp = self.classes)[(typeof cname === \"number\" && cname < 0) ? ρσ_expr_temp.length + cname : cname];\n                                (ρσ_expr_temp = cached.classes)[(typeof cname === \"number\" && cname < 0) ? ρσ_expr_temp.length + cname : cname] = (function(){\n                                    var ρσ_d = Object.create(null);\n                                    ρσ_d[\"name\"] = (function(){\n                                        var ρσ_d = Object.create(null);\n                                        ρσ_d[\"name\"] = cobj.name.name;\n                                        return ρσ_d;\n                                    }).call(this);\n                                    ρσ_d[\"static\"] = cobj.static;\n                                    ρσ_d[\"bound\"] = cobj.bound;\n                                    ρσ_d[\"classvars\"] = cobj.classvars;\n                                    return ρσ_d;\n                                }).call(this);\n                            }\n                            var ρσ_Iter116 = ρσ_Iterable(self.exports);\n                            for (var ρσ_Index116 = 0; ρσ_Index116 < ρσ_Iter116.length; ρσ_Index116++) {\n                                symdef = ρσ_Iter116[ρσ_Index116];\n                                cached.exports.push((function(){\n                                    var ρσ_d = Object.create(null);\n                                    ρσ_d[\"name\"] = symdef.name;\n                                    return ρσ_d;\n                                }).call(this));\n                            }\n                            var ρσ_Iter117 = ρσ_Iterable(ρσ_list_decorate([ true, false ]));\n                            for (var ρσ_Index117 = 0; ρσ_Index117 < ρσ_Iter117.length; ρσ_Index117++) {\n                                beautify = ρσ_Iter117[ρσ_Index117];\n                                var ρσ_Iter118 = ρσ_Iterable(ρσ_list_decorate([ true, false ]));\n                                for (var ρσ_Index118 = 0; ρσ_Index118 < ρσ_Iter118.length; ρσ_Index118++) {\n                                    keep_docstrings = ρσ_Iter118[ρσ_Index118];\n                                    var ρσ_Iter119 = ρσ_Iterable(ρσ_list_decorate([ 5, 6 ]));\n                                    for (var ρσ_Index119 = 0; ρσ_Index119 < ρσ_Iter119.length; ρσ_Index119++) {\n                                        js_version = ρσ_Iter119[ρσ_Index119];\n                                        co = new OutputStream((function(){\n                                            var ρσ_d = Object.create(null);\n                                            ρσ_d[\"beautify\"] = beautify;\n                                            ρσ_d[\"keep_docstrings\"] = keep_docstrings;\n                                            ρσ_d[\"js_version\"] = js_version;\n                                            ρσ_d[\"private_scope\"] = false;\n                                            ρσ_d[\"write_name\"] = false;\n                                            ρσ_d[\"discard_asserts\"] = output.options.discard_asserts;\n                                            return ρσ_d;\n                                        }).call(this));\n                                        co.with_indent(output.indentation(), function () {\n                                            output_module(co);\n                                        });\n                                        raw = co.get();\n                                        (ρσ_expr_temp = cached.outputs)[ρσ_bound_index(output_key(beautify, keep_docstrings, js_version), ρσ_expr_temp)] = raw;\n                                    }\n                                }\n                            }\n                            try {\n                                writefile(cache_file_name(self.filename, output.options.module_cache_dir), JSON.stringify(cached, null, \"\\t\"));\n                            } catch (ρσ_Exception) {\n                                ρσ_last_exception = ρσ_Exception;\n                                if (ρσ_Exception instanceof Error) {\n                                    var e = ρσ_Exception;\n                                    console.error(\"Failed to write output cache file:\", self.filename + \"-cached\", \"with error:\", e);\n                                } else {\n                                    throw ρσ_Exception;\n                                }\n                            }\n                        }\n                    }\n                });\n            });\n            output.print(\"()\");\n            output.semicolon();\n            output.newline();\n        };\n        if (!print_module.__argnames__) Object.defineProperties(print_module, {\n            __argnames__ : {value: [\"self\", \"output\"]}\n        });\n\n        function print_imports(container, output) {\n            var is_first_aname, akey, argname, parts, q, ρσ_unpack, i, part, self;\n            is_first_aname = true;\n            function add_aname(aname, key, from_import) {\n                if (is_first_aname) {\n                    is_first_aname = false;\n                } else {\n                    output.indent();\n                }\n                output.print(\"var \");\n                output.assign(aname);\n                if (key.indexOf(\".\") === -1) {\n                    [output.print(\"ρσ_modules.\"), output.print(key)];\n                } else {\n                    [output.print(\"ρσ_modules[\\\"\"), output.print(key), output.print(\"\\\"]\")];\n                }\n                if (from_import) {\n                    output.print(\".\");\n                    output.print(from_import);\n                }\n                output.end_statement();\n            };\n            if (!add_aname.__argnames__) Object.defineProperties(add_aname, {\n                __argnames__ : {value: [\"aname\", \"key\", \"from_import\"]}\n            });\n\n            var ρσ_Iter120 = ρσ_Iterable(container.imports);\n            for (var ρσ_Index120 = 0; ρσ_Index120 < ρσ_Iter120.length; ρσ_Index120++) {\n                self = ρσ_Iter120[ρσ_Index120];\n                output.import_(self.module);\n                if (self.argnames) {\n                    var ρσ_Iter121 = ρσ_Iterable(self.argnames);\n                    for (var ρσ_Index121 = 0; ρσ_Index121 < ρσ_Iter121.length; ρσ_Index121++) {\n                        argname = ρσ_Iter121[ρσ_Index121];\n                        akey = (argname.alias) ? argname.alias.name : argname.name;\n                        add_aname(akey, self.key, argname.name);\n                    }\n                } else {\n                    if (self.alias) {\n                        add_aname(self.alias.name, self.key, false);\n                    } else {\n                        parts = self.key.split(\".\");\n                        var ρσ_Iter122 = ρσ_Iterable(enumerate(parts));\n                        for (var ρσ_Index122 = 0; ρσ_Index122 < ρσ_Iter122.length; ρσ_Index122++) {\n                            ρσ_unpack = ρσ_Iter122[ρσ_Index122];\n                            i = ρσ_unpack[0];\n                            part = ρσ_unpack[1];\n                            if (i === 0) {\n                                add_aname(part, part, false);\n                            } else {\n                                q = parts.slice(0, i + 1).join(\".\");\n                                output.indent();\n                                output.spaced(q, \"=\", \"ρσ_modules[\\\"\" + q + \"\\\"]\");\n                                output.end_statement();\n                            }\n                        }\n                    }\n                }\n            }\n        };\n        if (!print_imports.__argnames__) Object.defineProperties(print_imports, {\n            __argnames__ : {value: [\"container\", \"output\"]}\n        });\n\n        ρσ_modules[\"output.modules\"].write_imports = write_imports;\n        ρσ_modules[\"output.modules\"].write_main_name = write_main_name;\n        ρσ_modules[\"output.modules\"].const_decl = const_decl;\n        ρσ_modules[\"output.modules\"].declare_exports = declare_exports;\n        ρσ_modules[\"output.modules\"].prologue = prologue;\n        ρσ_modules[\"output.modules\"].print_top_level = print_top_level;\n        ρσ_modules[\"output.modules\"].print_module = print_module;\n        ρσ_modules[\"output.modules\"].print_imports = print_imports;\n    })();\n\n    (function(){\n        var __name__ = \"output.codegen\";\n        var noop = ρσ_modules.utils.noop;\n\n        var PRECEDENCE = ρσ_modules.parse.PRECEDENCE;\n\n        var AST_Array = ρσ_modules.ast.AST_Array;\n        var AST_Assign = ρσ_modules.ast.AST_Assign;\n        var AST_BaseCall = ρσ_modules.ast.AST_BaseCall;\n        var AST_Binary = ρσ_modules.ast.AST_Binary;\n        var AST_BlockStatement = ρσ_modules.ast.AST_BlockStatement;\n        var AST_Break = ρσ_modules.ast.AST_Break;\n        var AST_Catch = ρσ_modules.ast.AST_Catch;\n        var AST_Class = ρσ_modules.ast.AST_Class;\n        var AST_Conditional = ρσ_modules.ast.AST_Conditional;\n        var AST_Constant = ρσ_modules.ast.AST_Constant;\n        var AST_Continue = ρσ_modules.ast.AST_Continue;\n        var AST_Debugger = ρσ_modules.ast.AST_Debugger;\n        var AST_Definitions = ρσ_modules.ast.AST_Definitions;\n        var AST_Directive = ρσ_modules.ast.AST_Directive;\n        var AST_Do = ρσ_modules.ast.AST_Do;\n        var AST_Dot = ρσ_modules.ast.AST_Dot;\n        var is_node_type = ρσ_modules.ast.is_node_type;\n        var AST_EmptyStatement = ρσ_modules.ast.AST_EmptyStatement;\n        var AST_Exit = ρσ_modules.ast.AST_Exit;\n        var AST_ExpressiveObject = ρσ_modules.ast.AST_ExpressiveObject;\n        var AST_Finally = ρσ_modules.ast.AST_Finally;\n        var AST_ForIn = ρσ_modules.ast.AST_ForIn;\n        var AST_ForJS = ρσ_modules.ast.AST_ForJS;\n        var AST_Function = ρσ_modules.ast.AST_Function;\n        var AST_Hole = ρσ_modules.ast.AST_Hole;\n        var AST_If = ρσ_modules.ast.AST_If;\n        var AST_Imports = ρσ_modules.ast.AST_Imports;\n        var AST_Infinity = ρσ_modules.ast.AST_Infinity;\n        var AST_Lambda = ρσ_modules.ast.AST_Lambda;\n        var AST_ListComprehension = ρσ_modules.ast.AST_ListComprehension;\n        var AST_LoopControl = ρσ_modules.ast.AST_LoopControl;\n        var AST_NaN = ρσ_modules.ast.AST_NaN;\n        var AST_New = ρσ_modules.ast.AST_New;\n        var AST_Node = ρσ_modules.ast.AST_Node;\n        var AST_Number = ρσ_modules.ast.AST_Number;\n        var AST_Object = ρσ_modules.ast.AST_Object;\n        var AST_ObjectKeyVal = ρσ_modules.ast.AST_ObjectKeyVal;\n        var AST_ObjectProperty = ρσ_modules.ast.AST_ObjectProperty;\n        var AST_PropAccess = ρσ_modules.ast.AST_PropAccess;\n        var AST_RegExp = ρσ_modules.ast.AST_RegExp;\n        var AST_Return = ρσ_modules.ast.AST_Return;\n        var AST_Set = ρσ_modules.ast.AST_Set;\n        var AST_Seq = ρσ_modules.ast.AST_Seq;\n        var AST_SimpleStatement = ρσ_modules.ast.AST_SimpleStatement;\n        var AST_Splice = ρσ_modules.ast.AST_Splice;\n        var AST_Statement = ρσ_modules.ast.AST_Statement;\n        var AST_StatementWithBody = ρσ_modules.ast.AST_StatementWithBody;\n        var AST_String = ρσ_modules.ast.AST_String;\n        var AST_Sub = ρσ_modules.ast.AST_Sub;\n        var AST_ItemAccess = ρσ_modules.ast.AST_ItemAccess;\n        var AST_Symbol = ρσ_modules.ast.AST_Symbol;\n        var AST_This = ρσ_modules.ast.AST_This;\n        var AST_Throw = ρσ_modules.ast.AST_Throw;\n        var AST_Toplevel = ρσ_modules.ast.AST_Toplevel;\n        var AST_Try = ρσ_modules.ast.AST_Try;\n        var AST_Unary = ρσ_modules.ast.AST_Unary;\n        var AST_UnaryPrefix = ρσ_modules.ast.AST_UnaryPrefix;\n        var AST_Undefined = ρσ_modules.ast.AST_Undefined;\n        var AST_Var = ρσ_modules.ast.AST_Var;\n        var AST_VarDef = ρσ_modules.ast.AST_VarDef;\n        var AST_Assert = ρσ_modules.ast.AST_Assert;\n        var AST_Verbatim = ρσ_modules.ast.AST_Verbatim;\n        var AST_While = ρσ_modules.ast.AST_While;\n        var AST_With = ρσ_modules.ast.AST_With;\n        var AST_Yield = ρσ_modules.ast.AST_Yield;\n        var TreeWalker = ρσ_modules.ast.TreeWalker;\n        var AST_Existential = ρσ_modules.ast.AST_Existential;\n\n        var print_try = ρσ_modules[\"output.exceptions\"].print_try;\n        var print_catch = ρσ_modules[\"output.exceptions\"].print_catch;\n        var print_finally = ρσ_modules[\"output.exceptions\"].print_finally;\n\n        var print_class = ρσ_modules[\"output.classes\"].print_class;\n\n        var print_array = ρσ_modules[\"output.literals\"].print_array;\n        var print_obj_literal = ρσ_modules[\"output.literals\"].print_obj_literal;\n        var print_object = ρσ_modules[\"output.literals\"].print_object;\n        var print_set = ρσ_modules[\"output.literals\"].print_set;\n        var print_regexp = ρσ_modules[\"output.literals\"].print_regexp;\n\n        var print_do_loop = ρσ_modules[\"output.loops\"].print_do_loop;\n        var print_while_loop = ρσ_modules[\"output.loops\"].print_while_loop;\n        var print_for_loop_body = ρσ_modules[\"output.loops\"].print_for_loop_body;\n        var print_for_in = ρσ_modules[\"output.loops\"].print_for_in;\n        var print_list_comprehension = ρσ_modules[\"output.loops\"].print_list_comprehension;\n\n        var print_top_level = ρσ_modules[\"output.modules\"].print_top_level;\n        var print_imports = ρσ_modules[\"output.modules\"].print_imports;\n\n        var print_getattr = ρσ_modules[\"output.operators\"].print_getattr;\n        var print_getitem = ρσ_modules[\"output.operators\"].print_getitem;\n        var print_rich_getitem = ρσ_modules[\"output.operators\"].print_rich_getitem;\n        var print_splice_assignment = ρσ_modules[\"output.operators\"].print_splice_assignment;\n        var print_unary_prefix = ρσ_modules[\"output.operators\"].print_unary_prefix;\n        var print_binary_op = ρσ_modules[\"output.operators\"].print_binary_op;\n        var print_assign = ρσ_modules[\"output.operators\"].print_assign;\n        var print_conditional = ρσ_modules[\"output.operators\"].print_conditional;\n        var print_seq = ρσ_modules[\"output.operators\"].print_seq;\n        var print_existential = ρσ_modules[\"output.operators\"].print_existential;\n\n        var print_function = ρσ_modules[\"output.functions\"].print_function;\n        var print_function_call = ρσ_modules[\"output.functions\"].print_function_call;\n\n        var print_bracketed = ρσ_modules[\"output.statements\"].print_bracketed;\n        var first_in_statement = ρσ_modules[\"output.statements\"].first_in_statement;\n        var force_statement = ρσ_modules[\"output.statements\"].force_statement;\n        var print_with = ρσ_modules[\"output.statements\"].print_with;\n        var print_assert = ρσ_modules[\"output.statements\"].print_assert;\n\n        var make_block = ρσ_modules[\"output.utils\"].make_block;\n        var make_num = ρσ_modules[\"output.utils\"].make_num;\n\n        function generate_code() {\n            function DEFPRINT(nodetype, generator) {\n                nodetype.prototype._codegen = generator;\n            };\n            if (!DEFPRINT.__argnames__) Object.defineProperties(DEFPRINT, {\n                __argnames__ : {value: [\"nodetype\", \"generator\"]}\n            });\n\n            AST_Node.prototype.print = (function() {\n                var ρσ_anonfunc = function (stream, force_parens) {\n                    var self, generator;\n                    self = this;\n                    generator = self._codegen;\n                    stream.push_node(self);\n                    if (force_parens || self.needs_parens(stream)) {\n                        stream.with_parens(function () {\n                            self.add_comments(stream);\n                            generator(self, stream);\n                        });\n                    } else {\n                        self.add_comments(stream);\n                        generator(self, stream);\n                    }\n                    stream.pop_node();\n                };\n                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                    __argnames__ : {value: [\"stream\", \"force_parens\"]}\n                });\n                return ρσ_anonfunc;\n            })();\n            AST_Node.prototype.add_comments = (function() {\n                var ρσ_anonfunc = function (output) {\n                    var c, self, start, comments, comm;\n                    c = output.option(\"comments\");\n                    self = this;\n                    if (c) {\n                        start = self.start;\n                        if (start && !start._comments_dumped) {\n                            start._comments_dumped = true;\n                            comments = start.comments_before;\n                            if (is_node_type(self, AST_Exit) && self.value && self.value.start.comments_before && self.value.start.comments_before.length > 0) {\n                                comments = (comments || ρσ_list_decorate([])).concat(self.value.start.comments_before);\n                                self.value.start.comments_before = ρσ_list_decorate([]);\n                            }\n                            if (c.test) {\n                                comments = comments.filter((function() {\n                                    var ρσ_anonfunc = function (comment) {\n                                        return c.test(comment.value);\n                                    };\n                                    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                                        __argnames__ : {value: [\"comment\"]}\n                                    });\n                                    return ρσ_anonfunc;\n                                })());\n                            } else if (typeof c === \"function\") {\n                                comments = comments.filter((function() {\n                                    var ρσ_anonfunc = function (comment) {\n                                        return c(self, comment);\n                                    };\n                                    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                                        __argnames__ : {value: [\"comment\"]}\n                                    });\n                                    return ρσ_anonfunc;\n                                })());\n                            }\n                            var ρσ_Iter123 = ρσ_Iterable(comments);\n                            for (var ρσ_Index123 = 0; ρσ_Index123 < ρσ_Iter123.length; ρσ_Index123++) {\n                                comm = ρσ_Iter123[ρσ_Index123];\n                                if (comm.type === \"comment1\") {\n                                    output.print(\"//\" + comm.value + \"\\n\");\n                                    output.indent();\n                                } else if (comm.type === \"comment2\") {\n                                    output.print(\"/*\" + comm.value + \"*/\");\n                                    if (start.nlb) {\n                                        output.print(\"\\n\");\n                                        output.indent();\n                                    } else {\n                                        output.space();\n                                    }\n                                }\n                            }\n                        }\n                    }\n                };\n                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                    __argnames__ : {value: [\"output\"]}\n                });\n                return ρσ_anonfunc;\n            })();\n            function PARENS(nodetype, func) {\n                nodetype.prototype.needs_parens = func;\n            };\n            if (!PARENS.__argnames__) Object.defineProperties(PARENS, {\n                __argnames__ : {value: [\"nodetype\", \"func\"]}\n            });\n\n            PARENS(AST_Node, function () {\n                return false;\n            });\n            PARENS(AST_Function, (function() {\n                var ρσ_anonfunc = function (output) {\n                    return first_in_statement(output);\n                };\n                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                    __argnames__ : {value: [\"output\"]}\n                });\n                return ρσ_anonfunc;\n            })());\n            PARENS(AST_Object, (function() {\n                var ρσ_anonfunc = function (output) {\n                    return first_in_statement(output);\n                };\n                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                    __argnames__ : {value: [\"output\"]}\n                });\n                return ρσ_anonfunc;\n            })());\n            PARENS(AST_Unary, (function() {\n                var ρσ_anonfunc = function (output) {\n                    var p;\n                    p = output.parent();\n                    return is_node_type(p, AST_PropAccess) && p.expression === this;\n                };\n                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                    __argnames__ : {value: [\"output\"]}\n                });\n                return ρσ_anonfunc;\n            })());\n            PARENS(AST_Seq, (function() {\n                var ρσ_anonfunc = function (output) {\n                    var p;\n                    p = output.parent();\n                    return is_node_type(p, AST_Unary) || is_node_type(p, AST_VarDef) || is_node_type(p, AST_Dot) || is_node_type(p, AST_ObjectProperty) || is_node_type(p, AST_Conditional);\n                };\n                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                    __argnames__ : {value: [\"output\"]}\n                });\n                return ρσ_anonfunc;\n            })());\n            PARENS(AST_Binary, (function() {\n                var ρσ_anonfunc = function (output) {\n                    var p, po, pp, so, sp;\n                    p = output.parent();\n                    if (is_node_type(p, AST_BaseCall) && p.expression === this) {\n                        return true;\n                    }\n                    if (is_node_type(p, AST_Unary)) {\n                        return true;\n                    }\n                    if (is_node_type(p, AST_PropAccess) && p.expression === this) {\n                        return true;\n                    }\n                    if (is_node_type(p, AST_Binary)) {\n                        po = p.operator;\n                        pp = PRECEDENCE[(typeof po === \"number\" && po < 0) ? PRECEDENCE.length + po : po];\n                        so = this.operator;\n                        sp = PRECEDENCE[(typeof so === \"number\" && so < 0) ? PRECEDENCE.length + so : so];\n                        if (pp > sp || pp === sp && this === p.right && !(so === po && (so === \"*\" || so === \"&&\" || so === \"||\"))) {\n                            return true;\n                        }\n                    }\n                };\n                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                    __argnames__ : {value: [\"output\"]}\n                });\n                return ρσ_anonfunc;\n            })());\n            PARENS(AST_PropAccess, (function() {\n                var ρσ_anonfunc = function (output) {\n                    var p;\n                    p = output.parent();\n                    if (is_node_type(p, AST_New) && p.expression === this) {\n                        try {\n                            this.walk(new TreeWalker((function() {\n                                var ρσ_anonfunc = function (node) {\n                                    if (is_node_type(node, AST_BaseCall)) {\n                                        throw p;\n                                    }\n                                };\n                                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                                    __argnames__ : {value: [\"node\"]}\n                                });\n                                return ρσ_anonfunc;\n                            })()));\n                        } catch (ρσ_Exception) {\n                            ρσ_last_exception = ρσ_Exception;\n                            {\n                                var ex = ρσ_Exception;\n                                if (ex !== p) {\n                                    throw ex;\n                                }\n                                return true;\n                            } \n                        }\n                    }\n                };\n                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                    __argnames__ : {value: [\"output\"]}\n                });\n                return ρσ_anonfunc;\n            })());\n            PARENS(AST_BaseCall, (function() {\n                var ρσ_anonfunc = function (output) {\n                    var p;\n                    p = output.parent();\n                    return is_node_type(p, AST_New) && p.expression === this;\n                };\n                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                    __argnames__ : {value: [\"output\"]}\n                });\n                return ρσ_anonfunc;\n            })());\n            PARENS(AST_New, (function() {\n                var ρσ_anonfunc = function (output) {\n                    var p;\n                    p = output.parent();\n                    if (this.args.length === 0 && (is_node_type(p, AST_PropAccess) || is_node_type(p, AST_BaseCall) && p.expression === this)) {\n                        return true;\n                    }\n                };\n                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                    __argnames__ : {value: [\"output\"]}\n                });\n                return ρσ_anonfunc;\n            })());\n            PARENS(AST_Number, (function() {\n                var ρσ_anonfunc = function (output) {\n                    var p;\n                    p = output.parent();\n                    if (this.value < 0 && is_node_type(p, AST_PropAccess) && p.expression === this) {\n                        return true;\n                    }\n                };\n                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                    __argnames__ : {value: [\"output\"]}\n                });\n                return ρσ_anonfunc;\n            })());\n            PARENS(AST_NaN, (function() {\n                var ρσ_anonfunc = function (output) {\n                    var p;\n                    p = output.parent();\n                    if (is_node_type(p, AST_PropAccess) && p.expression === this) {\n                        return true;\n                    }\n                };\n                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                    __argnames__ : {value: [\"output\"]}\n                });\n                return ρσ_anonfunc;\n            })());\n            function assign_and_conditional_paren_rules(output) {\n                var p;\n                p = output.parent();\n                if (is_node_type(p, AST_Unary)) {\n                    return true;\n                }\n                if (is_node_type(p, AST_Binary) && !is_node_type(p, AST_Assign)) {\n                    return true;\n                }\n                if (is_node_type(p, AST_BaseCall) && p.expression === this) {\n                    return true;\n                }\n                if (is_node_type(p, AST_Conditional) && p.condition === this) {\n                    return true;\n                }\n                if (is_node_type(p, AST_PropAccess) && p.expression === this) {\n                    return true;\n                }\n            };\n            if (!assign_and_conditional_paren_rules.__argnames__) Object.defineProperties(assign_and_conditional_paren_rules, {\n                __argnames__ : {value: [\"output\"]}\n            });\n\n            PARENS(AST_Assign, assign_and_conditional_paren_rules);\n            PARENS(AST_Conditional, assign_and_conditional_paren_rules);\n            DEFPRINT(AST_Directive, (function() {\n                var ρσ_anonfunc = function (self, output) {\n                    output.print_string(self.value);\n                    output.semicolon();\n                };\n                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                    __argnames__ : {value: [\"self\", \"output\"]}\n                });\n                return ρσ_anonfunc;\n            })());\n            DEFPRINT(AST_Debugger, (function() {\n                var ρσ_anonfunc = function (self, output) {\n                    output.print(\"debugger\");\n                    output.semicolon();\n                };\n                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                    __argnames__ : {value: [\"self\", \"output\"]}\n                });\n                return ρσ_anonfunc;\n            })());\n            AST_StatementWithBody.prototype._do_print_body = (function() {\n                var ρσ_anonfunc = function (output) {\n                    force_statement(this.body, output);\n                };\n                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                    __argnames__ : {value: [\"output\"]}\n                });\n                return ρσ_anonfunc;\n            })();\n            DEFPRINT(AST_Statement, (function() {\n                var ρσ_anonfunc = function (self, output) {\n                    self.body.print(output);\n                    output.semicolon();\n                };\n                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                    __argnames__ : {value: [\"self\", \"output\"]}\n                });\n                return ρσ_anonfunc;\n            })());\n            DEFPRINT(AST_Toplevel, print_top_level);\n            DEFPRINT(AST_Imports, print_imports);\n            DEFPRINT(AST_SimpleStatement, (function() {\n                var ρσ_anonfunc = function (self, output) {\n                    if (!is_node_type(self.body, AST_EmptyStatement)) {\n                        self.body.print(output);\n                        output.semicolon();\n                    }\n                };\n                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                    __argnames__ : {value: [\"self\", \"output\"]}\n                });\n                return ρσ_anonfunc;\n            })());\n            DEFPRINT(AST_BlockStatement, (function() {\n                var ρσ_anonfunc = function (self, output) {\n                    print_bracketed(self, output);\n                };\n                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                    __argnames__ : {value: [\"self\", \"output\"]}\n                });\n                return ρσ_anonfunc;\n            })());\n            DEFPRINT(AST_EmptyStatement, (function() {\n                var ρσ_anonfunc = function (self, output) {\n                };\n                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                    __argnames__ : {value: [\"self\", \"output\"]}\n                });\n                return ρσ_anonfunc;\n            })());\n            DEFPRINT(AST_Do, print_do_loop);\n            DEFPRINT(AST_While, print_while_loop);\n            AST_ForIn.prototype._do_print_body = print_for_loop_body;\n            DEFPRINT(AST_ForIn, print_for_in);\n            AST_ForJS.prototype._do_print_body = (function() {\n                var ρσ_anonfunc = function (output) {\n                    var self;\n                    self = this;\n                    output.with_block(function () {\n                        var stmt;\n                        var ρσ_Iter124 = ρσ_Iterable(self.body.body);\n                        for (var ρσ_Index124 = 0; ρσ_Index124 < ρσ_Iter124.length; ρσ_Index124++) {\n                            stmt = ρσ_Iter124[ρσ_Index124];\n                            output.indent();\n                            stmt.print(output);\n                            output.newline();\n                        }\n                    });\n                };\n                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                    __argnames__ : {value: [\"output\"]}\n                });\n                return ρσ_anonfunc;\n            })();\n            DEFPRINT(AST_ForJS, (function() {\n                var ρσ_anonfunc = function (self, output) {\n                    output.print(\"for\");\n                    output.space();\n                    output.with_parens(function () {\n                        self.condition.print(output);\n                    });\n                    output.space();\n                    self._do_print_body(output);\n                };\n                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                    __argnames__ : {value: [\"self\", \"output\"]}\n                });\n                return ρσ_anonfunc;\n            })());\n            DEFPRINT(AST_ListComprehension, print_list_comprehension);\n            DEFPRINT(AST_With, print_with);\n            DEFPRINT(AST_Assert, print_assert);\n            AST_Lambda.prototype._do_print = print_function;\n            DEFPRINT(AST_Lambda, (function() {\n                var ρσ_anonfunc = function (self, output) {\n                    self._do_print(output);\n                };\n                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                    __argnames__ : {value: [\"self\", \"output\"]}\n                });\n                return ρσ_anonfunc;\n            })());\n            AST_Class.prototype._do_print = print_class;\n            DEFPRINT(AST_Class, (function() {\n                var ρσ_anonfunc = function (self, output) {\n                    self._do_print(output);\n                };\n                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                    __argnames__ : {value: [\"self\", \"output\"]}\n                });\n                return ρσ_anonfunc;\n            })());\n            AST_Exit.prototype._do_print = (function() {\n                var ρσ_anonfunc = function (output, kind) {\n                    var self;\n                    self = this;\n                    output.print(kind);\n                    if (self.value) {\n                        output.space();\n                        self.value.print(output);\n                    }\n                    output.semicolon();\n                };\n                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                    __argnames__ : {value: [\"output\", \"kind\"]}\n                });\n                return ρσ_anonfunc;\n            })();\n            DEFPRINT(AST_Yield, (function() {\n                var ρσ_anonfunc = function (self, output) {\n                    self._do_print(output, \"yield\" + ((self.is_yield_from) ? \"*\" : \"\"));\n                };\n                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                    __argnames__ : {value: [\"self\", \"output\"]}\n                });\n                return ρσ_anonfunc;\n            })());\n            DEFPRINT(AST_Return, (function() {\n                var ρσ_anonfunc = function (self, output) {\n                    self._do_print(output, \"return\");\n                };\n                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                    __argnames__ : {value: [\"self\", \"output\"]}\n                });\n                return ρσ_anonfunc;\n            })());\n            DEFPRINT(AST_Throw, (function() {\n                var ρσ_anonfunc = function (self, output) {\n                    self._do_print(output, \"throw\");\n                };\n                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                    __argnames__ : {value: [\"self\", \"output\"]}\n                });\n                return ρσ_anonfunc;\n            })());\n            AST_LoopControl.prototype._do_print = (function() {\n                var ρσ_anonfunc = function (output, kind) {\n                    output.print(kind);\n                    if (this.label) {\n                        output.space();\n                        this.label.print(output);\n                    }\n                    output.semicolon();\n                };\n                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                    __argnames__ : {value: [\"output\", \"kind\"]}\n                });\n                return ρσ_anonfunc;\n            })();\n            DEFPRINT(AST_Break, (function() {\n                var ρσ_anonfunc = function (self, output) {\n                    self._do_print(output, \"break\");\n                };\n                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                    __argnames__ : {value: [\"self\", \"output\"]}\n                });\n                return ρσ_anonfunc;\n            })());\n            DEFPRINT(AST_Continue, (function() {\n                var ρσ_anonfunc = function (self, output) {\n                    self._do_print(output, \"continue\");\n                };\n                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                    __argnames__ : {value: [\"self\", \"output\"]}\n                });\n                return ρσ_anonfunc;\n            })());\n            function make_then(self, output) {\n                var b;\n                if (output.option(\"bracketize\")) {\n                    make_block(self.body, output);\n                    return;\n                }\n                if (!self.body) {\n                    return output.force_semicolon();\n                }\n                if (is_node_type(self.body, AST_Do) && output.option(\"ie_proof\")) {\n                    make_block(self.body, output);\n                    return;\n                }\n                b = self.body;\n                while (true) {\n                    if (is_node_type(b, AST_If)) {\n                        if (!b.alternative) {\n                            make_block(self.body, output);\n                            return;\n                        }\n                        b = b.alternative;\n                    } else if (is_node_type(b, AST_StatementWithBody)) {\n                        b = b.body;\n                    } else {\n                        break;\n                    }\n                }\n                force_statement(self.body, output);\n            };\n            if (!make_then.__argnames__) Object.defineProperties(make_then, {\n                __argnames__ : {value: [\"self\", \"output\"]}\n            });\n\n            DEFPRINT(AST_If, (function() {\n                var ρσ_anonfunc = function (self, output) {\n                    output.print(\"if\");\n                    output.space();\n                    output.with_parens(function () {\n                        self.condition.print(output);\n                    });\n                    output.space();\n                    if (self.alternative) {\n                        make_then(self, output);\n                        output.space();\n                        output.print(\"else\");\n                        output.space();\n                        force_statement(self.alternative, output);\n                    } else {\n                        self._do_print_body(output);\n                    }\n                };\n                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                    __argnames__ : {value: [\"self\", \"output\"]}\n                });\n                return ρσ_anonfunc;\n            })());\n            DEFPRINT(AST_Try, print_try);\n            DEFPRINT(AST_Catch, print_catch);\n            DEFPRINT(AST_Finally, print_finally);\n            AST_Definitions.prototype._do_print = (function() {\n                var ρσ_anonfunc = function (output, kind) {\n                    var ρσ_unpack, i, def_, p, in_for, avoid_semicolon;\n                    output.print(kind);\n                    output.space();\n                    var ρσ_Iter125 = ρσ_Iterable(enumerate(this.definitions));\n                    for (var ρσ_Index125 = 0; ρσ_Index125 < ρσ_Iter125.length; ρσ_Index125++) {\n                        ρσ_unpack = ρσ_Iter125[ρσ_Index125];\n                        i = ρσ_unpack[0];\n                        def_ = ρσ_unpack[1];\n                        if (i) {\n                            output.comma();\n                        }\n                        def_.print(output);\n                    }\n                    p = output.parent();\n                    in_for = is_node_type(p, AST_ForIn);\n                    avoid_semicolon = in_for && p.init === this;\n                    if (!avoid_semicolon) {\n                        output.semicolon();\n                    }\n                };\n                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                    __argnames__ : {value: [\"output\", \"kind\"]}\n                });\n                return ρσ_anonfunc;\n            })();\n            DEFPRINT(AST_Var, (function() {\n                var ρσ_anonfunc = function (self, output) {\n                    self._do_print(output, \"var\");\n                };\n                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                    __argnames__ : {value: [\"self\", \"output\"]}\n                });\n                return ρσ_anonfunc;\n            })());\n            function parenthesize_for_noin(node, output, noin) {\n                if (!noin) {\n                    node.print(output);\n                } else {\n                    try {\n                        node.walk(new TreeWalker((function() {\n                            var ρσ_anonfunc = function (node) {\n                                if (is_node_type(node, AST_Binary) && node.operator === \"in\") {\n                                    throw output;\n                                }\n                            };\n                            if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                                __argnames__ : {value: [\"node\"]}\n                            });\n                            return ρσ_anonfunc;\n                        })()));\n                        node.print(output);\n                    } catch (ρσ_Exception) {\n                        ρσ_last_exception = ρσ_Exception;\n                        {\n                            var ex = ρσ_Exception;\n                            if (ex !== output) {\n                                throw ex;\n                            }\n                            node.print(output, true);\n                        } \n                    }\n                }\n            };\n            if (!parenthesize_for_noin.__argnames__) Object.defineProperties(parenthesize_for_noin, {\n                __argnames__ : {value: [\"node\", \"output\", \"noin\"]}\n            });\n\n            DEFPRINT(AST_VarDef, (function() {\n                var ρσ_anonfunc = function (self, output) {\n                    var p, noin;\n                    self.name.print(output);\n                    if (self.value) {\n                        output.assign(\"\");\n                        p = output.parent(1);\n                        noin = is_node_type(p, AST_ForIn);\n                        parenthesize_for_noin(self.value, output, noin);\n                    }\n                };\n                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                    __argnames__ : {value: [\"self\", \"output\"]}\n                });\n                return ρσ_anonfunc;\n            })());\n            DEFPRINT(AST_BaseCall, print_function_call);\n            AST_Seq.prototype._do_print = print_seq;\n            DEFPRINT(AST_Seq, (function() {\n                var ρσ_anonfunc = function (self, output) {\n                    self._do_print(output);\n                };\n                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                    __argnames__ : {value: [\"self\", \"output\"]}\n                });\n                return ρσ_anonfunc;\n            })());\n            DEFPRINT(AST_Dot, print_getattr);\n            DEFPRINT(AST_Sub, print_getitem);\n            DEFPRINT(AST_ItemAccess, print_rich_getitem);\n            DEFPRINT(AST_Splice, print_splice_assignment);\n            DEFPRINT(AST_UnaryPrefix, print_unary_prefix);\n            DEFPRINT(AST_Binary, print_binary_op);\n            DEFPRINT(AST_Existential, print_existential);\n            DEFPRINT(AST_Assign, print_assign);\n            DEFPRINT(AST_Conditional, print_conditional);\n            DEFPRINT(AST_Array, print_array);\n            DEFPRINT(AST_ExpressiveObject, print_obj_literal);\n            DEFPRINT(AST_Object, print_object);\n            DEFPRINT(AST_ObjectKeyVal, (function() {\n                var ρσ_anonfunc = function (self, output) {\n                    self.key.print(output);\n                    output.colon();\n                    self.value.print(output);\n                };\n                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                    __argnames__ : {value: [\"self\", \"output\"]}\n                });\n                return ρσ_anonfunc;\n            })());\n            DEFPRINT(AST_Set, print_set);\n            AST_Symbol.prototype.definition = function () {\n                return this.thedef;\n            };\n            DEFPRINT(AST_Symbol, (function() {\n                var ρσ_anonfunc = function (self, output) {\n                    var def_;\n                    def_ = self.definition();\n                    output.print_name((def_) ? def_.mangled_name || def_.name : self.name);\n                };\n                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                    __argnames__ : {value: [\"self\", \"output\"]}\n                });\n                return ρσ_anonfunc;\n            })());\n            DEFPRINT(AST_Undefined, (function() {\n                var ρσ_anonfunc = function (self, output) {\n                    output.print(\"void 0\");\n                };\n                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                    __argnames__ : {value: [\"self\", \"output\"]}\n                });\n                return ρσ_anonfunc;\n            })());\n            DEFPRINT(AST_Hole, noop);\n            DEFPRINT(AST_Infinity, (function() {\n                var ρσ_anonfunc = function (self, output) {\n                    output.print(\"1/0\");\n                };\n                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                    __argnames__ : {value: [\"self\", \"output\"]}\n                });\n                return ρσ_anonfunc;\n            })());\n            DEFPRINT(AST_NaN, (function() {\n                var ρσ_anonfunc = function (self, output) {\n                    output.print(\"0/0\");\n                };\n                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                    __argnames__ : {value: [\"self\", \"output\"]}\n                });\n                return ρσ_anonfunc;\n            })());\n            DEFPRINT(AST_This, (function() {\n                var ρσ_anonfunc = function (self, output) {\n                    output.print(\"this\");\n                };\n                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                    __argnames__ : {value: [\"self\", \"output\"]}\n                });\n                return ρσ_anonfunc;\n            })());\n            DEFPRINT(AST_Constant, (function() {\n                var ρσ_anonfunc = function (self, output) {\n                    output.print(self.value);\n                };\n                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                    __argnames__ : {value: [\"self\", \"output\"]}\n                });\n                return ρσ_anonfunc;\n            })());\n            DEFPRINT(AST_String, (function() {\n                var ρσ_anonfunc = function (self, output) {\n                    output.print_string(self.value);\n                };\n                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                    __argnames__ : {value: [\"self\", \"output\"]}\n                });\n                return ρσ_anonfunc;\n            })());\n            DEFPRINT(AST_Verbatim, (function() {\n                var ρσ_anonfunc = function (self, output) {\n                    output.print(self.value);\n                };\n                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                    __argnames__ : {value: [\"self\", \"output\"]}\n                });\n                return ρσ_anonfunc;\n            })());\n            DEFPRINT(AST_Number, (function() {\n                var ρσ_anonfunc = function (self, output) {\n                    output.print(make_num(self.value));\n                };\n                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                    __argnames__ : {value: [\"self\", \"output\"]}\n                });\n                return ρσ_anonfunc;\n            })());\n            DEFPRINT(AST_RegExp, print_regexp);\n        };\n\n        ρσ_modules[\"output.codegen\"].generate_code = generate_code;\n    })();\n\n    (function(){\n\n        var __name__ = \"__main__\";\n\n\n        var ast, ast_node;\n        var DefaultsError = ρσ_modules.utils.DefaultsError;\n        var string_template = ρσ_modules.utils.string_template;\n\n        var ImportError = ρσ_modules.errors.ImportError;\n        var SyntaxError = ρσ_modules.errors.SyntaxError;\n\n        var ALL_KEYWORDS = ρσ_modules.tokenizer.ALL_KEYWORDS;\n        var IDENTIFIER_PAT = ρσ_modules.tokenizer.IDENTIFIER_PAT;\n        var tokenizer = ρσ_modules.tokenizer.tokenizer;\n\n        var parse = ρσ_modules.parse.parse;\n        var NATIVE_CLASSES = ρσ_modules.parse.NATIVE_CLASSES;\n        var compile_time_decorators = ρσ_modules.parse.compile_time_decorators;\n\n        var OutputStream = ρσ_modules[\"output.stream\"].OutputStream;\n\n        var generate_code = ρσ_modules[\"output.codegen\"].generate_code;\n\n        generate_code();\n        if (typeof exports === \"object\") {\n            exports.DefaultsError = DefaultsError;\n            exports.parse = parse;\n            exports.compile_time_decorators = compile_time_decorators;\n            exports.OutputStream = OutputStream;\n            exports.string_template = string_template;\n            exports.ALL_KEYWORDS = ALL_KEYWORDS;\n            exports.IDENTIFIER_PAT = IDENTIFIER_PAT;\n            exports.NATIVE_CLASSES = NATIVE_CLASSES;\n            exports.ImportError = ImportError;\n            exports.SyntaxError = SyntaxError;\n            exports.tokenizer = tokenizer;\n            ast = ρσ_modules[\"ast\"];\n            var ρσ_Iter126 = ρσ_Iterable(ast);\n            for (var ρσ_Index126 = 0; ρσ_Index126 < ρσ_Iter126.length; ρσ_Index126++) {\n                ast_node = ρσ_Iter126[ρσ_Index126];\n                if (ast_node.substr(0, 4) === \"AST_\") {\n                    exports[(typeof ast_node === \"number\" && ast_node < 0) ? exports.length + ast_node : ast_node] = ast[(typeof ast_node === \"number\" && ast_node < 0) ? ast.length + ast_node : ast_node];\n                }\n            }\n        }\n    })();\n})();","baselib-plain-pretty.js":"var ρσ_len;\nfunction ρσ_bool(val) {\n    return !!val;\n};\nif (!ρσ_bool.__argnames__) Object.defineProperties(ρσ_bool, {\n    __argnames__ : {value: [\"val\"]}\n});\n\nfunction ρσ_print() {\n    var parts;\n    if (typeof console === \"object\") {\n        parts = [];\n        for (var i = 0; i < arguments.length; i++) {\n            parts.push(ρσ_str(arguments[(typeof i === \"number\" && i < 0) ? arguments.length + i : i]));\n        }\n        console.log(parts.join(\" \"));\n    }\n};\n\nfunction ρσ_int(val, base) {\n    var ans;\n    ans = parseInt(val, base || 10);\n    if (isNaN(ans)) {\n        throw new ValueError(\"Invalid literal for int with base \" + (base || 10) + \": \" + val);\n    }\n    return ans;\n};\nif (!ρσ_int.__argnames__) Object.defineProperties(ρσ_int, {\n    __argnames__ : {value: [\"val\", \"base\"]}\n});\n\nfunction ρσ_float() {\n    var ans;\n    ans = parseFloat.apply(null, arguments);\n    if (isNaN(ans)) {\n        throw new ValueError(\"Could not convert string to float: \" + arguments[0]);\n    }\n    return ans;\n};\n\nfunction ρσ_arraylike_creator() {\n    var names;\n    names = \"Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array\".split(\" \");\n    if (typeof HTMLCollection === \"function\") {\n        names = names.concat(\"HTMLCollection NodeList NamedNodeMap\".split(\" \"));\n    }\n    return (function() {\n        var ρσ_anonfunc = function (x) {\n            if (Array.isArray(x) || typeof x === \"string\" || names.indexOf(Object.prototype.toString.call(x).slice(8, -1)) > -1) {\n                return true;\n            }\n            return false;\n        };\n        if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n            __argnames__ : {value: [\"x\"]}\n        });\n        return ρσ_anonfunc;\n    })();\n};\n\nfunction options_object(f) {\n    return function () {\n        if (typeof arguments[arguments.length - 1] === \"object\") {\n            arguments[ρσ_bound_index(arguments.length - 1, arguments)][ρσ_kwargs_symbol] = true;\n        }\n        return f.apply(this, arguments);\n    };\n};\nif (!options_object.__argnames__) Object.defineProperties(options_object, {\n    __argnames__ : {value: [\"f\"]}\n});\n\nfunction ρσ_id(x) {\n    return x.ρσ_object_id;\n};\nif (!ρσ_id.__argnames__) Object.defineProperties(ρσ_id, {\n    __argnames__ : {value: [\"x\"]}\n});\n\nfunction ρσ_dir(item) {\n    var arr;\n    arr = ρσ_list_decorate([]);\n    for (var i in item) {\n        arr.push(i);\n    }\n    return arr;\n};\nif (!ρσ_dir.__argnames__) Object.defineProperties(ρσ_dir, {\n    __argnames__ : {value: [\"item\"]}\n});\n\nfunction ρσ_ord(x) {\n    var ans, second;\n    ans = x.charCodeAt(0);\n    if (55296 <= ans && ans <= 56319) {\n        second = x.charCodeAt(1);\n        if (56320 <= second && second <= 57343) {\n            return (ans - 55296) * 1024 + second - 56320 + 65536;\n        }\n        throw new TypeError(\"string is missing the low surrogate char\");\n    }\n    return ans;\n};\nif (!ρσ_ord.__argnames__) Object.defineProperties(ρσ_ord, {\n    __argnames__ : {value: [\"x\"]}\n});\n\nfunction ρσ_chr(code) {\n    if (code <= 65535) {\n        return String.fromCharCode(code);\n    }\n    code -= 65536;\n    return String.fromCharCode(55296 + (code >> 10), 56320 + (code & 1023));\n};\nif (!ρσ_chr.__argnames__) Object.defineProperties(ρσ_chr, {\n    __argnames__ : {value: [\"code\"]}\n});\n\nfunction ρσ_callable(x) {\n    return typeof x === \"function\";\n};\nif (!ρσ_callable.__argnames__) Object.defineProperties(ρσ_callable, {\n    __argnames__ : {value: [\"x\"]}\n});\n\nfunction ρσ_bin(x) {\n    var ans;\n    if (typeof x !== \"number\" || x % 1 !== 0) {\n        throw new TypeError(\"integer required\");\n    }\n    ans = x.toString(2);\n    if (ans[0] === \"-\") {\n        ans = \"-\" + \"0b\" + ans.slice(1);\n    } else {\n        ans = \"0b\" + ans;\n    }\n    return ans;\n};\nif (!ρσ_bin.__argnames__) Object.defineProperties(ρσ_bin, {\n    __argnames__ : {value: [\"x\"]}\n});\n\nfunction ρσ_hex(x) {\n    var ans;\n    if (typeof x !== \"number\" || x % 1 !== 0) {\n        throw new TypeError(\"integer required\");\n    }\n    ans = x.toString(16);\n    if (ans[0] === \"-\") {\n        ans = \"-\" + \"0x\" + ans.slice(1);\n    } else {\n        ans = \"0x\" + ans;\n    }\n    return ans;\n};\nif (!ρσ_hex.__argnames__) Object.defineProperties(ρσ_hex, {\n    __argnames__ : {value: [\"x\"]}\n});\n\nfunction ρσ_enumerate(iterable) {\n    var ans, iterator;\n    ans = {\"_i\":-1};\n    ans[ρσ_iterator_symbol] = function () {\n        return this;\n    };\n    if (ρσ_arraylike(iterable)) {\n        ans[\"next\"] = function () {\n            this._i += 1;\n            if (this._i < iterable.length) {\n                return {'done':false, 'value':[this._i, iterable[this._i]]};\n            }\n            return {'done':true};\n        };\n        return ans;\n    }\n    if (typeof iterable[ρσ_iterator_symbol] === \"function\") {\n        iterator = (typeof Map === \"function\" && iterable instanceof Map) ? iterable.keys() : iterable[ρσ_iterator_symbol]();\n        ans[\"_iterator\"] = iterator;\n        ans[\"next\"] = function () {\n            var r;\n            r = this._iterator.next();\n            if (r.done) {\n                return {'done':true};\n            }\n            this._i += 1;\n            return {'done':false, 'value':[this._i, r.value]};\n        };\n        return ans;\n    }\n    return ρσ_enumerate(Object.keys(iterable));\n};\nif (!ρσ_enumerate.__argnames__) Object.defineProperties(ρσ_enumerate, {\n    __argnames__ : {value: [\"iterable\"]}\n});\n\nfunction ρσ_reversed(iterable) {\n    var ans;\n    if (ρσ_arraylike(iterable)) {\n        ans = {\"_i\": iterable.length};\n        ans[\"next\"] = function () {\n            this._i -= 1;\n            if (this._i > -1) {\n                return {'done':false, 'value':iterable[this._i]};\n            }\n            return {'done':true};\n        };\n        ans[ρσ_iterator_symbol] = function () {\n            return this;\n        };\n        return ans;\n    }\n    throw new TypeError(\"reversed() can only be called on arrays or strings\");\n};\nif (!ρσ_reversed.__argnames__) Object.defineProperties(ρσ_reversed, {\n    __argnames__ : {value: [\"iterable\"]}\n});\n\nfunction ρσ_iter(iterable) {\n    var ans;\n    if (typeof iterable[ρσ_iterator_symbol] === \"function\") {\n        return (typeof Map === \"function\" && iterable instanceof Map) ? iterable.keys() : iterable[ρσ_iterator_symbol]();\n    }\n    if (ρσ_arraylike(iterable)) {\n        ans = {\"_i\":-1};\n        ans[ρσ_iterator_symbol] = function () {\n            return this;\n        };\n        ans[\"next\"] = function () {\n            this._i += 1;\n            if (this._i < iterable.length) {\n                return {'done':false, 'value':iterable[this._i]};\n            }\n            return {'done':true};\n        };\n        return ans;\n    }\n    return ρσ_iter(Object.keys(iterable));\n};\nif (!ρσ_iter.__argnames__) Object.defineProperties(ρσ_iter, {\n    __argnames__ : {value: [\"iterable\"]}\n});\n\nfunction ρσ_range_next(step, length) {\n    var ρσ_unpack;\n    this._i += step;\n    this._idx += 1;\n    if (this._idx >= length) {\n        ρσ_unpack = [this.__i, -1];\n        this._i = ρσ_unpack[0];\n        this._idx = ρσ_unpack[1];\n        return {'done':true};\n    }\n    return {'done':false, 'value':this._i};\n};\nif (!ρσ_range_next.__argnames__) Object.defineProperties(ρσ_range_next, {\n    __argnames__ : {value: [\"step\", \"length\"]}\n});\n\nfunction ρσ_range(start, stop, step) {\n    var length, ans;\n    if (arguments.length <= 1) {\n        stop = start || 0;\n        start = 0;\n    }\n    step = arguments[2] || 1;\n    length = Math.max(Math.ceil((stop - start) / step), 0);\n    ans = {start:start, step:step, stop:stop};\n    ans[ρσ_iterator_symbol] = function () {\n        var it;\n        it = {\"_i\": start - step, \"_idx\": -1};\n        it.next = ρσ_range_next.bind(it, step, length);\n        it[ρσ_iterator_symbol] = function () {\n            return this;\n        };\n        return it;\n    };\n    ans.count = (function() {\n        var ρσ_anonfunc = function (val) {\n            if (!this._cached) {\n                this._cached = list(this);\n            }\n            return this._cached.count(val);\n        };\n        if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n            __argnames__ : {value: [\"val\"]}\n        });\n        return ρσ_anonfunc;\n    })();\n    ans.index = (function() {\n        var ρσ_anonfunc = function (val) {\n            if (!this._cached) {\n                this._cached = list(this);\n            }\n            return this._cached.index(val);\n        };\n        if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n            __argnames__ : {value: [\"val\"]}\n        });\n        return ρσ_anonfunc;\n    })();\n    if (typeof Proxy === \"function\") {\n        ans = new Proxy(ans, (function(){\n            var ρσ_d = {};\n            ρσ_d[\"get\"] = (function() {\n                var ρσ_anonfunc = function (obj, prop) {\n                    var iprop;\n                    if (typeof prop === \"string\") {\n                        iprop = parseInt(prop);\n                        if (!isNaN(iprop)) {\n                            prop = iprop;\n                        }\n                    }\n                    if (typeof prop === \"number\") {\n                        if (!obj._cached) {\n                            obj._cached = list(obj);\n                        }\n                        return (ρσ_expr_temp = obj._cached)[(typeof prop === \"number\" && prop < 0) ? ρσ_expr_temp.length + prop : prop];\n                    }\n                    return obj[(typeof prop === \"number\" && prop < 0) ? obj.length + prop : prop];\n                };\n                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                    __argnames__ : {value: [\"obj\", \"prop\"]}\n                });\n                return ρσ_anonfunc;\n            })();\n            return ρσ_d;\n        }).call(this));\n    }\n    return ans;\n};\nif (!ρσ_range.__argnames__) Object.defineProperties(ρσ_range, {\n    __argnames__ : {value: [\"start\", \"stop\", \"step\"]}\n});\n\nfunction ρσ_getattr(obj, name, defval) {\n    var ret;\n    try {\n        ret = obj[(typeof name === \"number\" && name < 0) ? obj.length + name : name];\n    } catch (ρσ_Exception) {\n        ρσ_last_exception = ρσ_Exception;\n        if (ρσ_Exception instanceof TypeError) {\n            if (defval === undefined) {\n                throw new AttributeError(\"The attribute \" + name + \" is not present\");\n            }\n            return defval;\n        } else {\n            throw ρσ_Exception;\n        }\n    }\n    if (ret === undefined && !(name in obj)) {\n        if (defval === undefined) {\n            throw new AttributeError(\"The attribute \" + name + \" is not present\");\n        }\n        ret = defval;\n    }\n    return ret;\n};\nif (!ρσ_getattr.__argnames__) Object.defineProperties(ρσ_getattr, {\n    __argnames__ : {value: [\"obj\", \"name\", \"defval\"]}\n});\n\nfunction ρσ_setattr(obj, name, value) {\n    obj[(typeof name === \"number\" && name < 0) ? obj.length + name : name] = value;\n};\nif (!ρσ_setattr.__argnames__) Object.defineProperties(ρσ_setattr, {\n    __argnames__ : {value: [\"obj\", \"name\", \"value\"]}\n});\n\nfunction ρσ_hasattr(obj, name) {\n    return name in obj;\n};\nif (!ρσ_hasattr.__argnames__) Object.defineProperties(ρσ_hasattr, {\n    __argnames__ : {value: [\"obj\", \"name\"]}\n});\n\nρσ_len = function () {\n    function len(obj) {\n        if (ρσ_arraylike(obj)) {\n            return obj.length;\n        }\n        if (typeof obj.__len__ === \"function\") {\n            return obj.__len__();\n        }\n        if (obj instanceof Set || obj instanceof Map) {\n            return obj.size;\n        }\n        return Object.keys(obj).length;\n    };\n    if (!len.__argnames__) Object.defineProperties(len, {\n        __argnames__ : {value: [\"obj\"]}\n    });\n\n    function len5(obj) {\n        if (ρσ_arraylike(obj)) {\n            return obj.length;\n        }\n        if (typeof obj.__len__ === \"function\") {\n            return obj.__len__();\n        }\n        return Object.keys(obj).length;\n    };\n    if (!len5.__argnames__) Object.defineProperties(len5, {\n        __argnames__ : {value: [\"obj\"]}\n    });\n\n    return (typeof Set === \"function\" && typeof Map === \"function\") ? len : len5;\n}();\nfunction ρσ_get_module(name) {\n    return ρσ_modules[(typeof name === \"number\" && name < 0) ? ρσ_modules.length + name : name];\n};\nif (!ρσ_get_module.__argnames__) Object.defineProperties(ρσ_get_module, {\n    __argnames__ : {value: [\"name\"]}\n});\n\nfunction ρσ_pow(x, y, z) {\n    var ans;\n    ans = Math.pow(x, y);\n    if (z !== undefined) {\n        ans %= z;\n    }\n    return ans;\n};\nif (!ρσ_pow.__argnames__) Object.defineProperties(ρσ_pow, {\n    __argnames__ : {value: [\"x\", \"y\", \"z\"]}\n});\n\nfunction ρσ_type(x) {\n    return x.constructor;\n};\nif (!ρσ_type.__argnames__) Object.defineProperties(ρσ_type, {\n    __argnames__ : {value: [\"x\"]}\n});\n\nfunction ρσ_divmod(x, y) {\n    var d;\n    if (y === 0) {\n        throw new ZeroDivisionError(\"integer division or modulo by zero\");\n    }\n    d = Math.floor(x / y);\n    return [d, x - d * y];\n};\nif (!ρσ_divmod.__argnames__) Object.defineProperties(ρσ_divmod, {\n    __argnames__ : {value: [\"x\", \"y\"]}\n});\n\nfunction ρσ_max() {\n    var kwargs = arguments[arguments.length-1];\n    if (kwargs === null || typeof kwargs !== \"object\" || kwargs [ρσ_kwargs_symbol] !== true) kwargs = {};\n    var args = Array.prototype.slice.call(arguments, 0);\n    if (kwargs !== null && typeof kwargs === \"object\" && kwargs [ρσ_kwargs_symbol] === true) args.pop();\n    var args, x;\n    if (args.length === 0) {\n        if (kwargs.defval !== undefined) {\n            return kwargs.defval;\n        }\n        throw new TypeError(\"expected at least one argument\");\n    }\n    if (args.length === 1) {\n        args = args[0];\n    }\n    if (kwargs.key) {\n        args = (function() {\n            var ρσ_Iter = ρσ_Iterable(args), ρσ_Result = [], x;\n            for (var ρσ_Index = 0; ρσ_Index < ρσ_Iter.length; ρσ_Index++) {\n                x = ρσ_Iter[ρσ_Index];\n                ρσ_Result.push(kwargs.key(x));\n            }\n            ρσ_Result = ρσ_list_constructor(ρσ_Result);\n            return ρσ_Result;\n        })();\n    }\n    if (!Array.isArray(args)) {\n        args = list(args);\n    }\n    if (args.length) {\n        return this.apply(null, args);\n    }\n    if (kwargs.defval !== undefined) {\n        return kwargs.defval;\n    }\n    throw new TypeError(\"expected at least one argument\");\n};\nif (!ρσ_max.__handles_kwarg_interpolation__) Object.defineProperties(ρσ_max, {\n    __handles_kwarg_interpolation__ : {value: true}\n});\n\nvar abs = Math.abs, max = ρσ_max.bind(Math.max), min = ρσ_max.bind(Math.min), bool = ρσ_bool, type = ρσ_type;\nvar float = ρσ_float, int = ρσ_int, arraylike = ρσ_arraylike_creator(), ρσ_arraylike = arraylike;\nvar print = ρσ_print, id = ρσ_id, get_module = ρσ_get_module, pow = ρσ_pow, divmod = ρσ_divmod;\nvar dir = ρσ_dir, ord = ρσ_ord, chr = ρσ_chr, bin = ρσ_bin, hex = ρσ_hex, callable = ρσ_callable;\nvar enumerate = ρσ_enumerate, iter = ρσ_iter, reversed = ρσ_reversed, len = ρσ_len;\nvar range = ρσ_range, getattr = ρσ_getattr, setattr = ρσ_setattr, hasattr = ρσ_hasattr;function ρσ_equals(a, b) {\n    var ρσ_unpack, akeys, bkeys, key;\n    if (a === b) {\n        return true;\n    }\n    if (a && typeof a.__eq__ === \"function\") {\n        return a.__eq__(b);\n    }\n    if (b && typeof b.__eq__ === \"function\") {\n        return b.__eq__(a);\n    }\n    if (ρσ_arraylike(a) && ρσ_arraylike(b)) {\n        if ((a.length !== b.length && (typeof a.length !== \"object\" || ρσ_not_equals(a.length, b.length)))) {\n            return false;\n        }\n        for (var i=0; i < a.length; i++) {\n            if (!((a[(typeof i === \"number\" && i < 0) ? a.length + i : i] === b[(typeof i === \"number\" && i < 0) ? b.length + i : i] || typeof a[(typeof i === \"number\" && i < 0) ? a.length + i : i] === \"object\" && ρσ_equals(a[(typeof i === \"number\" && i < 0) ? a.length + i : i], b[(typeof i === \"number\" && i < 0) ? b.length + i : i])))) {\n                return false;\n            }\n        }\n        return true;\n    }\n    if (typeof a === \"object\" && typeof b === \"object\" && a !== null && b !== null && (a.constructor === Object && b.constructor === Object || Object.getPrototypeOf(a) === null && Object.getPrototypeOf(b) === null)) {\n        ρσ_unpack = [Object.keys(a), Object.keys(b)];\n        akeys = ρσ_unpack[0];\n        bkeys = ρσ_unpack[1];\n        if (akeys.length !== bkeys.length) {\n            return false;\n        }\n        for (var j=0; j < akeys.length; j++) {\n            key = akeys[(typeof j === \"number\" && j < 0) ? akeys.length + j : j];\n            if (!((a[(typeof key === \"number\" && key < 0) ? a.length + key : key] === b[(typeof key === \"number\" && key < 0) ? b.length + key : key] || typeof a[(typeof key === \"number\" && key < 0) ? a.length + key : key] === \"object\" && ρσ_equals(a[(typeof key === \"number\" && key < 0) ? a.length + key : key], b[(typeof key === \"number\" && key < 0) ? b.length + key : key])))) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n};\nif (!ρσ_equals.__argnames__) Object.defineProperties(ρσ_equals, {\n    __argnames__ : {value: [\"a\", \"b\"]}\n});\n\nfunction ρσ_not_equals(a, b) {\n    if (a === b) {\n        return false;\n    }\n    if (a && typeof a.__ne__ === \"function\") {\n        return a.__ne__(b);\n    }\n    if (b && typeof b.__ne__ === \"function\") {\n        return b.__ne__(a);\n    }\n    return !ρσ_equals(a, b);\n};\nif (!ρσ_not_equals.__argnames__) Object.defineProperties(ρσ_not_equals, {\n    __argnames__ : {value: [\"a\", \"b\"]}\n});\n\nvar equals = ρσ_equals;\nfunction ρσ_list_extend(iterable) {\n    var start, iterator, result;\n    if (Array.isArray(iterable) || typeof iterable === \"string\") {\n        start = this.length;\n        this.length += iterable.length;\n        for (var i = 0; i < iterable.length; i++) {\n            (ρσ_expr_temp = this)[ρσ_bound_index(start + i, ρσ_expr_temp)] = iterable[(typeof i === \"number\" && i < 0) ? iterable.length + i : i];\n        }\n    } else {\n        iterator = (typeof Map === \"function\" && iterable instanceof Map) ? iterable.keys() : iterable[ρσ_iterator_symbol]();\n        result = iterator.next();\n        while (!result.done) {\n            this.push(result.value);\n            result = iterator.next();\n        }\n    }\n};\nif (!ρσ_list_extend.__argnames__) Object.defineProperties(ρσ_list_extend, {\n    __argnames__ : {value: [\"iterable\"]}\n});\n\nfunction ρσ_list_index(val, start, stop) {\n    var idx;\n    start = start || 0;\n    if (start < 0) {\n        start = this.length + start;\n    }\n    if (start < 0) {\n        throw new ValueError(val + \" is not in list\");\n    }\n    if (stop === undefined) {\n        idx = this.indexOf(val, start);\n        if (idx === -1) {\n            throw new ValueError(val + \" is not in list\");\n        }\n        return idx;\n    }\n    if (stop < 0) {\n        stop = this.length + stop;\n    }\n    for (var i = start; i < stop; i++) {\n        if (((ρσ_expr_temp = this)[(typeof i === \"number\" && i < 0) ? ρσ_expr_temp.length + i : i] === val || typeof (ρσ_expr_temp = this)[(typeof i === \"number\" && i < 0) ? ρσ_expr_temp.length + i : i] === \"object\" && ρσ_equals((ρσ_expr_temp = this)[(typeof i === \"number\" && i < 0) ? ρσ_expr_temp.length + i : i], val))) {\n            return i;\n        }\n    }\n    throw new ValueError(val + \" is not in list\");\n};\nif (!ρσ_list_index.__argnames__) Object.defineProperties(ρσ_list_index, {\n    __argnames__ : {value: [\"val\", \"start\", \"stop\"]}\n});\n\nfunction ρσ_list_pop(index) {\n    var ans;\n    if (this.length === 0) {\n        throw new IndexError(\"list is empty\");\n    }\n    ans = this.splice(index, 1);\n    if (!ans.length) {\n        throw new IndexError(\"pop index out of range\");\n    }\n    return ans[0];\n};\nif (!ρσ_list_pop.__argnames__) Object.defineProperties(ρσ_list_pop, {\n    __argnames__ : {value: [\"index\"]}\n});\n\nfunction ρσ_list_remove(value) {\n    var idx;\n    idx = this.indexOf(value);\n    if (idx === -1) {\n        throw new ValueError(value + \" not in list\");\n    }\n    this.splice(idx, 1);\n};\nif (!ρσ_list_remove.__argnames__) Object.defineProperties(ρσ_list_remove, {\n    __argnames__ : {value: [\"value\"]}\n});\n\nfunction ρσ_list_to_string() {\n    return \"[\" + this.join(\", \") + \"]\";\n};\n\nfunction ρσ_list_insert(index, val) {\n    if (index < 0) {\n        index += this.length;\n    }\n    index = min(this.length, max(index, 0));\n    if (index === 0) {\n        this.unshift(val);\n        return;\n    }\n    for (var i = this.length; i > index; i--) {\n        (ρσ_expr_temp = this)[(typeof i === \"number\" && i < 0) ? ρσ_expr_temp.length + i : i] = (ρσ_expr_temp = this)[ρσ_bound_index(i - 1, ρσ_expr_temp)];\n    }\n    (ρσ_expr_temp = this)[(typeof index === \"number\" && index < 0) ? ρσ_expr_temp.length + index : index] = val;\n};\nif (!ρσ_list_insert.__argnames__) Object.defineProperties(ρσ_list_insert, {\n    __argnames__ : {value: [\"index\", \"val\"]}\n});\n\nfunction ρσ_list_copy() {\n    return ρσ_list_constructor(this);\n};\n\nfunction ρσ_list_clear() {\n    this.length = 0;\n};\n\nfunction ρσ_list_as_array() {\n    return Array.prototype.slice.call(this);\n};\n\nfunction ρσ_list_count(value) {\n    return this.reduce((function() {\n        var ρσ_anonfunc = function (n, val) {\n            return n + (val === value);\n        };\n        if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n            __argnames__ : {value: [\"n\", \"val\"]}\n        });\n        return ρσ_anonfunc;\n    })(), 0);\n};\nif (!ρσ_list_count.__argnames__) Object.defineProperties(ρσ_list_count, {\n    __argnames__ : {value: [\"value\"]}\n});\n\nfunction ρσ_list_sort_key(value) {\n    var t;\n    t = typeof value;\n    if (t === \"string\" || t === \"number\") {\n        return value;\n    }\n    return value.toString();\n};\nif (!ρσ_list_sort_key.__argnames__) Object.defineProperties(ρσ_list_sort_key, {\n    __argnames__ : {value: [\"value\"]}\n});\n\nfunction ρσ_list_sort_cmp(a, b, ap, bp) {\n    if (a < b) {\n        return -1;\n    }\n    if (a > b) {\n        return 1;\n    }\n    return ap - bp;\n};\nif (!ρσ_list_sort_cmp.__argnames__) Object.defineProperties(ρσ_list_sort_cmp, {\n    __argnames__ : {value: [\"a\", \"b\", \"ap\", \"bp\"]}\n});\n\nfunction ρσ_list_sort() {\n    var key = (arguments[0] === undefined || ( 0 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === \"object\" && arguments[arguments.length-1] [ρσ_kwargs_symbol] === true)) ? ρσ_list_sort.__defaults__.key : arguments[0];\n    var reverse = (arguments[1] === undefined || ( 1 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === \"object\" && arguments[arguments.length-1] [ρσ_kwargs_symbol] === true)) ? ρσ_list_sort.__defaults__.reverse : arguments[1];\n    var ρσ_kwargs_obj = arguments[arguments.length-1];\n    if (ρσ_kwargs_obj === null || typeof ρσ_kwargs_obj !== \"object\" || ρσ_kwargs_obj [ρσ_kwargs_symbol] !== true) ρσ_kwargs_obj = {};\n    if (Object.prototype.hasOwnProperty.call(ρσ_kwargs_obj, \"key\")){\n        key = ρσ_kwargs_obj.key;\n    }\n    if (Object.prototype.hasOwnProperty.call(ρσ_kwargs_obj, \"reverse\")){\n        reverse = ρσ_kwargs_obj.reverse;\n    }\n    var mult, keymap, posmap, k;\n    key = key || ρσ_list_sort_key;\n    mult = (reverse) ? -1 : 1;\n    keymap = dict();\n    posmap = dict();\n    for (var i=0; i < this.length; i++) {\n        k = (ρσ_expr_temp = this)[(typeof i === \"number\" && i < 0) ? ρσ_expr_temp.length + i : i];\n        keymap.set(k, key(k));\n        posmap.set(k, i);\n    }\n    this.sort((function() {\n        var ρσ_anonfunc = function (a, b) {\n            return mult * ρσ_list_sort_cmp(keymap.get(a), keymap.get(b), posmap.get(a), posmap.get(b));\n        };\n        if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n            __argnames__ : {value: [\"a\", \"b\"]}\n        });\n        return ρσ_anonfunc;\n    })());\n};\nif (!ρσ_list_sort.__defaults__) Object.defineProperties(ρσ_list_sort, {\n    __defaults__ : {value: {key:null, reverse:false}},\n    __handles_kwarg_interpolation__ : {value: true},\n    __argnames__ : {value: [\"key\", \"reverse\"]}\n});\n\nfunction ρσ_list_concat() {\n    var ans;\n    ans = Array.prototype.concat.apply(this, arguments);\n    ρσ_list_decorate(ans);\n    return ans;\n};\n\nfunction ρσ_list_slice() {\n    var ans;\n    ans = Array.prototype.slice.apply(this, arguments);\n    ρσ_list_decorate(ans);\n    return ans;\n};\n\nfunction ρσ_list_iterator(value) {\n    var self;\n    self = this;\n    return (function(){\n        var ρσ_d = {};\n        ρσ_d[\"_i\"] = -1;\n        ρσ_d[\"_list\"] = self;\n        ρσ_d[\"next\"] = function () {\n            this._i += 1;\n            if (this._i >= this._list.length) {\n                return (function(){\n                    var ρσ_d = {};\n                    ρσ_d[\"done\"] = true;\n                    return ρσ_d;\n                }).call(this);\n            }\n            return (function(){\n                var ρσ_d = {};\n                ρσ_d[\"done\"] = false;\n                ρσ_d[\"value\"] = (ρσ_expr_temp = this._list)[ρσ_bound_index(this._i, ρσ_expr_temp)];\n                return ρσ_d;\n            }).call(this);\n        };\n        return ρσ_d;\n    }).call(this);\n};\nif (!ρσ_list_iterator.__argnames__) Object.defineProperties(ρσ_list_iterator, {\n    __argnames__ : {value: [\"value\"]}\n});\n\nfunction ρσ_list_len() {\n    return this.length;\n};\n\nfunction ρσ_list_contains(val) {\n    for (var i = 0; i < this.length; i++) {\n        if (((ρσ_expr_temp = this)[(typeof i === \"number\" && i < 0) ? ρσ_expr_temp.length + i : i] === val || typeof (ρσ_expr_temp = this)[(typeof i === \"number\" && i < 0) ? ρσ_expr_temp.length + i : i] === \"object\" && ρσ_equals((ρσ_expr_temp = this)[(typeof i === \"number\" && i < 0) ? ρσ_expr_temp.length + i : i], val))) {\n            return true;\n        }\n    }\n    return false;\n};\nif (!ρσ_list_contains.__argnames__) Object.defineProperties(ρσ_list_contains, {\n    __argnames__ : {value: [\"val\"]}\n});\n\nfunction ρσ_list_eq(other) {\n    if (!ρσ_arraylike(other)) {\n        return false;\n    }\n    if ((this.length !== other.length && (typeof this.length !== \"object\" || ρσ_not_equals(this.length, other.length)))) {\n        return false;\n    }\n    for (var i = 0; i < this.length; i++) {\n        if (!(((ρσ_expr_temp = this)[(typeof i === \"number\" && i < 0) ? ρσ_expr_temp.length + i : i] === other[(typeof i === \"number\" && i < 0) ? other.length + i : i] || typeof (ρσ_expr_temp = this)[(typeof i === \"number\" && i < 0) ? ρσ_expr_temp.length + i : i] === \"object\" && ρσ_equals((ρσ_expr_temp = this)[(typeof i === \"number\" && i < 0) ? ρσ_expr_temp.length + i : i], other[(typeof i === \"number\" && i < 0) ? other.length + i : i])))) {\n            return false;\n        }\n    }\n    return true;\n};\nif (!ρσ_list_eq.__argnames__) Object.defineProperties(ρσ_list_eq, {\n    __argnames__ : {value: [\"other\"]}\n});\n\nfunction ρσ_list_decorate(ans) {\n    ans.append = Array.prototype.push;\n    ans.toString = ρσ_list_to_string;\n    ans.inspect = ρσ_list_to_string;\n    ans.extend = ρσ_list_extend;\n    ans.index = ρσ_list_index;\n    ans.pypop = ρσ_list_pop;\n    ans.remove = ρσ_list_remove;\n    ans.insert = ρσ_list_insert;\n    ans.copy = ρσ_list_copy;\n    ans.clear = ρσ_list_clear;\n    ans.count = ρσ_list_count;\n    ans.concat = ρσ_list_concat;\n    ans.pysort = ρσ_list_sort;\n    ans.slice = ρσ_list_slice;\n    ans.as_array = ρσ_list_as_array;\n    ans.__len__ = ρσ_list_len;\n    ans.__contains__ = ρσ_list_contains;\n    ans.__eq__ = ρσ_list_eq;\n    ans.constructor = ρσ_list_constructor;\n    if (typeof ans[ρσ_iterator_symbol] !== \"function\") {\n        ans[ρσ_iterator_symbol] = ρσ_list_iterator;\n    }\n    return ans;\n};\nif (!ρσ_list_decorate.__argnames__) Object.defineProperties(ρσ_list_decorate, {\n    __argnames__ : {value: [\"ans\"]}\n});\n\nfunction ρσ_list_constructor(iterable) {\n    var ans, iterator, result;\n    if (iterable === undefined) {\n        ans = [];\n    } else if (ρσ_arraylike(iterable)) {\n        ans = new Array(iterable.length);\n        for (var i = 0; i < iterable.length; i++) {\n            ans[(typeof i === \"number\" && i < 0) ? ans.length + i : i] = iterable[(typeof i === \"number\" && i < 0) ? iterable.length + i : i];\n        }\n    } else if (typeof iterable[ρσ_iterator_symbol] === \"function\") {\n        iterator = (typeof Map === \"function\" && iterable instanceof Map) ? iterable.keys() : iterable[ρσ_iterator_symbol]();\n        ans = ρσ_list_decorate([]);\n        result = iterator.next();\n        while (!result.done) {\n            ans.push(result.value);\n            result = iterator.next();\n        }\n    } else if (typeof iterable === \"number\") {\n        ans = new Array(iterable);\n    } else {\n        ans = Object.keys(iterable);\n    }\n    return ρσ_list_decorate(ans);\n};\nif (!ρσ_list_constructor.__argnames__) Object.defineProperties(ρσ_list_constructor, {\n    __argnames__ : {value: [\"iterable\"]}\n});\n\nρσ_list_constructor.__name__ = \"list\";\nvar list = ρσ_list_constructor, list_wrap = ρσ_list_decorate;\nfunction sorted() {\n    var iterable = ( 0 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === \"object\" && arguments[arguments.length-1] [ρσ_kwargs_symbol] === true) ? undefined : arguments[0];\n    var key = (arguments[1] === undefined || ( 1 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === \"object\" && arguments[arguments.length-1] [ρσ_kwargs_symbol] === true)) ? sorted.__defaults__.key : arguments[1];\n    var reverse = (arguments[2] === undefined || ( 2 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === \"object\" && arguments[arguments.length-1] [ρσ_kwargs_symbol] === true)) ? sorted.__defaults__.reverse : arguments[2];\n    var ρσ_kwargs_obj = arguments[arguments.length-1];\n    if (ρσ_kwargs_obj === null || typeof ρσ_kwargs_obj !== \"object\" || ρσ_kwargs_obj [ρσ_kwargs_symbol] !== true) ρσ_kwargs_obj = {};\n    if (Object.prototype.hasOwnProperty.call(ρσ_kwargs_obj, \"key\")){\n        key = ρσ_kwargs_obj.key;\n    }\n    if (Object.prototype.hasOwnProperty.call(ρσ_kwargs_obj, \"reverse\")){\n        reverse = ρσ_kwargs_obj.reverse;\n    }\n    var ans;\n    ans = ρσ_list_constructor(iterable);\n    ans.pysort(key, reverse);\n    return ans;\n};\nif (!sorted.__defaults__) Object.defineProperties(sorted, {\n    __defaults__ : {value: {key:null, reverse:false}},\n    __handles_kwarg_interpolation__ : {value: true},\n    __argnames__ : {value: [\"iterable\", \"key\", \"reverse\"]}\n});\n\nvar ρσ_global_object_id = 0, ρσ_set_implementation;\nfunction ρσ_set_keyfor(x) {\n    var t, ans;\n    t = typeof x;\n    if (t === \"string\" || t === \"number\" || t === \"boolean\") {\n        return \"_\" + t[0] + x;\n    }\n    if (x === null) {\n        return \"__!@#$0\";\n    }\n    ans = x.ρσ_hash_key_prop;\n    if (ans === undefined) {\n        ans = \"_!@#$\" + (++ρσ_global_object_id);\n        Object.defineProperty(x, \"ρσ_hash_key_prop\", (function(){\n            var ρσ_d = {};\n            ρσ_d[\"value\"] = ans;\n            return ρσ_d;\n        }).call(this));\n    }\n    return ans;\n};\nif (!ρσ_set_keyfor.__argnames__) Object.defineProperties(ρσ_set_keyfor, {\n    __argnames__ : {value: [\"x\"]}\n});\n\nfunction ρσ_set_polyfill() {\n    this._store = {};\n    this.size = 0;\n};\n\nρσ_set_polyfill.prototype.add = (function() {\n    var ρσ_anonfunc = function (x) {\n        var key;\n        key = ρσ_set_keyfor(x);\n        if (!Object.prototype.hasOwnProperty.call(this._store, key)) {\n            this.size += 1;\n            (ρσ_expr_temp = this._store)[(typeof key === \"number\" && key < 0) ? ρσ_expr_temp.length + key : key] = x;\n        }\n        return this;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"x\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_set_polyfill.prototype.clear = (function() {\n    var ρσ_anonfunc = function (x) {\n        this._store = {};\n        this.size = 0;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"x\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_set_polyfill.prototype.delete = (function() {\n    var ρσ_anonfunc = function (x) {\n        var key;\n        key = ρσ_set_keyfor(x);\n        if (Object.prototype.hasOwnProperty.call(this._store, key)) {\n            this.size -= 1;\n            delete this._store[key];\n            return true;\n        }\n        return false;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"x\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_set_polyfill.prototype.has = (function() {\n    var ρσ_anonfunc = function (x) {\n        return Object.prototype.hasOwnProperty.call(this._store, ρσ_set_keyfor(x));\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"x\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_set_polyfill.prototype.values = (function() {\n    var ρσ_anonfunc = function (x) {\n        var ans;\n        ans = {'_keys': Object.keys(this._store), '_i':-1, '_s':this._store};\n        ans[ρσ_iterator_symbol] = function () {\n            return this;\n        };\n        ans[\"next\"] = function () {\n            this._i += 1;\n            if (this._i >= this._keys.length) {\n                return {'done': true};\n            }\n            return {'done':false, 'value':this._s[this._keys[this._i]]};\n        };\n        return ans;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"x\"]}\n    });\n    return ρσ_anonfunc;\n})();\nif (typeof Set !== \"function\" || typeof Set.prototype.delete !== \"function\") {\n    ρσ_set_implementation = ρσ_set_polyfill;\n} else {\n    ρσ_set_implementation = Set;\n}\nfunction ρσ_set(iterable) {\n    var ans, s, iterator, result, keys;\n    if (this instanceof ρσ_set) {\n        this.jsset = new ρσ_set_implementation;\n        ans = this;\n        if (iterable === undefined) {\n            return ans;\n        }\n        s = ans.jsset;\n        if (ρσ_arraylike(iterable)) {\n            for (var i = 0; i < iterable.length; i++) {\n                s.add(iterable[(typeof i === \"number\" && i < 0) ? iterable.length + i : i]);\n            }\n        } else if (typeof iterable[ρσ_iterator_symbol] === \"function\") {\n            iterator = (typeof Map === \"function\" && iterable instanceof Map) ? iterable.keys() : iterable[ρσ_iterator_symbol]();\n            result = iterator.next();\n            while (!result.done) {\n                s.add(result.value);\n                result = iterator.next();\n            }\n        } else {\n            keys = Object.keys(iterable);\n            for (var j=0; j < keys.length; j++) {\n                s.add(keys[(typeof j === \"number\" && j < 0) ? keys.length + j : j]);\n            }\n        }\n        return ans;\n    } else {\n        return new ρσ_set(iterable);\n    }\n};\nif (!ρσ_set.__argnames__) Object.defineProperties(ρσ_set, {\n    __argnames__ : {value: [\"iterable\"]}\n});\n\nρσ_set.prototype.__name__ = \"set\";\nObject.defineProperties(ρσ_set.prototype, (function(){\n    var ρσ_d = {};\n    ρσ_d[\"length\"] = (function(){\n        var ρσ_d = {};\n        ρσ_d[\"get\"] = function () {\n            return this.jsset.size;\n        };\n        return ρσ_d;\n    }).call(this);\n    ρσ_d[\"size\"] = (function(){\n        var ρσ_d = {};\n        ρσ_d[\"get\"] = function () {\n            return this.jsset.size;\n        };\n        return ρσ_d;\n    }).call(this);\n    return ρσ_d;\n}).call(this));\nρσ_set.prototype.__len__ = function () {\n    return this.jsset.size;\n};\nρσ_set.prototype.has = ρσ_set.prototype.__contains__ = (function() {\n    var ρσ_anonfunc = function (x) {\n        return this.jsset.has(x);\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"x\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_set.prototype.add = (function() {\n    var ρσ_anonfunc = function (x) {\n        this.jsset.add(x);\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"x\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_set.prototype.clear = function () {\n    this.jsset.clear();\n};\nρσ_set.prototype.copy = function () {\n    return ρσ_set(this);\n};\nρσ_set.prototype.discard = (function() {\n    var ρσ_anonfunc = function (x) {\n        this.jsset.delete(x);\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"x\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_set.prototype[ρσ_iterator_symbol] = function () {\n    return this.jsset.values();\n};\nρσ_set.prototype.difference = function () {\n    var ans, s, iterator, r, x, has;\n    ans = new ρσ_set;\n    s = ans.jsset;\n    iterator = this.jsset.values();\n    r = iterator.next();\n    while (!r.done) {\n        x = r.value;\n        has = false;\n        for (var i = 0; i < arguments.length; i++) {\n            if (arguments[(typeof i === \"number\" && i < 0) ? arguments.length + i : i].has(x)) {\n                has = true;\n                break;\n            }\n        }\n        if (!has) {\n            s.add(x);\n        }\n        r = iterator.next();\n    }\n    return ans;\n};\nρσ_set.prototype.difference_update = function () {\n    var s, remove, iterator, r, x;\n    s = this.jsset;\n    remove = [];\n    iterator = s.values();\n    r = iterator.next();\n    while (!r.done) {\n        x = r.value;\n        for (var i = 0; i < arguments.length; i++) {\n            if (arguments[(typeof i === \"number\" && i < 0) ? arguments.length + i : i].has(x)) {\n                remove.push(x);\n                break;\n            }\n        }\n        r = iterator.next();\n    }\n    for (var j = 0; j < remove.length; j++) {\n        s.delete(remove[(typeof j === \"number\" && j < 0) ? remove.length + j : j]);\n    }\n};\nρσ_set.prototype.intersection = function () {\n    var ans, s, iterator, r, x, has;\n    ans = new ρσ_set;\n    s = ans.jsset;\n    iterator = this.jsset.values();\n    r = iterator.next();\n    while (!r.done) {\n        x = r.value;\n        has = true;\n        for (var i = 0; i < arguments.length; i++) {\n            if (!arguments[(typeof i === \"number\" && i < 0) ? arguments.length + i : i].has(x)) {\n                has = false;\n                break;\n            }\n        }\n        if (has) {\n            s.add(x);\n        }\n        r = iterator.next();\n    }\n    return ans;\n};\nρσ_set.prototype.intersection_update = function () {\n    var s, remove, iterator, r, x;\n    s = this.jsset;\n    remove = [];\n    iterator = s.values();\n    r = iterator.next();\n    while (!r.done) {\n        x = r.value;\n        for (var i = 0; i < arguments.length; i++) {\n            if (!arguments[(typeof i === \"number\" && i < 0) ? arguments.length + i : i].has(x)) {\n                remove.push(x);\n                break;\n            }\n        }\n        r = iterator.next();\n    }\n    for (var j = 0; j < remove.length; j++) {\n        s.delete(remove[(typeof j === \"number\" && j < 0) ? remove.length + j : j]);\n    }\n};\nρσ_set.prototype.isdisjoint = (function() {\n    var ρσ_anonfunc = function (other) {\n        var iterator, r, x;\n        iterator = this.jsset.values();\n        r = iterator.next();\n        while (!r.done) {\n            x = r.value;\n            if (other.has(x)) {\n                return false;\n            }\n            r = iterator.next();\n        }\n        return true;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"other\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_set.prototype.issubset = (function() {\n    var ρσ_anonfunc = function (other) {\n        var iterator, r, x;\n        iterator = this.jsset.values();\n        r = iterator.next();\n        while (!r.done) {\n            x = r.value;\n            if (!other.has(x)) {\n                return false;\n            }\n            r = iterator.next();\n        }\n        return true;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"other\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_set.prototype.issuperset = (function() {\n    var ρσ_anonfunc = function (other) {\n        var s, iterator, r, x;\n        s = this.jsset;\n        iterator = other.jsset.values();\n        r = iterator.next();\n        while (!r.done) {\n            x = r.value;\n            if (!s.has(x)) {\n                return false;\n            }\n            r = iterator.next();\n        }\n        return true;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"other\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_set.prototype.pop = function () {\n    var iterator, r;\n    iterator = this.jsset.values();\n    r = iterator.next();\n    if (r.done) {\n        throw new KeyError(\"pop from an empty set\");\n    }\n    this.jsset.delete(r.value);\n    return r.value;\n};\nρσ_set.prototype.remove = (function() {\n    var ρσ_anonfunc = function (x) {\n        if (!this.jsset.delete(x)) {\n            throw new KeyError(x.toString());\n        }\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"x\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_set.prototype.symmetric_difference = (function() {\n    var ρσ_anonfunc = function (other) {\n        return this.union(other).difference(this.intersection(other));\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"other\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_set.prototype.symmetric_difference_update = (function() {\n    var ρσ_anonfunc = function (other) {\n        var common;\n        common = this.intersection(other);\n        this.update(other);\n        this.difference_update(common);\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"other\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_set.prototype.union = function () {\n    var ans;\n    ans = ρσ_set(this);\n    ans.update.apply(ans, arguments);\n    return ans;\n};\nρσ_set.prototype.update = function () {\n    var s, iterator, r;\n    s = this.jsset;\n    for (var i=0; i < arguments.length; i++) {\n        iterator = arguments[(typeof i === \"number\" && i < 0) ? arguments.length + i : i][ρσ_iterator_symbol]();\n        r = iterator.next();\n        while (!r.done) {\n            s.add(r.value);\n            r = iterator.next();\n        }\n    }\n};\nρσ_set.prototype.toString = ρσ_set.prototype.inspect = function () {\n    return \"{\" + list(this).join(\", \") + \"}\";\n};\nρσ_set.prototype.__eq__ = (function() {\n    var ρσ_anonfunc = function (other) {\n        var iterator, r;\n        if (!other instanceof this.constructor) {\n            return false;\n        }\n        if (other.size !== this.size) {\n            return false;\n        }\n        if (other.size === 0) {\n            return true;\n        }\n        iterator = other[ρσ_iterator_symbol]();\n        r = iterator.next();\n        while (!r.done) {\n            if (!this.has(r.value)) {\n                return false;\n            }\n            r = iterator.next();\n        }\n        return true;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"other\"]}\n    });\n    return ρσ_anonfunc;\n})();\nfunction ρσ_set_wrap(x) {\n    var ans;\n    ans = new ρσ_set;\n    ans.jsset = x;\n    return ans;\n};\nif (!ρσ_set_wrap.__argnames__) Object.defineProperties(ρσ_set_wrap, {\n    __argnames__ : {value: [\"x\"]}\n});\n\nvar set = ρσ_set, set_wrap = ρσ_set_wrap;\nvar ρσ_dict_implementation;\nfunction ρσ_dict_polyfill() {\n    this._store = {};\n    this.size = 0;\n};\n\nρσ_dict_polyfill.prototype.set = (function() {\n    var ρσ_anonfunc = function (x, value) {\n        var key;\n        key = ρσ_set_keyfor(x);\n        if (!Object.prototype.hasOwnProperty.call(this._store, key)) {\n            this.size += 1;\n        }\n        (ρσ_expr_temp = this._store)[(typeof key === \"number\" && key < 0) ? ρσ_expr_temp.length + key : key] = [x, value];\n        return this;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"x\", \"value\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_dict_polyfill.prototype.clear = (function() {\n    var ρσ_anonfunc = function (x) {\n        this._store = {};\n        this.size = 0;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"x\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_dict_polyfill.prototype.delete = (function() {\n    var ρσ_anonfunc = function (x) {\n        var key;\n        key = ρσ_set_keyfor(x);\n        if (Object.prototype.hasOwnProperty.call(this._store, key)) {\n            this.size -= 1;\n            delete this._store[key];\n            return true;\n        }\n        return false;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"x\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_dict_polyfill.prototype.has = (function() {\n    var ρσ_anonfunc = function (x) {\n        return Object.prototype.hasOwnProperty.call(this._store, ρσ_set_keyfor(x));\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"x\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_dict_polyfill.prototype.get = (function() {\n    var ρσ_anonfunc = function (x) {\n        try {\n            return (ρσ_expr_temp = this._store)[ρσ_bound_index(ρσ_set_keyfor(x), ρσ_expr_temp)][1];\n        } catch (ρσ_Exception) {\n            ρσ_last_exception = ρσ_Exception;\n            if (ρσ_Exception instanceof TypeError) {\n                return undefined;\n            } else {\n                throw ρσ_Exception;\n            }\n        }\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"x\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_dict_polyfill.prototype.values = (function() {\n    var ρσ_anonfunc = function (x) {\n        var ans;\n        ans = {'_keys': Object.keys(this._store), '_i':-1, '_s':this._store};\n        ans[ρσ_iterator_symbol] = function () {\n            return this;\n        };\n        ans[\"next\"] = function () {\n            this._i += 1;\n            if (this._i >= this._keys.length) {\n                return {'done': true};\n            }\n            return {'done':false, 'value':this._s[this._keys[this._i]][1]};\n        };\n        return ans;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"x\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_dict_polyfill.prototype.keys = (function() {\n    var ρσ_anonfunc = function (x) {\n        var ans;\n        ans = {'_keys': Object.keys(this._store), '_i':-1, '_s':this._store};\n        ans[ρσ_iterator_symbol] = function () {\n            return this;\n        };\n        ans[\"next\"] = function () {\n            this._i += 1;\n            if (this._i >= this._keys.length) {\n                return {'done': true};\n            }\n            return {'done':false, 'value':this._s[this._keys[this._i]][0]};\n        };\n        return ans;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"x\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_dict_polyfill.prototype.entries = (function() {\n    var ρσ_anonfunc = function (x) {\n        var ans;\n        ans = {'_keys': Object.keys(this._store), '_i':-1, '_s':this._store};\n        ans[ρσ_iterator_symbol] = function () {\n            return this;\n        };\n        ans[\"next\"] = function () {\n            this._i += 1;\n            if (this._i >= this._keys.length) {\n                return {'done': true};\n            }\n            return {'done':false, 'value':this._s[this._keys[this._i]]};\n        };\n        return ans;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"x\"]}\n    });\n    return ρσ_anonfunc;\n})();\nif (typeof Map !== \"function\" || typeof Map.prototype.delete !== \"function\") {\n    ρσ_dict_implementation = ρσ_dict_polyfill;\n} else {\n    ρσ_dict_implementation = Map;\n}\nfunction ρσ_dict() {\n    var iterable = ( 0 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === \"object\" && arguments[arguments.length-1] [ρσ_kwargs_symbol] === true) ? undefined : arguments[0];\n    var kw = arguments[arguments.length-1];\n    if (kw === null || typeof kw !== \"object\" || kw [ρσ_kwargs_symbol] !== true) kw = {};\n    if (this instanceof ρσ_dict) {\n        this.jsmap = new ρσ_dict_implementation;\n        if (iterable !== undefined) {\n            this.update(iterable);\n        }\n        this.update(kw);\n        return this;\n    } else {\n        return ρσ_interpolate_kwargs_constructor.call(Object.create(ρσ_dict.prototype), false, ρσ_dict, [iterable].concat([ρσ_desugar_kwargs(kw)]));\n    }\n};\nif (!ρσ_dict.__handles_kwarg_interpolation__) Object.defineProperties(ρσ_dict, {\n    __handles_kwarg_interpolation__ : {value: true},\n    __argnames__ : {value: [\"iterable\"]}\n});\n\nρσ_dict.prototype.__name__ = \"dict\";\nObject.defineProperties(ρσ_dict.prototype, (function(){\n    var ρσ_d = {};\n    ρσ_d[\"length\"] = (function(){\n        var ρσ_d = {};\n        ρσ_d[\"get\"] = function () {\n            return this.jsmap.size;\n        };\n        return ρσ_d;\n    }).call(this);\n    ρσ_d[\"size\"] = (function(){\n        var ρσ_d = {};\n        ρσ_d[\"get\"] = function () {\n            return this.jsmap.size;\n        };\n        return ρσ_d;\n    }).call(this);\n    return ρσ_d;\n}).call(this));\nρσ_dict.prototype.__len__ = function () {\n    return this.jsmap.size;\n};\nρσ_dict.prototype.has = ρσ_dict.prototype.__contains__ = (function() {\n    var ρσ_anonfunc = function (x) {\n        return this.jsmap.has(x);\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"x\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_dict.prototype.set = ρσ_dict.prototype.__setitem__ = (function() {\n    var ρσ_anonfunc = function (key, value) {\n        this.jsmap.set(key, value);\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"key\", \"value\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_dict.prototype.__delitem__ = (function() {\n    var ρσ_anonfunc = function (key) {\n        this.jsmap.delete(key);\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"key\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_dict.prototype.clear = function () {\n    this.jsmap.clear();\n};\nρσ_dict.prototype.copy = function () {\n    return ρσ_dict(this);\n};\nρσ_dict.prototype.keys = function () {\n    return this.jsmap.keys();\n};\nρσ_dict.prototype.values = function () {\n    return this.jsmap.values();\n};\nρσ_dict.prototype.items = ρσ_dict.prototype.entries = function () {\n    return this.jsmap.entries();\n};\nρσ_dict.prototype[ρσ_iterator_symbol] = function () {\n    return this.jsmap.keys();\n};\nρσ_dict.prototype.__getitem__ = (function() {\n    var ρσ_anonfunc = function (key) {\n        var ans;\n        ans = this.jsmap.get(key);\n        if (ans === undefined && !this.jsmap.has(key)) {\n            throw new KeyError(key + \"\");\n        }\n        return ans;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"key\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_dict.prototype.get = (function() {\n    var ρσ_anonfunc = function (key, defval) {\n        var ans;\n        ans = this.jsmap.get(key);\n        if (ans === undefined && !this.jsmap.has(key)) {\n            return (defval === undefined) ? null : defval;\n        }\n        return ans;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"key\", \"defval\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_dict.prototype.set_default = (function() {\n    var ρσ_anonfunc = function (key, defval) {\n        var j;\n        j = this.jsmap;\n        if (!j.has(key)) {\n            j.set(key, defval);\n            return defval;\n        }\n        return j.get(key);\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"key\", \"defval\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_dict.fromkeys = ρσ_dict.prototype.fromkeys = (function() {\n    var ρσ_anonfunc = function () {\n        var iterable = ( 0 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === \"object\" && arguments[arguments.length-1] [ρσ_kwargs_symbol] === true) ? undefined : arguments[0];\n        var value = (arguments[1] === undefined || ( 1 === arguments.length-1 && arguments[arguments.length-1] !== null && typeof arguments[arguments.length-1] === \"object\" && arguments[arguments.length-1] [ρσ_kwargs_symbol] === true)) ? ρσ_anonfunc.__defaults__.value : arguments[1];\n        var ρσ_kwargs_obj = arguments[arguments.length-1];\n        if (ρσ_kwargs_obj === null || typeof ρσ_kwargs_obj !== \"object\" || ρσ_kwargs_obj [ρσ_kwargs_symbol] !== true) ρσ_kwargs_obj = {};\n        if (Object.prototype.hasOwnProperty.call(ρσ_kwargs_obj, \"value\")){\n            value = ρσ_kwargs_obj.value;\n        }\n        var ans, iterator, r;\n        ans = ρσ_dict();\n        iterator = iter(iterable);\n        r = iterator.next();\n        while (!r.done) {\n            ans.set(r.value, value);\n            r = iterator.next();\n        }\n        return ans;\n    };\n    if (!ρσ_anonfunc.__defaults__) Object.defineProperties(ρσ_anonfunc, {\n        __defaults__ : {value: {value:null}},\n        __handles_kwarg_interpolation__ : {value: true},\n        __argnames__ : {value: [\"iterable\", \"value\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_dict.prototype.pop = (function() {\n    var ρσ_anonfunc = function (key, defval) {\n        var ans;\n        ans = this.jsmap.get(key);\n        if (ans === undefined && !this.jsmap.has(key)) {\n            if (defval === undefined) {\n                throw new KeyError(key);\n            }\n            return defval;\n        }\n        this.jsmap.delete(key);\n        return ans;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"key\", \"defval\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_dict.prototype.popitem = function () {\n    var r;\n    r = this.jsmap.entries().next();\n    if (r.done) {\n        throw new KeyError(\"dict is empty\");\n    }\n    this.jsmap.delete(r.value[0]);\n    return r.value;\n};\nρσ_dict.prototype.update = function () {\n    var m, iterable, iterator, result, keys;\n    if (arguments.length === 0) {\n        return;\n    }\n    m = this.jsmap;\n    iterable = arguments[0];\n    if (Array.isArray(iterable)) {\n        for (var i = 0; i < iterable.length; i++) {\n            m.set(iterable[(typeof i === \"number\" && i < 0) ? iterable.length + i : i][0], iterable[(typeof i === \"number\" && i < 0) ? iterable.length + i : i][1]);\n        }\n    } else if (iterable instanceof ρσ_dict) {\n        iterator = iterable.items();\n        result = iterator.next();\n        while (!result.done) {\n            m.set(result.value[0], result.value[1]);\n            result = iterator.next();\n        }\n    } else if (typeof Map === \"function\" && iterable instanceof Map) {\n        iterator = iterable.entries();\n        result = iterator.next();\n        while (!result.done) {\n            m.set(result.value[0], result.value[1]);\n            result = iterator.next();\n        }\n    } else if (typeof iterable[ρσ_iterator_symbol] === \"function\") {\n        iterator = iterable[ρσ_iterator_symbol]();\n        result = iterator.next();\n        while (!result.done) {\n            m.set(result.value[0], result.value[1]);\n            result = iterator.next();\n        }\n    } else {\n        keys = Object.keys(iterable);\n        for (var j=0; j < keys.length; j++) {\n            if (keys[(typeof j === \"number\" && j < 0) ? keys.length + j : j] !== ρσ_iterator_symbol) {\n                m.set(keys[(typeof j === \"number\" && j < 0) ? keys.length + j : j], iterable[ρσ_bound_index(keys[(typeof j === \"number\" && j < 0) ? keys.length + j : j], iterable)]);\n            }\n        }\n    }\n    if (arguments.length > 1) {\n        ρσ_dict.prototype.update.call(this, arguments[1]);\n    }\n};\nρσ_dict.prototype.toString = ρσ_dict.prototype.inspect = ρσ_dict.prototype.__str__ = ρσ_dict.prototype.__repr__ = function () {\n    var entries, iterator, r;\n    entries = [];\n    iterator = this.jsmap.entries();\n    r = iterator.next();\n    while (!r.done) {\n        entries.push(ρσ_repr(r.value[0]) + \": \" + ρσ_repr(r.value[1]));\n        r = iterator.next();\n    }\n    return \"{\" + entries.join(\", \") + \"}\";\n};\nρσ_dict.prototype.__eq__ = (function() {\n    var ρσ_anonfunc = function (other) {\n        var iterator, r, x;\n        if (!(other instanceof this.constructor)) {\n            return false;\n        }\n        if (other.size !== this.size) {\n            return false;\n        }\n        if (other.size === 0) {\n            return true;\n        }\n        iterator = other.items();\n        r = iterator.next();\n        while (!r.done) {\n            x = this.jsmap.get(r.value[0]);\n            if (x === undefined && !this.jsmap.has(r.value[0]) || x !== r.value[1]) {\n                return false;\n            }\n            r = iterator.next();\n        }\n        return true;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"other\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_dict.prototype.as_object = (function() {\n    var ρσ_anonfunc = function (other) {\n        var ans, iterator, r;\n        ans = {};\n        iterator = this.jsmap.entries();\n        r = iterator.next();\n        while (!r.done) {\n            ans[ρσ_bound_index(r.value[0], ans)] = r.value[1];\n            r = iterator.next();\n        }\n        return ans;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"other\"]}\n    });\n    return ρσ_anonfunc;\n})();\nfunction ρσ_dict_wrap(x) {\n    var ans;\n    ans = new ρσ_dict;\n    ans.jsmap = x;\n    return ans;\n};\nif (!ρσ_dict_wrap.__argnames__) Object.defineProperties(ρσ_dict_wrap, {\n    __argnames__ : {value: [\"x\"]}\n});\n\nvar dict = ρσ_dict, dict_wrap = ρσ_dict_wrap;var NameError;\nNameError = ReferenceError;\nfunction Exception() {\n    if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n    Exception.prototype.__init__.apply(this, arguments);\n}\nρσ_extends(Exception, Error);\nException.prototype.__init__ = function __init__(message) {\n    var self = this;\n    self.message = message;\n    self.stack = (new Error).stack;\n    self.name = self.constructor.name;\n};\nif (!Exception.prototype.__init__.__argnames__) Object.defineProperties(Exception.prototype.__init__, {\n    __argnames__ : {value: [\"message\"]}\n});\nException.__argnames__ = Exception.prototype.__init__.__argnames__;\nException.__handles_kwarg_interpolation__ = Exception.prototype.__init__.__handles_kwarg_interpolation__;\nException.prototype.__repr__ = function __repr__() {\n    var self = this;\n    return self.name + \": \" + self.message;\n};\nif (!Exception.prototype.__repr__.__argnames__) Object.defineProperties(Exception.prototype.__repr__, {\n    __argnames__ : {value: []}\n});\nException.prototype.__str__ = function __str__ () {\n    if(Error.prototype.__str__) return Error.prototype.__str__.call(this);\nreturn this.__repr__();\n};\nObject.defineProperty(Exception.prototype, \"__bases__\", {value: [Error]});\n\nfunction AttributeError() {\n    if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n    AttributeError.prototype.__init__.apply(this, arguments);\n}\nρσ_extends(AttributeError, Exception);\nAttributeError.prototype.__init__ = function __init__ () {\n    Exception.prototype.__init__ && Exception.prototype.__init__.apply(this, arguments);\n};\nAttributeError.prototype.__repr__ = function __repr__ () {\n    if(Exception.prototype.__repr__) return Exception.prototype.__repr__.call(this);\n    return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n};\nAttributeError.prototype.__str__ = function __str__ () {\n    if(Exception.prototype.__str__) return Exception.prototype.__str__.call(this);\nreturn this.__repr__();\n};\nObject.defineProperty(AttributeError.prototype, \"__bases__\", {value: [Exception]});\n\n\nfunction IndexError() {\n    if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n    IndexError.prototype.__init__.apply(this, arguments);\n}\nρσ_extends(IndexError, Exception);\nIndexError.prototype.__init__ = function __init__ () {\n    Exception.prototype.__init__ && Exception.prototype.__init__.apply(this, arguments);\n};\nIndexError.prototype.__repr__ = function __repr__ () {\n    if(Exception.prototype.__repr__) return Exception.prototype.__repr__.call(this);\n    return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n};\nIndexError.prototype.__str__ = function __str__ () {\n    if(Exception.prototype.__str__) return Exception.prototype.__str__.call(this);\nreturn this.__repr__();\n};\nObject.defineProperty(IndexError.prototype, \"__bases__\", {value: [Exception]});\n\n\nfunction KeyError() {\n    if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n    KeyError.prototype.__init__.apply(this, arguments);\n}\nρσ_extends(KeyError, Exception);\nKeyError.prototype.__init__ = function __init__ () {\n    Exception.prototype.__init__ && Exception.prototype.__init__.apply(this, arguments);\n};\nKeyError.prototype.__repr__ = function __repr__ () {\n    if(Exception.prototype.__repr__) return Exception.prototype.__repr__.call(this);\n    return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n};\nKeyError.prototype.__str__ = function __str__ () {\n    if(Exception.prototype.__str__) return Exception.prototype.__str__.call(this);\nreturn this.__repr__();\n};\nObject.defineProperty(KeyError.prototype, \"__bases__\", {value: [Exception]});\n\n\nfunction ValueError() {\n    if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n    ValueError.prototype.__init__.apply(this, arguments);\n}\nρσ_extends(ValueError, Exception);\nValueError.prototype.__init__ = function __init__ () {\n    Exception.prototype.__init__ && Exception.prototype.__init__.apply(this, arguments);\n};\nValueError.prototype.__repr__ = function __repr__ () {\n    if(Exception.prototype.__repr__) return Exception.prototype.__repr__.call(this);\n    return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n};\nValueError.prototype.__str__ = function __str__ () {\n    if(Exception.prototype.__str__) return Exception.prototype.__str__.call(this);\nreturn this.__repr__();\n};\nObject.defineProperty(ValueError.prototype, \"__bases__\", {value: [Exception]});\n\n\nfunction UnicodeDecodeError() {\n    if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n    UnicodeDecodeError.prototype.__init__.apply(this, arguments);\n}\nρσ_extends(UnicodeDecodeError, Exception);\nUnicodeDecodeError.prototype.__init__ = function __init__ () {\n    Exception.prototype.__init__ && Exception.prototype.__init__.apply(this, arguments);\n};\nUnicodeDecodeError.prototype.__repr__ = function __repr__ () {\n    if(Exception.prototype.__repr__) return Exception.prototype.__repr__.call(this);\n    return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n};\nUnicodeDecodeError.prototype.__str__ = function __str__ () {\n    if(Exception.prototype.__str__) return Exception.prototype.__str__.call(this);\nreturn this.__repr__();\n};\nObject.defineProperty(UnicodeDecodeError.prototype, \"__bases__\", {value: [Exception]});\n\n\nfunction AssertionError() {\n    if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n    AssertionError.prototype.__init__.apply(this, arguments);\n}\nρσ_extends(AssertionError, Exception);\nAssertionError.prototype.__init__ = function __init__ () {\n    Exception.prototype.__init__ && Exception.prototype.__init__.apply(this, arguments);\n};\nAssertionError.prototype.__repr__ = function __repr__ () {\n    if(Exception.prototype.__repr__) return Exception.prototype.__repr__.call(this);\n    return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n};\nAssertionError.prototype.__str__ = function __str__ () {\n    if(Exception.prototype.__str__) return Exception.prototype.__str__.call(this);\nreturn this.__repr__();\n};\nObject.defineProperty(AssertionError.prototype, \"__bases__\", {value: [Exception]});\n\n\nfunction ZeroDivisionError() {\n    if (this.ρσ_object_id === undefined) Object.defineProperty(this, \"ρσ_object_id\", {\"value\":++ρσ_object_counter});\n    ZeroDivisionError.prototype.__init__.apply(this, arguments);\n}\nρσ_extends(ZeroDivisionError, Exception);\nZeroDivisionError.prototype.__init__ = function __init__ () {\n    Exception.prototype.__init__ && Exception.prototype.__init__.apply(this, arguments);\n};\nZeroDivisionError.prototype.__repr__ = function __repr__ () {\n    if(Exception.prototype.__repr__) return Exception.prototype.__repr__.call(this);\n    return \"<\" + __name__ + \".\" + this.constructor.name + \" #\" + this.ρσ_object_id + \">\";\n};\nZeroDivisionError.prototype.__str__ = function __str__ () {\n    if(Exception.prototype.__str__) return Exception.prototype.__str__.call(this);\nreturn this.__repr__();\n};\nObject.defineProperty(ZeroDivisionError.prototype, \"__bases__\", {value: [Exception]});\n\nvar ρσ_in, ρσ_desugar_kwargs, ρσ_exists;\nfunction ρσ_eslice(arr, step, start, end) {\n    var is_string;\n    if (typeof arr === \"string\" || arr instanceof String) {\n        is_string = true;\n        arr = arr.split(\"\");\n    }\n    if (step < 0) {\n        step = -step;\n        arr = arr.slice().reverse();\n        if (typeof start !== \"undefined\") {\n            start = arr.length - start - 1;\n        }\n        if (typeof end !== \"undefined\") {\n            end = arr.length - end - 1;\n        }\n    }\n    if (typeof start === \"undefined\") {\n        start = 0;\n    }\n    if (typeof end === \"undefined\") {\n        end = arr.length;\n    }\n    arr = arr.slice(start, end).filter((function() {\n        var ρσ_anonfunc = function (e, i) {\n            return i % step === 0;\n        };\n        if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n            __argnames__ : {value: [\"e\", \"i\"]}\n        });\n        return ρσ_anonfunc;\n    })());\n    if (is_string) {\n        arr = arr.join(\"\");\n    }\n    return arr;\n};\nif (!ρσ_eslice.__argnames__) Object.defineProperties(ρσ_eslice, {\n    __argnames__ : {value: [\"arr\", \"step\", \"start\", \"end\"]}\n});\n\nfunction ρσ_delslice(arr, step, start, end) {\n    var is_string, ρσ_unpack, indices;\n    if (typeof arr === \"string\" || arr instanceof String) {\n        is_string = true;\n        arr = arr.split(\"\");\n    }\n    if (step < 0) {\n        if (typeof start === \"undefined\") {\n            start = arr.length;\n        }\n        if (typeof end === \"undefined\") {\n            end = 0;\n        }\n        ρσ_unpack = [end, start, -step];\n        start = ρσ_unpack[0];\n        end = ρσ_unpack[1];\n        step = ρσ_unpack[2];\n    }\n    if (typeof start === \"undefined\") {\n        start = 0;\n    }\n    if (typeof end === \"undefined\") {\n        end = arr.length;\n    }\n    if (step === 1) {\n        arr.splice(start, end - start);\n    } else {\n        if (end > start) {\n            indices = [];\n            for (var i = start; i < end; i += step) {\n                indices.push(i);\n            }\n            for (var i = indices.length - 1; i >= 0; i--) {\n                arr.splice(indices[(typeof i === \"number\" && i < 0) ? indices.length + i : i], 1);\n            }\n        }\n    }\n    if (is_string) {\n        arr = arr.join(\"\");\n    }\n    return arr;\n};\nif (!ρσ_delslice.__argnames__) Object.defineProperties(ρσ_delslice, {\n    __argnames__ : {value: [\"arr\", \"step\", \"start\", \"end\"]}\n});\n\nfunction ρσ_flatten(arr) {\n    var ans, value;\n    ans = ρσ_list_decorate([]);\n    for (var i=0; i < arr.length; i++) {\n        value = arr[(typeof i === \"number\" && i < 0) ? arr.length + i : i];\n        if (Array.isArray(value)) {\n            ans = ans.concat(ρσ_flatten(value));\n        } else {\n            ans.push(value);\n        }\n    }\n    return ans;\n};\nif (!ρσ_flatten.__argnames__) Object.defineProperties(ρσ_flatten, {\n    __argnames__ : {value: [\"arr\"]}\n});\n\nfunction ρσ_unpack_asarray(num, iterable) {\n    var ans, iterator, result;\n    if (ρσ_arraylike(iterable)) {\n        return iterable;\n    }\n    ans = [];\n    if (typeof iterable[ρσ_iterator_symbol] === \"function\") {\n        iterator = (typeof Map === \"function\" && iterable instanceof Map) ? iterable.keys() : iterable[ρσ_iterator_symbol]();\n        result = iterator.next();\n        while (!result.done && ans.length < num) {\n            ans.push(result.value);\n            result = iterator.next();\n        }\n    }\n    return ans;\n};\nif (!ρσ_unpack_asarray.__argnames__) Object.defineProperties(ρσ_unpack_asarray, {\n    __argnames__ : {value: [\"num\", \"iterable\"]}\n});\n\nfunction ρσ_extends(child, parent) {\n    child.prototype = Object.create(parent.prototype);\n    child.prototype.constructor = child;\n};\nif (!ρσ_extends.__argnames__) Object.defineProperties(ρσ_extends, {\n    __argnames__ : {value: [\"child\", \"parent\"]}\n});\n\nρσ_in = function () {\n    if (typeof Map === \"function\" && typeof Set === \"function\") {\n        return (function() {\n            var ρσ_anonfunc = function (val, arr) {\n                if (typeof arr === \"string\") {\n                    return arr.indexOf(val) !== -1;\n                }\n                if (typeof arr.__contains__ === \"function\") {\n                    return arr.__contains__(val);\n                }\n                if (arr instanceof Map || arr instanceof Set) {\n                    return arr.has(val);\n                }\n                if (ρσ_arraylike(arr)) {\n                    return ρσ_list_contains.call(arr, val);\n                }\n                return Object.prototype.hasOwnProperty.call(arr, val);\n            };\n            if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                __argnames__ : {value: [\"val\", \"arr\"]}\n            });\n            return ρσ_anonfunc;\n        })();\n    }\n    return (function() {\n        var ρσ_anonfunc = function (val, arr) {\n            if (typeof arr === \"string\") {\n                return arr.indexOf(val) !== -1;\n            }\n            if (typeof arr.__contains__ === \"function\") {\n                return arr.__contains__(val);\n            }\n            if (ρσ_arraylike(arr)) {\n                return ρσ_list_contains.call(arr, val);\n            }\n            return Object.prototype.hasOwnProperty.call(arr, val);\n        };\n        if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n            __argnames__ : {value: [\"val\", \"arr\"]}\n        });\n        return ρσ_anonfunc;\n    })();\n}();\nfunction ρσ_Iterable(iterable) {\n    var iterator, ans, result;\n    if (ρσ_arraylike(iterable)) {\n        return iterable;\n    }\n    if (typeof iterable[ρσ_iterator_symbol] === \"function\") {\n        iterator = (typeof Map === \"function\" && iterable instanceof Map) ? iterable.keys() : iterable[ρσ_iterator_symbol]();\n        ans = ρσ_list_decorate([]);\n        result = iterator.next();\n        while (!result.done) {\n            ans.push(result.value);\n            result = iterator.next();\n        }\n        return ans;\n    }\n    return Object.keys(iterable);\n};\nif (!ρσ_Iterable.__argnames__) Object.defineProperties(ρσ_Iterable, {\n    __argnames__ : {value: [\"iterable\"]}\n});\n\nρσ_desugar_kwargs = function () {\n    if (typeof Object.assign === \"function\") {\n        return function () {\n            var ans;\n            ans = Object.create(null);\n            ans[ρσ_kwargs_symbol] = true;\n            for (var i = 0; i < arguments.length; i++) {\n                Object.assign(ans, arguments[(typeof i === \"number\" && i < 0) ? arguments.length + i : i]);\n            }\n            return ans;\n        };\n    }\n    return function () {\n        var ans, keys;\n        ans = Object.create(null);\n        ans[ρσ_kwargs_symbol] = true;\n        for (var i = 0; i < arguments.length; i++) {\n            keys = Object.keys(arguments[(typeof i === \"number\" && i < 0) ? arguments.length + i : i]);\n            for (var j = 0; j < keys.length; j++) {\n                ans[ρσ_bound_index(keys[(typeof j === \"number\" && j < 0) ? keys.length + j : j], ans)] = (ρσ_expr_temp = arguments[(typeof i === \"number\" && i < 0) ? arguments.length + i : i])[ρσ_bound_index(keys[(typeof j === \"number\" && j < 0) ? keys.length + j : j], ρσ_expr_temp)];\n            }\n        }\n        return ans;\n    };\n}();\nfunction ρσ_interpolate_kwargs(f, supplied_args) {\n    var has_prop, kwobj, args, prop;\n    if (!f.__argnames__) {\n        return f.apply(this, supplied_args);\n    }\n    has_prop = Object.prototype.hasOwnProperty;\n    kwobj = supplied_args.pop();\n    if (f.__handles_kwarg_interpolation__) {\n        args = new Array(Math.max(supplied_args.length, f.__argnames__.length) + 1);\n        args[args.length-1] = kwobj;\n        for (var i = 0; i < args.length - 1; i++) {\n            if (i < f.__argnames__.length) {\n                prop = (ρσ_expr_temp = f.__argnames__)[(typeof i === \"number\" && i < 0) ? ρσ_expr_temp.length + i : i];\n                if (has_prop.call(kwobj, prop)) {\n                    args[(typeof i === \"number\" && i < 0) ? args.length + i : i] = kwobj[(typeof prop === \"number\" && prop < 0) ? kwobj.length + prop : prop];\n                    delete kwobj[prop];\n                } else if (i < supplied_args.length) {\n                    args[(typeof i === \"number\" && i < 0) ? args.length + i : i] = supplied_args[(typeof i === \"number\" && i < 0) ? supplied_args.length + i : i];\n                }\n            } else {\n                args[(typeof i === \"number\" && i < 0) ? args.length + i : i] = supplied_args[(typeof i === \"number\" && i < 0) ? supplied_args.length + i : i];\n            }\n        }\n        return f.apply(this, args);\n    }\n    for (var i = 0; i < f.__argnames__.length; i++) {\n        prop = (ρσ_expr_temp = f.__argnames__)[(typeof i === \"number\" && i < 0) ? ρσ_expr_temp.length + i : i];\n        if (has_prop.call(kwobj, prop)) {\n            supplied_args[(typeof i === \"number\" && i < 0) ? supplied_args.length + i : i] = kwobj[(typeof prop === \"number\" && prop < 0) ? kwobj.length + prop : prop];\n        }\n    }\n    return f.apply(this, supplied_args);\n};\nif (!ρσ_interpolate_kwargs.__argnames__) Object.defineProperties(ρσ_interpolate_kwargs, {\n    __argnames__ : {value: [\"f\", \"supplied_args\"]}\n});\n\nfunction ρσ_interpolate_kwargs_constructor(apply, f, supplied_args) {\n    if (apply) {\n        f.apply(this, supplied_args);\n    } else {\n        ρσ_interpolate_kwargs.call(this, f, supplied_args);\n    }\n    return this;\n};\nif (!ρσ_interpolate_kwargs_constructor.__argnames__) Object.defineProperties(ρσ_interpolate_kwargs_constructor, {\n    __argnames__ : {value: [\"apply\", \"f\", \"supplied_args\"]}\n});\n\nfunction ρσ_getitem(obj, key) {\n    if (obj.__getitem__) {\n        return obj.__getitem__(key);\n    }\n    if (typeof key === \"number\" && key < 0) {\n        key += obj.length;\n    }\n    return obj[(typeof key === \"number\" && key < 0) ? obj.length + key : key];\n};\nif (!ρσ_getitem.__argnames__) Object.defineProperties(ρσ_getitem, {\n    __argnames__ : {value: [\"obj\", \"key\"]}\n});\n\nfunction ρσ_setitem(obj, key, val) {\n    if (obj.__setitem__) {\n        obj.__setitem__(key, val);\n    } else {\n        if (typeof key === \"number\" && key < 0) {\n            key += obj.length;\n        }\n        obj[(typeof key === \"number\" && key < 0) ? obj.length + key : key] = val;\n    }\n};\nif (!ρσ_setitem.__argnames__) Object.defineProperties(ρσ_setitem, {\n    __argnames__ : {value: [\"obj\", \"key\", \"val\"]}\n});\n\nfunction ρσ_delitem(obj, key) {\n    if (obj.__delitem__) {\n        obj.__delitem__(key);\n    } else if (typeof obj.splice === \"function\") {\n        obj.splice(key, 1);\n    } else {\n        if (typeof key === \"number\" && key < 0) {\n            key += obj.length;\n        }\n        delete obj[key];\n    }\n};\nif (!ρσ_delitem.__argnames__) Object.defineProperties(ρσ_delitem, {\n    __argnames__ : {value: [\"obj\", \"key\"]}\n});\n\nfunction ρσ_bound_index(idx, arr) {\n    if (typeof idx === \"number\" && idx < 0) {\n        idx += arr.length;\n    }\n    return idx;\n};\nif (!ρσ_bound_index.__argnames__) Object.defineProperties(ρσ_bound_index, {\n    __argnames__ : {value: [\"idx\", \"arr\"]}\n});\n\nfunction ρσ_splice(arr, val, start, end) {\n    start = start || 0;\n    if (start < 0) {\n        start += arr.length;\n    }\n    if (end === undefined) {\n        end = arr.length;\n    }\n    if (end < 0) {\n        end += arr.length;\n    }\n    Array.prototype.splice.apply(arr, [start, end - start].concat(val));\n};\nif (!ρσ_splice.__argnames__) Object.defineProperties(ρσ_splice, {\n    __argnames__ : {value: [\"arr\", \"val\", \"start\", \"end\"]}\n});\n\nρσ_exists = (function(){\n    var ρσ_d = {};\n    ρσ_d[\"n\"] = (function() {\n        var ρσ_anonfunc = function (expr) {\n            return expr !== undefined && expr !== null;\n        };\n        if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n            __argnames__ : {value: [\"expr\"]}\n        });\n        return ρσ_anonfunc;\n    })();\n    ρσ_d[\"d\"] = (function() {\n        var ρσ_anonfunc = function (expr) {\n            if (expr === undefined || expr === null) {\n                return Object.create(null);\n            }\n            return expr;\n        };\n        if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n            __argnames__ : {value: [\"expr\"]}\n        });\n        return ρσ_anonfunc;\n    })();\n    ρσ_d[\"c\"] = (function() {\n        var ρσ_anonfunc = function (expr) {\n            if (typeof expr === \"function\") {\n                return expr;\n            }\n            return function () {\n                return undefined;\n            };\n        };\n        if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n            __argnames__ : {value: [\"expr\"]}\n        });\n        return ρσ_anonfunc;\n    })();\n    ρσ_d[\"g\"] = (function() {\n        var ρσ_anonfunc = function (expr) {\n            if (expr === undefined || expr === null || typeof expr.__getitem__ !== \"function\") {\n                return (function(){\n                    var ρσ_d = {};\n                    ρσ_d[\"__getitem__\"] = function () {\n                        return undefined;\n                    };\n                    return ρσ_d;\n                }).call(this);\n            }\n        };\n        if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n            __argnames__ : {value: [\"expr\"]}\n        });\n        return ρσ_anonfunc;\n    })();\n    ρσ_d[\"e\"] = (function() {\n        var ρσ_anonfunc = function (expr, alt) {\n            return (expr === undefined || expr === null) ? alt : expr;\n        };\n        if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n            __argnames__ : {value: [\"expr\", \"alt\"]}\n        });\n        return ρσ_anonfunc;\n    })();\n    return ρσ_d;\n}).call(this);\nfunction ρσ_mixin() {\n    var seen, resolved_props, p, target, props, name;\n    seen = Object.create(null);\n    seen.__argnames__ = seen.__handles_kwarg_interpolation__ = seen.__init__ = seen.__annotations__ = seen.__doc__ = seen.__bind_methods__ = seen.__bases__ = seen.constructor = seen.__class__ = true;\n    resolved_props = {};\n    p = target = arguments[0].prototype;\n    while (p && p !== Object.prototype) {\n        props = Object.getOwnPropertyNames(p);\n        for (var i = 0; i < props.length; i++) {\n            seen[ρσ_bound_index(props[(typeof i === \"number\" && i < 0) ? props.length + i : i], seen)] = true;\n        }\n        p = Object.getPrototypeOf(p);\n    }\n    for (var c = 1; c < arguments.length; c++) {\n        p = arguments[(typeof c === \"number\" && c < 0) ? arguments.length + c : c].prototype;\n        while (p && p !== Object.prototype) {\n            props = Object.getOwnPropertyNames(p);\n            for (var i = 0; i < props.length; i++) {\n                name = props[(typeof i === \"number\" && i < 0) ? props.length + i : i];\n                if (seen[(typeof name === \"number\" && name < 0) ? seen.length + name : name]) {\n                    continue;\n                }\n                seen[(typeof name === \"number\" && name < 0) ? seen.length + name : name] = true;\n                resolved_props[(typeof name === \"number\" && name < 0) ? resolved_props.length + name : name] = Object.getOwnPropertyDescriptor(p, name);\n            }\n            p = Object.getPrototypeOf(p);\n        }\n    }\n    Object.defineProperties(target, resolved_props);\n};\n\nfunction ρσ_instanceof() {\n    var obj, bases, q, cls, p;\n    obj = arguments[0];\n    bases = \"\";\n    if (obj && obj.constructor && obj.constructor.prototype) {\n        bases = obj.constructor.prototype.__bases__ || \"\";\n    }\n    for (var i = 1; i < arguments.length; i++) {\n        q = arguments[(typeof i === \"number\" && i < 0) ? arguments.length + i : i];\n        if (obj instanceof q) {\n            return true;\n        }\n        if ((q === Array || q === ρσ_list_constructor) && Array.isArray(obj)) {\n            return true;\n        }\n        if (q === ρσ_str && (typeof obj === \"string\" || obj instanceof String)) {\n            return true;\n        }\n        if (bases.length > 1) {\n            for (var c = 1; c < bases.length; c++) {\n                cls = bases[(typeof c === \"number\" && c < 0) ? bases.length + c : c];\n                while (cls) {\n                    if (q === cls) {\n                        return true;\n                    }\n                    p = Object.getPrototypeOf(cls.prototype);\n                    if (!p) {\n                        break;\n                    }\n                    cls = p.constructor;\n                }\n            }\n        }\n    }\n    return false;\n};\nfunction sum(iterable, start) {\n    var ans, iterator, r;\n    if (Array.isArray(iterable)) {\n        return iterable.reduce((function() {\n            var ρσ_anonfunc = function (prev, cur) {\n                return prev + cur;\n            };\n            if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                __argnames__ : {value: [\"prev\", \"cur\"]}\n            });\n            return ρσ_anonfunc;\n        })(), start || 0);\n    }\n    ans = start || 0;\n    iterator = iter(iterable);\n    r = iterator.next();\n    while (!r.done) {\n        ans += r.value;\n        r = iterator.next();\n    }\n    return ans;\n};\nif (!sum.__argnames__) Object.defineProperties(sum, {\n    __argnames__ : {value: [\"iterable\", \"start\"]}\n});\n\nfunction map() {\n    var iterators, func, args, ans;\n    iterators = new Array(arguments.length - 1);\n    func = arguments[0];\n    args = new Array(arguments.length - 1);\n    for (var i = 1; i < arguments.length; i++) {\n        iterators[ρσ_bound_index(i - 1, iterators)] = iter(arguments[(typeof i === \"number\" && i < 0) ? arguments.length + i : i]);\n    }\n    ans = {'_func':func, '_iterators':iterators, '_args':args};\n    ans[ρσ_iterator_symbol] = function () {\n        return this;\n    };\n    ans[\"next\"] = function () {\n        var r;\n        for (var i = 0; i < this._iterators.length; i++) {\n            r = (ρσ_expr_temp = this._iterators)[(typeof i === \"number\" && i < 0) ? ρσ_expr_temp.length + i : i].next();\n            if (r.done) {\n                return {'done':true};\n            }\n            (ρσ_expr_temp = this._args)[(typeof i === \"number\" && i < 0) ? ρσ_expr_temp.length + i : i] = r.value;\n        }\n        return {'done':false, 'value':this._func.apply(undefined, this._args)};\n    };\n    return ans;\n};\n\nfunction filter(func_or_none, iterable) {\n    var func, ans;\n    func = (func_or_none === null) ? ρσ_bool : func_or_none;\n    ans = {'_func':func, '_iterator':ρσ_iter(iterable)};\n    ans[ρσ_iterator_symbol] = function () {\n        return this;\n    };\n    ans[\"next\"] = function () {\n        var r;\n        r = this._iterator.next();\n        while (!r.done) {\n            if (this._func(r.value)) {\n                return r;\n            }\n            r = this._iterator.next();\n        }\n        return {'done':true};\n    };\n    return ans;\n};\nif (!filter.__argnames__) Object.defineProperties(filter, {\n    __argnames__ : {value: [\"func_or_none\", \"iterable\"]}\n});\n\nfunction zip() {\n    var iterators, ans;\n    iterators = new Array(arguments.length);\n    for (var i = 0; i < arguments.length; i++) {\n        iterators[(typeof i === \"number\" && i < 0) ? iterators.length + i : i] = iter(arguments[(typeof i === \"number\" && i < 0) ? arguments.length + i : i]);\n    }\n    ans = {'_iterators':iterators};\n    ans[ρσ_iterator_symbol] = function () {\n        return this;\n    };\n    ans[\"next\"] = function () {\n        var args, r;\n        args = new Array(this._iterators.length);\n        for (var i = 0; i < this._iterators.length; i++) {\n            r = (ρσ_expr_temp = this._iterators)[(typeof i === \"number\" && i < 0) ? ρσ_expr_temp.length + i : i].next();\n            if (r.done) {\n                return {'done':true};\n            }\n            args[(typeof i === \"number\" && i < 0) ? args.length + i : i] = r.value;\n        }\n        return {'done':false, 'value':args};\n    };\n    return ans;\n};\n\nfunction any(iterable) {\n    var i;\n    var ρσ_Iter0 = ρσ_Iterable(iterable);\n    for (var ρσ_Index0 = 0; ρσ_Index0 < ρσ_Iter0.length; ρσ_Index0++) {\n        i = ρσ_Iter0[ρσ_Index0];\n        if (i) {\n            return true;\n        }\n    }\n    return false;\n};\nif (!any.__argnames__) Object.defineProperties(any, {\n    __argnames__ : {value: [\"iterable\"]}\n});\n\nfunction all(iterable) {\n    var i;\n    var ρσ_Iter1 = ρσ_Iterable(iterable);\n    for (var ρσ_Index1 = 0; ρσ_Index1 < ρσ_Iter1.length; ρσ_Index1++) {\n        i = ρσ_Iter1[ρσ_Index1];\n        if (!i) {\n            return false;\n        }\n    }\n    return true;\n};\nif (!all.__argnames__) Object.defineProperties(all, {\n    __argnames__ : {value: [\"iterable\"]}\n});\nvar define_str_func, ρσ_unpack, ρσ_orig_split, ρσ_orig_replace;\nfunction ρσ_repr_js_builtin(x, as_array) {\n    var ans, b, keys, key;\n    ans = [];\n    b = \"{}\";\n    if (as_array) {\n        b = \"[]\";\n        for (var i = 0; i < x.length; i++) {\n            ans.push(ρσ_repr(x[(typeof i === \"number\" && i < 0) ? x.length + i : i]));\n        }\n    } else {\n        keys = Object.keys(x);\n        for (var k = 0; k < keys.length; k++) {\n            key = keys[(typeof k === \"number\" && k < 0) ? keys.length + k : k];\n            ans.push(JSON.stringify(key) + \":\" + ρσ_repr(x[(typeof key === \"number\" && key < 0) ? x.length + key : key]));\n        }\n    }\n    return b[0] + ans.join(\", \") + b[1];\n};\nif (!ρσ_repr_js_builtin.__argnames__) Object.defineProperties(ρσ_repr_js_builtin, {\n    __argnames__ : {value: [\"x\", \"as_array\"]}\n});\n\nfunction ρσ_html_element_to_string(elem) {\n    var attrs, val, attr, ans;\n    attrs = [];\n    var ρσ_Iter0 = ρσ_Iterable(elem.attributes);\n    for (var ρσ_Index0 = 0; ρσ_Index0 < ρσ_Iter0.length; ρσ_Index0++) {\n        attr = ρσ_Iter0[ρσ_Index0];\n        if (attr.specified) {\n            val = attr.value;\n            if (val.length > 10) {\n                val = val.slice(0, 15) + \"...\";\n            }\n            val = JSON.stringify(val);\n            attrs.push(\"\" + ρσ_str.format(\"{}\", attr.name) + \"=\" + ρσ_str.format(\"{}\", val) + \"\");\n        }\n    }\n    attrs = (attrs.length) ? \" \" + attrs.join(\" \") : \"\";\n    ans = \"<\" + ρσ_str.format(\"{}\", elem.tagName) + \"\" + ρσ_str.format(\"{}\", attrs) + \">\";\n    return ans;\n};\nif (!ρσ_html_element_to_string.__argnames__) Object.defineProperties(ρσ_html_element_to_string, {\n    __argnames__ : {value: [\"elem\"]}\n});\n\nfunction ρσ_repr(x) {\n    var ans, name;\n    if (x === null) {\n        return \"None\";\n    }\n    if (x === undefined) {\n        return \"undefined\";\n    }\n    ans = x;\n    if (typeof x.__repr__ === \"function\") {\n        ans = x.__repr__();\n    } else if (x === true || x === false) {\n        ans = (x) ? \"True\" : \"False\";\n    } else if (Array.isArray(x)) {\n        ans = ρσ_repr_js_builtin(x, true);\n    } else if (typeof x === \"function\") {\n        ans = x.toString();\n    } else if (typeof x === \"object\" && !x.toString) {\n        ans = ρσ_repr_js_builtin(x);\n    } else {\n        name = Object.prototype.toString.call(x).slice(8, -1);\n        if (ρσ_not_equals(\"Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array\".indexOf(name), -1)) {\n            return name + \"([\" + x.map((function() {\n                var ρσ_anonfunc = function (i) {\n                    return str.format(\"0x{:02x}\", i);\n                };\n                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                    __argnames__ : {value: [\"i\"]}\n                });\n                return ρσ_anonfunc;\n            })()).join(\", \") + \"])\";\n        }\n        if (typeof HTMLElement !== \"undefined\" && x instanceof HTMLElement) {\n            ans = ρσ_html_element_to_string(x);\n        } else {\n            ans = (typeof x.toString === \"function\") ? x.toString() : x;\n        }\n        if (ans === \"[object Object]\") {\n            return ρσ_repr_js_builtin(x);\n        }\n        try {\n            ans = JSON.stringify(x);\n        } catch (ρσ_Exception) {\n            ρσ_last_exception = ρσ_Exception;\n            {\n            } \n        }\n    }\n    return ans + \"\";\n};\nif (!ρσ_repr.__argnames__) Object.defineProperties(ρσ_repr, {\n    __argnames__ : {value: [\"x\"]}\n});\n\nfunction ρσ_str(x) {\n    var ans, name;\n    if (x === null) {\n        return \"None\";\n    }\n    if (x === undefined) {\n        return \"undefined\";\n    }\n    ans = x;\n    if (typeof x.__str__ === \"function\") {\n        ans = x.__str__();\n    } else if (typeof x.__repr__ === \"function\") {\n        ans = x.__repr__();\n    } else if (x === true || x === false) {\n        ans = (x) ? \"True\" : \"False\";\n    } else if (Array.isArray(x)) {\n        ans = ρσ_repr_js_builtin(x, true);\n    } else if (typeof x.toString === \"function\") {\n        name = Object.prototype.toString.call(x).slice(8, -1);\n        if (ρσ_not_equals(\"Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array\".indexOf(name), -1)) {\n            return name + \"([\" + x.map((function() {\n                var ρσ_anonfunc = function (i) {\n                    return str.format(\"0x{:02x}\", i);\n                };\n                if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                    __argnames__ : {value: [\"i\"]}\n                });\n                return ρσ_anonfunc;\n            })()).join(\", \") + \"])\";\n        }\n        if (typeof HTMLElement !== \"undefined\" && x instanceof HTMLElement) {\n            ans = ρσ_html_element_to_string(x);\n        } else {\n            ans = x.toString();\n        }\n        if (ans === \"[object Object]\") {\n            ans = ρσ_repr_js_builtin(x);\n        }\n    } else if (typeof x === \"object\" && !x.toString) {\n        ans = ρσ_repr_js_builtin(x);\n    }\n    return ans + \"\";\n};\nif (!ρσ_str.__argnames__) Object.defineProperties(ρσ_str, {\n    __argnames__ : {value: [\"x\"]}\n});\n\ndefine_str_func = (function() {\n    var ρσ_anonfunc = function (name, func) {\n        var f;\n        (ρσ_expr_temp = ρσ_str.prototype)[(typeof name === \"number\" && name < 0) ? ρσ_expr_temp.length + name : name] = func;\n        ρσ_str[(typeof name === \"number\" && name < 0) ? ρσ_str.length + name : name] = f = func.call.bind(func);\n        if (func.__argnames__) {\n            Object.defineProperty(f, \"__argnames__\", (function(){\n                var ρσ_d = {};\n                ρσ_d[\"value\"] = ['string'].concat(func.__argnames__);\n                return ρσ_d;\n            }).call(this));\n        }\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"name\", \"func\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_unpack = [String.prototype.split.call.bind(String.prototype.split), String.prototype.replace.call.bind(String.prototype.replace)];\nρσ_orig_split = ρσ_unpack[0];\nρσ_orig_replace = ρσ_unpack[1];\ndefine_str_func(\"format\", function () {\n    var template, args, kwargs, explicit, implicit, idx, split, ans, pos, in_brace, markup, ch;\n    template = this;\n    if (template === undefined) {\n        throw new TypeError(\"Template is required\");\n    }\n    args = Array.prototype.slice.call(arguments);\n    kwargs = {};\n    if (args[args.length-1] && args[args.length-1][ρσ_kwargs_symbol] !== undefined) {\n        kwargs = args[args.length-1];\n        args = args.slice(0, -1);\n    }\n    explicit = implicit = false;\n    idx = 0;\n    split = ρσ_orig_split;\n    if (ρσ_str.format._template_resolve_pat === undefined) {\n        ρσ_str.format._template_resolve_pat = /[.\\[]/;\n    }\n    function resolve(arg, object) {\n        var ρσ_unpack, first, key, rest, ans;\n        if (!arg) {\n            return object;\n        }\n        ρσ_unpack = [arg[0], arg.slice(1)];\n        first = ρσ_unpack[0];\n        arg = ρσ_unpack[1];\n        key = split(arg, ρσ_str.format._template_resolve_pat, 1)[0];\n        rest = arg.slice(key.length);\n        ans = (first === \"[\") ? object[ρσ_bound_index(key.slice(0, -1), object)] : getattr(object, key);\n        if (ans === undefined) {\n            throw new KeyError((first === \"[\") ? key.slice(0, -1) : key);\n        }\n        return resolve(rest, ans);\n    };\n    if (!resolve.__argnames__) Object.defineProperties(resolve, {\n        __argnames__ : {value: [\"arg\", \"object\"]}\n    });\n\n    function resolve_format_spec(format_spec) {\n        if (ρσ_str.format._template_resolve_fs_pat === undefined) {\n            ρσ_str.format._template_resolve_fs_pat = /[{]([a-zA-Z0-9_]+)[}]/g;\n        }\n        return format_spec.replace(ρσ_str.format._template_resolve_fs_pat, (function() {\n            var ρσ_anonfunc = function (match, key) {\n                if (!Object.prototype.hasOwnProperty.call(kwargs, key)) {\n                    return \"\";\n                }\n                return \"\" + kwargs[(typeof key === \"number\" && key < 0) ? kwargs.length + key : key];\n            };\n            if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n                __argnames__ : {value: [\"match\", \"key\"]}\n            });\n            return ρσ_anonfunc;\n        })());\n    };\n    if (!resolve_format_spec.__argnames__) Object.defineProperties(resolve_format_spec, {\n        __argnames__ : {value: [\"format_spec\"]}\n    });\n\n    function apply_formatting(value, format_spec) {\n        var ρσ_unpack, fill, align, sign, fhash, zeropad, width, comma, precision, ftype, is_numeric, is_int, lftype, code, exp, nval, is_positive, left, right;\n        if (format_spec.indexOf(\"{\") !== -1) {\n            format_spec = resolve_format_spec(format_spec);\n        }\n        if (ρσ_str.format._template_format_pat === undefined) {\n            ρσ_str.format._template_format_pat = /([^{}](?=[<>=^]))?([<>=^])?([-+\\x20])?(\\#)?(0)?(\\d+)?(,)?(?:\\.(\\d+))?([bcdeEfFgGnosxX%])?/;\n        }\n        try {\n            ρσ_unpack = format_spec.match(ρσ_str.format._template_format_pat).slice(1);\nρσ_unpack = ρσ_unpack_asarray(9, ρσ_unpack);\n            fill = ρσ_unpack[0];\n            align = ρσ_unpack[1];\n            sign = ρσ_unpack[2];\n            fhash = ρσ_unpack[3];\n            zeropad = ρσ_unpack[4];\n            width = ρσ_unpack[5];\n            comma = ρσ_unpack[6];\n            precision = ρσ_unpack[7];\n            ftype = ρσ_unpack[8];\n        } catch (ρσ_Exception) {\n            ρσ_last_exception = ρσ_Exception;\n            if (ρσ_Exception instanceof TypeError) {\n                return value;\n            } else {\n                throw ρσ_Exception;\n            }\n        }\n        if (zeropad) {\n            fill = fill || \"0\";\n            align = align || \"=\";\n        } else {\n            fill = fill || \" \";\n            align = align || \">\";\n        }\n        is_numeric = Number(value) === value;\n        is_int = is_numeric && value % 1 === 0;\n        precision = parseInt(precision, 10);\n        lftype = (ftype || \"\").toLowerCase();\n        if (ftype === \"n\") {\n            is_numeric = true;\n            if (is_int) {\n                if (comma) {\n                    throw new ValueError(\"Cannot specify ',' with 'n'\");\n                }\n                value = parseInt(value, 10).toLocaleString();\n            } else {\n                value = parseFloat(value).toLocaleString();\n            }\n        } else if (['b', 'c', 'd', 'o', 'x'].indexOf(lftype) !== -1) {\n            value = parseInt(value, 10);\n            is_numeric = true;\n            if (!isNaN(value)) {\n                if (ftype === \"b\") {\n                    value = (value >>> 0).toString(2);\n                    if (fhash) {\n                        value = \"0b\" + value;\n                    }\n                } else if (ftype === \"c\") {\n                    if (value > 65535) {\n                        code = value - 65536;\n                        value = String.fromCharCode(55296 + (code >> 10), 56320 + (code & 1023));\n                    } else {\n                        value = String.fromCharCode(value);\n                    }\n                } else if (ftype === \"d\") {\n                    if (comma) {\n                        value = value.toLocaleString(\"en-US\");\n                    } else {\n                        value = value.toString(10);\n                    }\n                } else if (ftype === \"o\") {\n                    value = value.toString(8);\n                    if (fhash) {\n                        value = \"0o\" + value;\n                    }\n                } else if (lftype === \"x\") {\n                    value = value.toString(16);\n                    value = (ftype === \"x\") ? value.toLowerCase() : value.toUpperCase();\n                    if (fhash) {\n                        value = \"0x\" + value;\n                    }\n                }\n            }\n        } else if (['e','f','g','%'].indexOf(lftype) !== -1) {\n            is_numeric = true;\n            value = parseFloat(value);\n            if (lftype === \"e\") {\n                value = value.toExponential((isNaN(precision)) ? 6 : precision);\n                value = (ftype === \"E\") ? value.toUpperCase() : value.toLowerCase();\n            } else if (lftype === \"f\") {\n                value = value.toFixed((isNaN(precision)) ? 6 : precision);\n                value = (ftype === \"F\") ? value.toUpperCase() : value.toLowerCase();\n            } else if (ftype === \"%\") {\n                value *= 100;\n                value = value.toFixed((isNaN(precision)) ? 6 : precision) + \"%\";\n            } else if (lftype === \"g\") {\n                if (isNaN(precision)) {\n                    precision = 6;\n                }\n                precision = max(1, precision);\n                exp = parseInt(split(value.toExponential(precision - 1).toLowerCase(), \"e\")[1], 10);\n                if (-4 <= exp && exp < precision) {\n                    value = value.toFixed(precision - 1 - exp);\n                } else {\n                    value = value.toExponential(precision - 1);\n                }\n                value = value.replace(/0+$/g, \"\");\n                if (value[value.length-1] === \".\") {\n                    value = value.slice(0, -1);\n                }\n                if (ftype === \"G\") {\n                    value = value.toUpperCase();\n                }\n            }\n        } else {\n            value += \"\";\n            if (!isNaN(precision)) {\n                value = value.slice(0, precision);\n            }\n        }\n        value += \"\";\n        if (is_numeric && sign) {\n            nval = Number(value);\n            is_positive = !isNaN(nval) && nval >= 0;\n            if (is_positive && (sign === \" \" || sign === \"+\")) {\n                value = sign + value;\n            }\n        }\n        function repeat(char, num) {\n            return (new Array(num+1)).join(char);\n        };\n        if (!repeat.__argnames__) Object.defineProperties(repeat, {\n            __argnames__ : {value: [\"char\", \"num\"]}\n        });\n\n        if (is_numeric && width && width[0] === \"0\") {\n            width = width.slice(1);\n            ρσ_unpack = [\"0\", \"=\"];\n            fill = ρσ_unpack[0];\n            align = ρσ_unpack[1];\n        }\n        width = parseInt(width || \"-1\", 10);\n        if (isNaN(width)) {\n            throw new ValueError(\"Invalid width specification: \" + width);\n        }\n        if (fill && value.length < width) {\n            if (align === \"<\") {\n                value = value + repeat(fill, width - value.length);\n            } else if (align === \">\") {\n                value = repeat(fill, width - value.length) + value;\n            } else if (align === \"^\") {\n                left = Math.floor((width - value.length) / 2);\n                right = width - left - value.length;\n                value = repeat(fill, left) + value + repeat(fill, right);\n            } else if (align === \"=\") {\n                if (ρσ_in(value[0], \"+- \")) {\n                    value = value[0] + repeat(fill, width - value.length) + value.slice(1);\n                } else {\n                    value = repeat(fill, width - value.length) + value;\n                }\n            } else {\n                throw new ValueError(\"Unrecognized alignment: \" + align);\n            }\n        }\n        return value;\n    };\n    if (!apply_formatting.__argnames__) Object.defineProperties(apply_formatting, {\n        __argnames__ : {value: [\"value\", \"format_spec\"]}\n    });\n\n    function parse_markup(markup) {\n        var key, transformer, format_spec, pos, state, ch;\n        key = transformer = format_spec = \"\";\n        pos = 0;\n        state = 0;\n        while (pos < markup.length) {\n            ch = markup[(typeof pos === \"number\" && pos < 0) ? markup.length + pos : pos];\n            if (state === 0) {\n                if (ch === \"!\") {\n                    state = 1;\n                } else if (ch === \":\") {\n                    state = 2;\n                } else {\n                    key += ch;\n                }\n            } else if (state === 1) {\n                if (ch === \":\") {\n                    state = 2;\n                } else {\n                    transformer += ch;\n                }\n            } else {\n                format_spec += ch;\n            }\n            pos += 1;\n        }\n        return [key, transformer, format_spec];\n    };\n    if (!parse_markup.__argnames__) Object.defineProperties(parse_markup, {\n        __argnames__ : {value: [\"markup\"]}\n    });\n\n    function render_markup(markup) {\n        var ρσ_unpack, key, transformer, format_spec, lkey, nvalue, object, ans;\n        ρσ_unpack = parse_markup(markup);\nρσ_unpack = ρσ_unpack_asarray(3, ρσ_unpack);\n        key = ρσ_unpack[0];\n        transformer = ρσ_unpack[1];\n        format_spec = ρσ_unpack[2];\n        if (transformer && ['a', 'r', 's'].indexOf(transformer) === -1) {\n            throw new ValueError(\"Unknown conversion specifier: \" + transformer);\n        }\n        lkey = key.length && split(key, /[.\\[]/, 1)[0];\n        if (lkey) {\n            explicit = true;\n            if (implicit) {\n                throw new ValueError(\"cannot switch from automatic field numbering to manual field specification\");\n            }\n            nvalue = parseInt(lkey);\n            object = (isNaN(nvalue)) ? kwargs[(typeof lkey === \"number\" && lkey < 0) ? kwargs.length + lkey : lkey] : args[(typeof nvalue === \"number\" && nvalue < 0) ? args.length + nvalue : nvalue];\n            if (object === undefined) {\n                if (isNaN(nvalue)) {\n                    throw new KeyError(lkey);\n                }\n                throw new IndexError(lkey);\n            }\n            object = resolve(key.slice(lkey.length), object);\n        } else {\n            implicit = true;\n            if (explicit) {\n                throw new ValueError(\"cannot switch from manual field specification to automatic field numbering\");\n            }\n            if (idx >= args.length) {\n                throw new IndexError(\"Not enough arguments to match template: \" + template);\n            }\n            object = args[(typeof idx === \"number\" && idx < 0) ? args.length + idx : idx];\n            idx += 1;\n        }\n        if (typeof object === \"function\") {\n            object = object();\n        }\n        ans = \"\" + object;\n        if (format_spec) {\n            ans = apply_formatting(ans, format_spec);\n        }\n        return ans;\n    };\n    if (!render_markup.__argnames__) Object.defineProperties(render_markup, {\n        __argnames__ : {value: [\"markup\"]}\n    });\n\n    ans = \"\";\n    pos = 0;\n    in_brace = 0;\n    markup = \"\";\n    while (pos < template.length) {\n        ch = template[(typeof pos === \"number\" && pos < 0) ? template.length + pos : pos];\n        if (in_brace) {\n            if (ch === \"{\") {\n                in_brace += 1;\n                markup += \"{\";\n            } else if (ch === \"}\") {\n                in_brace -= 1;\n                if (in_brace > 0) {\n                    markup += \"}\";\n                } else {\n                    ans += render_markup(markup);\n                }\n            } else {\n                markup += ch;\n            }\n        } else {\n            if (ch === \"{\") {\n                if (template[ρσ_bound_index(pos + 1, template)] === \"{\") {\n                    pos += 1;\n                    ans += \"{\";\n                } else {\n                    in_brace = 1;\n                    markup = \"\";\n                }\n            } else {\n                ans += ch;\n                if (ch === \"}\" && template[ρσ_bound_index(pos + 1, template)] === \"}\") {\n                    pos += 1;\n                }\n            }\n        }\n        pos += 1;\n    }\n    if (in_brace) {\n        throw new ValueError(\"expected '}' before end of string\");\n    }\n    return ans;\n});\ndefine_str_func(\"capitalize\", function () {\n    var string;\n    string = this;\n    if (string) {\n        string = string[0].toUpperCase() + string.slice(1).toLowerCase();\n    }\n    return string;\n});\ndefine_str_func(\"center\", (function() {\n    var ρσ_anonfunc = function (width, fill) {\n        var left, right;\n        left = Math.floor((width - this.length) / 2);\n        right = width - left - this.length;\n        fill = fill || \" \";\n        return new Array(left+1).join(fill) + this + new Array(right+1).join(fill);\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"width\", \"fill\"]}\n    });\n    return ρσ_anonfunc;\n})());\ndefine_str_func(\"count\", (function() {\n    var ρσ_anonfunc = function (needle, start, end) {\n        var string, ρσ_unpack, pos, step, ans;\n        string = this;\n        start = start || 0;\n        end = end || string.length;\n        if (start < 0 || end < 0) {\n            string = string.slice(start, end);\n            ρσ_unpack = [0, string.length];\n            start = ρσ_unpack[0];\n            end = ρσ_unpack[1];\n        }\n        pos = start;\n        step = needle.length;\n        if (!step) {\n            return 0;\n        }\n        ans = 0;\n        while (pos !== -1) {\n            pos = string.indexOf(needle, pos);\n            if (pos !== -1) {\n                ans += 1;\n                pos += step;\n            }\n        }\n        return ans;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"needle\", \"start\", \"end\"]}\n    });\n    return ρσ_anonfunc;\n})());\ndefine_str_func(\"endswith\", (function() {\n    var ρσ_anonfunc = function (suffixes, start, end) {\n        var string, q;\n        string = this;\n        start = start || 0;\n        if (typeof suffixes === \"string\") {\n            suffixes = [suffixes];\n        }\n        if (end !== undefined) {\n            string = string.slice(0, end);\n        }\n        for (var i = 0; i < suffixes.length; i++) {\n            q = suffixes[(typeof i === \"number\" && i < 0) ? suffixes.length + i : i];\n            if (string.indexOf(q, Math.max(start, string.length - q.length)) !== -1) {\n                return true;\n            }\n        }\n        return false;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"suffixes\", \"start\", \"end\"]}\n    });\n    return ρσ_anonfunc;\n})());\ndefine_str_func(\"startswith\", (function() {\n    var ρσ_anonfunc = function (prefixes, start, end) {\n        var prefix;\n        start = start || 0;\n        if (typeof prefixes === \"string\") {\n            prefixes = [prefixes];\n        }\n        for (var i = 0; i < prefixes.length; i++) {\n            prefix = prefixes[(typeof i === \"number\" && i < 0) ? prefixes.length + i : i];\n            end = (end === undefined) ? this.length : end;\n            if (end - start >= prefix.length && prefix === this.slice(start, start + prefix.length)) {\n                return true;\n            }\n        }\n        return false;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"prefixes\", \"start\", \"end\"]}\n    });\n    return ρσ_anonfunc;\n})());\ndefine_str_func(\"find\", (function() {\n    var ρσ_anonfunc = function (needle, start, end) {\n        var ans;\n        while (start < 0) {\n            start += this.length;\n        }\n        ans = this.indexOf(needle, start);\n        if (end !== undefined && ans !== -1) {\n            while (end < 0) {\n                end += this.length;\n            }\n            if (ans >= end - needle.length) {\n                return -1;\n            }\n        }\n        return ans;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"needle\", \"start\", \"end\"]}\n    });\n    return ρσ_anonfunc;\n})());\ndefine_str_func(\"rfind\", (function() {\n    var ρσ_anonfunc = function (needle, start, end) {\n        var ans;\n        while (end < 0) {\n            end += this.length;\n        }\n        ans = this.lastIndexOf(needle, end - 1);\n        if (start !== undefined && ans !== -1) {\n            while (start < 0) {\n                start += this.length;\n            }\n            if (ans < start) {\n                return -1;\n            }\n        }\n        return ans;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"needle\", \"start\", \"end\"]}\n    });\n    return ρσ_anonfunc;\n})());\ndefine_str_func(\"index\", (function() {\n    var ρσ_anonfunc = function (needle, start, end) {\n        var ans;\n        ans = ρσ_str.prototype.find.apply(this, arguments);\n        if (ans === -1) {\n            throw new ValueError(\"substring not found\");\n        }\n        return ans;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"needle\", \"start\", \"end\"]}\n    });\n    return ρσ_anonfunc;\n})());\ndefine_str_func(\"rindex\", (function() {\n    var ρσ_anonfunc = function (needle, start, end) {\n        var ans;\n        ans = ρσ_str.prototype.rfind.apply(this, arguments);\n        if (ans === -1) {\n            throw new ValueError(\"substring not found\");\n        }\n        return ans;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"needle\", \"start\", \"end\"]}\n    });\n    return ρσ_anonfunc;\n})());\ndefine_str_func(\"islower\", function () {\n    return this.length > 0 && this.toLowerCase() === this.toString();\n});\ndefine_str_func(\"isupper\", function () {\n    return this.length > 0 && this.toUpperCase() === this.toString();\n});\ndefine_str_func(\"isspace\", function () {\n    return this.length > 0 && /^\\s+$/.test(this);\n});\ndefine_str_func(\"join\", (function() {\n    var ρσ_anonfunc = function (iterable) {\n        var ans, r;\n        if (Array.isArray(iterable)) {\n            return iterable.join(this);\n        }\n        ans = \"\";\n        r = iterable.next();\n        while (!r.done) {\n            if (ans) {\n                ans += this;\n            }\n            ans += r.value;\n            r = iterable.next();\n        }\n        return ans;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"iterable\"]}\n    });\n    return ρσ_anonfunc;\n})());\ndefine_str_func(\"ljust\", (function() {\n    var ρσ_anonfunc = function (width, fill) {\n        var string;\n        string = this;\n        if (width > string.length) {\n            fill = fill || \" \";\n            string += new Array(width - string.length + 1).join(fill);\n        }\n        return string;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"width\", \"fill\"]}\n    });\n    return ρσ_anonfunc;\n})());\ndefine_str_func(\"rjust\", (function() {\n    var ρσ_anonfunc = function (width, fill) {\n        var string;\n        string = this;\n        if (width > string.length) {\n            fill = fill || \" \";\n            string = new Array(width - string.length + 1).join(fill) + string;\n        }\n        return string;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"width\", \"fill\"]}\n    });\n    return ρσ_anonfunc;\n})());\ndefine_str_func(\"lower\", function () {\n    return this.toLowerCase();\n});\ndefine_str_func(\"upper\", function () {\n    return this.toUpperCase();\n});\ndefine_str_func(\"lstrip\", (function() {\n    var ρσ_anonfunc = function (chars) {\n        var string, pos;\n        string = this;\n        pos = 0;\n        chars = chars || ρσ_str.whitespace;\n        while (chars.indexOf(string[(typeof pos === \"number\" && pos < 0) ? string.length + pos : pos]) !== -1) {\n            pos += 1;\n        }\n        if (pos) {\n            string = string.slice(pos);\n        }\n        return string;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"chars\"]}\n    });\n    return ρσ_anonfunc;\n})());\ndefine_str_func(\"rstrip\", (function() {\n    var ρσ_anonfunc = function (chars) {\n        var string, pos;\n        string = this;\n        pos = string.length - 1;\n        chars = chars || ρσ_str.whitespace;\n        while (chars.indexOf(string[(typeof pos === \"number\" && pos < 0) ? string.length + pos : pos]) !== -1) {\n            pos -= 1;\n        }\n        if (pos < string.length - 1) {\n            string = string.slice(0, pos + 1);\n        }\n        return string;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"chars\"]}\n    });\n    return ρσ_anonfunc;\n})());\ndefine_str_func(\"strip\", (function() {\n    var ρσ_anonfunc = function (chars) {\n        return ρσ_str.prototype.lstrip.call(ρσ_str.prototype.rstrip.call(this, chars), chars);\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"chars\"]}\n    });\n    return ρσ_anonfunc;\n})());\ndefine_str_func(\"partition\", (function() {\n    var ρσ_anonfunc = function (sep) {\n        var idx;\n        idx = this.indexOf(sep);\n        if (idx === -1) {\n            return [this, \"\", \"\"];\n        }\n        return [this.slice(0, idx), sep, this.slice(idx + sep.length)];\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"sep\"]}\n    });\n    return ρσ_anonfunc;\n})());\ndefine_str_func(\"rpartition\", (function() {\n    var ρσ_anonfunc = function (sep) {\n        var idx;\n        idx = this.lastIndexOf(sep);\n        if (idx === -1) {\n            return [\"\", \"\", this];\n        }\n        return [this.slice(0, idx), sep, this.slice(idx + sep.length)];\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"sep\"]}\n    });\n    return ρσ_anonfunc;\n})());\ndefine_str_func(\"replace\", (function() {\n    var ρσ_anonfunc = function (old, repl, count) {\n        var string, pos, idx;\n        string = this;\n        if (count === 1) {\n            return ρσ_orig_replace(string, old, repl);\n        }\n        if (count < 1) {\n            return string;\n        }\n        count = count || Number.MAX_VALUE;\n        pos = 0;\n        while (count > 0) {\n            count -= 1;\n            idx = string.indexOf(old, pos);\n            if (idx === -1) {\n                break;\n            }\n            pos = idx + repl.length;\n            string = string.slice(0, idx) + repl + string.slice(idx + old.length);\n        }\n        return string;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"old\", \"repl\", \"count\"]}\n    });\n    return ρσ_anonfunc;\n})());\ndefine_str_func(\"split\", (function() {\n    var ρσ_anonfunc = function (sep, maxsplit) {\n        var split, ans, extra, parts;\n        if (maxsplit === 0) {\n            return ρσ_list_decorate([ this ]);\n        }\n        split = ρσ_orig_split;\n        if (sep === undefined || sep === null) {\n            if (maxsplit > 0) {\n                ans = split(this, /(\\s+)/);\n                extra = \"\";\n                parts = [];\n                for (var i = 0; i < ans.length; i++) {\n                    if (parts.length >= maxsplit + 1) {\n                        extra += ans[(typeof i === \"number\" && i < 0) ? ans.length + i : i];\n                    } else if (i % 2 === 0) {\n                        parts.push(ans[(typeof i === \"number\" && i < 0) ? ans.length + i : i]);\n                    }\n                }\n                parts[parts.length-1] += extra;\n                ans = parts;\n            } else {\n                ans = split(this, /\\s+/);\n            }\n        } else {\n            if (sep === \"\") {\n                throw new ValueError(\"empty separator\");\n            }\n            ans = split(this, sep);\n            if (maxsplit > 0 && ans.length > maxsplit) {\n                extra = ans.slice(maxsplit).join(sep);\n                ans = ans.slice(0, maxsplit);\n                ans.push(extra);\n            }\n        }\n        return ρσ_list_decorate(ans);\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"sep\", \"maxsplit\"]}\n    });\n    return ρσ_anonfunc;\n})());\ndefine_str_func(\"rsplit\", (function() {\n    var ρσ_anonfunc = function (sep, maxsplit) {\n        var split, ans, is_space, pos, current, spc, ch, end, idx;\n        if (!maxsplit) {\n            return ρσ_str.prototype.split.call(this, sep);\n        }\n        split = ρσ_orig_split;\n        if (sep === undefined || sep === null) {\n            if (maxsplit > 0) {\n                ans = [];\n                is_space = /\\s/;\n                pos = this.length - 1;\n                current = \"\";\n                while (pos > -1 && maxsplit > 0) {\n                    spc = false;\n                    ch = (ρσ_expr_temp = this)[(typeof pos === \"number\" && pos < 0) ? ρσ_expr_temp.length + pos : pos];\n                    while (pos > -1 && is_space.test(ch)) {\n                        spc = true;\n                        ch = this[--pos];\n                    }\n                    if (spc) {\n                        if (current) {\n                            ans.push(current);\n                            maxsplit -= 1;\n                        }\n                        current = ch;\n                    } else {\n                        current += ch;\n                    }\n                    pos -= 1;\n                }\n                ans.push(this.slice(0, pos + 1) + current);\n                ans.reverse();\n            } else {\n                ans = split(this, /\\s+/);\n            }\n        } else {\n            if (sep === \"\") {\n                throw new ValueError(\"empty separator\");\n            }\n            ans = [];\n            pos = end = this.length;\n            while (pos > -1 && maxsplit > 0) {\n                maxsplit -= 1;\n                idx = this.lastIndexOf(sep, pos);\n                if (idx === -1) {\n                    break;\n                }\n                ans.push(this.slice(idx + sep.length, end));\n                pos = idx - 1;\n                end = idx;\n            }\n            ans.push(this.slice(0, end));\n            ans.reverse();\n        }\n        return ρσ_list_decorate(ans);\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"sep\", \"maxsplit\"]}\n    });\n    return ρσ_anonfunc;\n})());\ndefine_str_func(\"splitlines\", (function() {\n    var ρσ_anonfunc = function (keepends) {\n        var split, parts, ans;\n        split = ρσ_orig_split;\n        if (keepends) {\n            parts = split(this, /((?:\\r?\\n)|\\r)/);\n            ans = [];\n            for (var i = 0; i < parts.length; i++) {\n                if (i % 2 === 0) {\n                    ans.push(parts[(typeof i === \"number\" && i < 0) ? parts.length + i : i]);\n                } else {\n                    ans[ans.length-1] += parts[(typeof i === \"number\" && i < 0) ? parts.length + i : i];\n                }\n            }\n        } else {\n            ans = split(this, /(?:\\r?\\n)|\\r/);\n        }\n        return ρσ_list_decorate(ans);\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"keepends\"]}\n    });\n    return ρσ_anonfunc;\n})());\ndefine_str_func(\"swapcase\", function () {\n    var ans, a, b;\n    ans = new Array(this.length);\n    for (var i = 0; i < ans.length; i++) {\n        a = (ρσ_expr_temp = this)[(typeof i === \"number\" && i < 0) ? ρσ_expr_temp.length + i : i];\n        b = a.toLowerCase();\n        if (a === b) {\n            b = a.toUpperCase();\n        }\n        ans[(typeof i === \"number\" && i < 0) ? ans.length + i : i] = b;\n    }\n    return ans.join(\"\");\n});\ndefine_str_func(\"zfill\", (function() {\n    var ρσ_anonfunc = function (width) {\n        var string;\n        string = this;\n        if (width > string.length) {\n            string = new Array(width - string.length + 1).join(\"0\") + string;\n        }\n        return string;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"width\"]}\n    });\n    return ρσ_anonfunc;\n})());\nρσ_str.uchrs = (function() {\n    var ρσ_anonfunc = function (string, with_positions) {\n        return (function(){\n            var ρσ_d = {};\n            ρσ_d[\"_string\"] = string;\n            ρσ_d[\"_pos\"] = 0;\n            ρσ_d[ρσ_iterator_symbol] = function () {\n                return this;\n            };\n            ρσ_d[\"next\"] = function () {\n                var length, pos, value, ans, extra;\n                length = this._string.length;\n                if (this._pos >= length) {\n                    return (function(){\n                        var ρσ_d = {};\n                        ρσ_d[\"done\"] = true;\n                        return ρσ_d;\n                    }).call(this);\n                }\n                pos = this._pos;\n                value = this._string.charCodeAt(this._pos++);\n                ans = \"\\ufffd\";\n                if (55296 <= value && value <= 56319) {\n                    if (this._pos < length) {\n                        extra = this._string.charCodeAt(this._pos++);\n                        if ((extra & 56320) === 56320) {\n                            ans = String.fromCharCode(value, extra);\n                        }\n                    }\n                } else if ((value & 56320) !== 56320) {\n                    ans = String.fromCharCode(value);\n                }\n                if (with_positions) {\n                    return (function(){\n                        var ρσ_d = {};\n                        ρσ_d[\"done\"] = false;\n                        ρσ_d[\"value\"] = ρσ_list_decorate([ pos, ans ]);\n                        return ρσ_d;\n                    }).call(this);\n                } else {\n                    return (function(){\n                        var ρσ_d = {};\n                        ρσ_d[\"done\"] = false;\n                        ρσ_d[\"value\"] = ans;\n                        return ρσ_d;\n                    }).call(this);\n                }\n            };\n            return ρσ_d;\n        }).call(this);\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"string\", \"with_positions\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_str.uslice = (function() {\n    var ρσ_anonfunc = function (string, start, end) {\n        var items, iterator, r;\n        items = [];\n        iterator = ρσ_str.uchrs(string);\n        r = iterator.next();\n        while (!r.done) {\n            items.push(r.value);\n            r = iterator.next();\n        }\n        return items.slice(start || 0, (end === undefined) ? items.length : end).join(\"\");\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"string\", \"start\", \"end\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_str.ulen = (function() {\n    var ρσ_anonfunc = function (string) {\n        var iterator, r, ans;\n        iterator = ρσ_str.uchrs(string);\n        r = iterator.next();\n        ans = 0;\n        while (!r.done) {\n            r = iterator.next();\n            ans += 1;\n        }\n        return ans;\n    };\n    if (!ρσ_anonfunc.__argnames__) Object.defineProperties(ρσ_anonfunc, {\n        __argnames__ : {value: [\"string\"]}\n    });\n    return ρσ_anonfunc;\n})();\nρσ_str.ascii_lowercase = \"abcdefghijklmnopqrstuvwxyz\";\nρσ_str.ascii_uppercase = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\nρσ_str.ascii_letters = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\nρσ_str.digits = \"0123456789\";\nρσ_str.punctuation = \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\";\nρσ_str.printable = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~ \\t\\n\\r\\u000b\\f\";\nρσ_str.whitespace = \" \\t\\n\\r\\u000b\\f\";\ndefine_str_func = undefined;\nvar str = ρσ_str, repr = ρσ_repr;","tools/web_repl.js":"/* vim:fileencoding=utf-8\n * \n * Copyright (C) 2016 Kovid Goyal <kovid at kovidgoyal.net>\n *\n * Distributed under terms of the BSD license\n */\n\"use strict\";  /*jshint node:true */\nvar vm = require('vm');\nvar embedded_compiler = require('tools/embedded_compiler.js');\n\nmodule.exports = function(compiler, baselib) {\n    var ctx = vm.createContext();\n    var LINE_CONTINUATION_CHARS = ':\\\\';\n    var find_completions = null;\n    var streaming_compiler = embedded_compiler(compiler, baselib, function(js) { return vm.runInContext(js, ctx); }, '__repl__');\n\n    return {\n        'in_block_mode': false,\n\n        'replace_print': function replace_print(write_line_func) {\n            ctx.print = function() {\n                var parts = [];\n                for (var i = 0; i < arguments.length; i++) \n                    parts.push(ctx.ρσ_str(arguments[i]));\n                write_line_func(parts.join(' '));\n            };\n        },\n\n        'is_input_complete': function is_input_complete(source) {\n            if (!source || !source.trim()) return false;\n            var lines = source.split('\\n');\n            var last_line = lines[lines.length - 1].trimRight();\n            if (this.in_block_mode) {\n                // In a block only exit after two blank lines\n                if (lines.length < 2) return false;\n                var second_last_line = lines[lines.length - 2].trimRight();\n                var block_ended = !!(!last_line && !second_last_line);\n                if (!block_ended) return false;\n                this.in_block_mode = false;\n                return true;\n            }\n\n            if (last_line && LINE_CONTINUATION_CHARS.indexOf(last_line.substr(last_line.length - 1)) > -1) {\n                this.in_block_mode = true;\n                return false;\n            }\n            try {\n                compiler.parse(source, {'filename': '<repl>', 'basedir': '__stdlib__'});\n            } catch(e) {\n                if (e.is_eof && e.line === lines.length && e.col > 0) {\n                    return false;\n                }\n                this.in_block_mode = false;\n                return true;\n            }\n            this.in_block_mode = false;\n            return true;\n        },\n\n        'compile': function web_repl_compile(code, opts) {\n            opts = opts || {};\n            opts.keep_docstrings = true;\n            opts.filename = '<input>';\n            return streaming_compiler.compile(code, opts);\n        },\n\n        'runjs': function runjs(code) {\n            var ans = vm.runInContext(code, ctx);\n            if (ans !== undefined || ans === null) {\n                ctx.ρσ_repl_val = ans;\n                var q = vm.runInContext('ρσ_repr(ρσ_repl_val)', ctx);\n                ans = (q === 'undefined') ? ans.toString() : q;\n            }\n            return ans;\n        },\n\n        'init_completions': function init_completions(completelib) {\n            find_completions = completelib(compiler);\n        },\n\n        'find_completions': function find_completions_(line) {\n            return find_completions(line, ctx);\n        },\n\n    };\n};\n\n","tools/embedded_compiler.js":"/* vim:fileencoding=utf-8\n * \n * Copyright (C) 2016 Kovid Goyal <kovid at kovidgoyal.net>\n *\n * Distributed under terms of the BSD license\n */\n\"use strict\";  /*jshint node:true */\n\nvar has_prop = Object.prototype.hasOwnProperty.call.bind(Object.prototype.hasOwnProperty);\n\nmodule.exports = function(compiler, baselib, runjs, name) {\n    var LINE_CONTINUATION_CHARS = ':\\\\';\n    runjs = runjs || eval;\n    runjs(print_ast(compiler.parse(''), true));\n    runjs('var __name__ = \"' + (name || '__embedded__') + '\";');\n\n    function print_ast(ast, keep_baselib, keep_docstrings, js_version) {\n        var output_options = {omit_baselib:!keep_baselib, write_name:false, private_scope:false, beautify:true, js_version: (js_version || 6), keep_docstrings:keep_docstrings};\n        if (keep_baselib) output_options.baselib_plain = baselib;\n        var output = new compiler.OutputStream(output_options);\n        ast.print(output);\n        return output.get();\n    }\n\n    return {\n        'toplevel': null,\n\n        'compile': function streaming_compile(code, opts) {\n            opts = opts || {};\n            var classes = (this.toplevel) ? this.toplevel.classes : undefined;\n            var scoped_flags = (this.toplevel) ? this.toplevel.scoped_flags: undefined;\n            this.toplevel = compiler.parse(code, {\n                'filename': opts.filename || '<embedded>',\n                'basedir': '__stdlib__',\n                'classes': classes,\n                'scoped_flags': scoped_flags,\n                'discard_asserts': opts.discard_asserts,\n            });\n            var ans = print_ast(this.toplevel, false, opts.keep_docstrings, opts.js_version);\n            if (classes) {\n                var exports = {};\n                var self = this;\n                this.toplevel.exports.forEach(function (name) { exports[name] = true; });\n                Object.getOwnPropertyNames(classes).forEach(function (name) {\n                    if (!has_prop(exports, name) && !has_prop(self.toplevel.classes, name))\n                        self.toplevel.classes[name] = classes[name];\n                });\n            }\n            scoped_flags = this.toplevel.scoped_flags;\n    \n            return ans;\n        },\n\n    };\n};\n\n","tools/utils.js":"/* vim:fileencoding=utf-8\n * \n * Copyright (C) 2015 Kovid Goyal <kovid at kovidgoyal.net>\n *\n * Distributed under terms of the BSD license\n */\n\"use strict\";  /*jshint node:true */\n\nvar comment_contents = /\\/\\*!?(?:\\@preserve)?[ \\t]*(?:\\r\\n|\\n)([\\s\\S]*?)(?:\\r\\n|\\n)[ \\t]*\\*\\//;\nvar colors = ['red', 'green', 'yellow', 'blue', 'magenta', 'cyan', 'white'];\n\nfunction ansi(code) {\n    code = code || 0;\n    return String.fromCharCode(27) + '[' + code + 'm';\n}\n\nfunction path_exists(path) {\n    var fs = require('fs');\n    try {\n        fs.statSync(path);\n        return true;\n    } catch(e) {\n        if (e.code != 'ENOENT') throw e;\n    }\n}\n\nfunction colored(string, color, bold) {\n    var prefix = [];\n    if (bold) prefix.push(ansi(1));\n    if (color) prefix.push(ansi(colors.indexOf(color) + 31));\n    return prefix.join('') + string + ansi(0);\n}\n\nfunction supports_color(stdout) {\n    stdout = stdout || process.stdout;\n\tif (stdout && !stdout.isTTY) {\n\t\treturn false;\n\t}\n\n\tif (process.platform === 'win32') {\n\t\treturn false;\n\t}\n\n\tif ('COLORTERM' in process.env) {\n\t\treturn true;\n\t}\n\n\tif (process.env.TERM === 'dumb') {\n\t\treturn false;\n\t}\n\n\tif (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {\n\t\treturn true;\n\t}\n\n    return false;\n\n}\n\nfunction safe_colored(string) {\n    return string;\n}\n\nfunction repeat(str, num) {\n    return new Array( num + 1 ).join( str );\n}\n\nfunction generators_available() {\n    var gen;\n    try {\n        eval('gen = function *(){}'); // jshint ignore:line\n        return typeof gen === 'function' && gen.constructor.name == 'GeneratorFunction';\n    } catch(e) {\n        return false;\n    }\n}\n\nfunction wrap(lines, width) {\n\tvar ans = [];\n\tvar prev = '';\n\tlines.forEach(function (line) {\n\t\tline = prev + line;\n\t\tprev = '';\n\t\tif (line.length > width) {\n\t\t\tprev = line.substr(width);\n            if (prev) prev += ' ';\n\t\t\tline = line.substr(0, width - 1);\n\t\t\tif (line.substr(line.length - 1 !== ' ')) line += '-';\n\t\t} \n\t\tans.push(line);\n\t});\n\tif (prev) ans = ans.concat(wrap([prev]));\n\treturn ans;\n}\n\nfunction merge() {\n    // Simple merge of properties from all objects\n    var ans = {};\n    Array.prototype.slice.call(arguments).forEach(function (arg) {\n        Object.keys(arg).forEach(function(key) {\n            ans[key] = arg[key];\n        });\n    });\n    return ans;\n}\n\nfunction get_import_dirs(paths_string, ignore_env) {\n    var path = require('path');\n    var paths = [];\n    function merge(new_path) {\n        if (paths.indexOf(new_path) == -1) paths.push(new_path);\n    }\n    if (!ignore_env && process && process.env && process.env.RAPYDSCRIPT_IMPORT_PATH) {\n        process.env.RAPYDSCRIPT_IMPORT_PATH.split(path.delimiter).forEach(merge);\n    }\n    if (paths_string) paths_string.split(path.delimiter).forEach(merge);\n    return paths;\n}\n\nexports.comment_contents = comment_contents;\nexports.repeat = repeat;\nexports.wrap = wrap;\nexports.merge = merge;\nexports.colored = colored;\nexports.safe_colored = (supports_color()) ? colored : safe_colored;\nexports.generators_available = generators_available;\nexports.get_import_dirs = get_import_dirs;\nexports.path_exists = path_exists;\n","tools/completer.js":"/* vim:fileencoding=utf-8\n * \n * Copyright (C) 2016 Kovid Goyal <kovid at kovidgoyal.net>\n *\n * Distributed under terms of the BSD license\n */\n\n\nmodule.exports = function(compiler, options) {\n    \"use strict\";\n    var all_keywords = compiler.ALL_KEYWORDS.split(' ');\n    var vm = require('vm');\n    options = options || {};\n    if (!options.enum_global) options.enum_global = \"var global = Function('return this')(); Object.getOwnPropertyNames(global);\";\n\n    function global_names(ctx) {\n        try {\n            var ans = vm.runInContext(options.enum_global, ctx);\n            ans = ans.concat(all_keywords);\n            ans.sort();\n            var seen = {};\n            ans.filter(function (item) { \n                if (Object.prototype.hasOwnProperty.call(seen, item)) return false;\n                seen[item] = true;\n                return true;\n            });\n            return ans;\n        } catch(e) {\n            console.log(e.stack || e.toString());\n        }\n        return [];\n    }\n\n    function object_names(obj, prefix) {\n        if (obj === null || obj === undefined) return [];\n        var groups = [], prefix_len = prefix.length, p;\n\n        function prefix_filter(name) { return (prefix_len) ? (name.substr(0, prefix_len) === prefix) : true; }\n\n        function add(o) {\n            var items = Object.getOwnPropertyNames(o).filter(prefix_filter);\n            if (items.length) groups.push(items);\n        }\n\n        if (typeof obj === 'object' || typeof obj === 'function') {\n            add(obj);\n            p = Object.getPrototypeOf(obj);\n        } else p = obj.constructor ? obj.constructor.prototype : null; \n\n        // Walk the prototype chain\n        try {\n            var sentinel = 5;\n            while (p !== null && sentinel > 0) {\n                add(p);\n                p = Object.getPrototypeOf(p);\n                // Circular refs possible? Let's guard against that.\n                sentinel--;\n            }\n        } catch (e) {\n            // console.error(\"completion error walking prototype chain:\" + e);\n        }\n        if (!groups.length) return [];\n        var seen = {}, ans = [];\n        function uniq(name) {\n            if (Object.prototype.hasOwnProperty.call(seen, name)) return false;\n            seen[name] = true;\n            return true;\n        }\n        for (var i = 0; i < groups.length; i++) {\n            var group = groups[i];\n            group.sort();\n            ans = ans.concat(group.filter(uniq));\n            ans.push('');  // group separator\n\n        }\n        while (ans.length && ans[ans.length - 1] === '') ans.pop();\n        return ans;\n    }\n\n    function prefix_matches(prefix, items) {\n        var len = prefix.length;\n        var ans = items.filter(function(item) { return item.substr(0, len) === prefix; });\n        ans.sort();\n        return ans;\n    }\n\n    function find_completions(line, ctx) {\n        var t;\n        try {\n            t = compiler.tokenizer(line, '<repl>');\n        } catch(e) { return []; }\n        var tokens = [], token;\n        while (true) {\n            try {\n                token = t();\n            } catch (e) { return []; }\n            if (token.type === 'eof') break;\n            if (token.type === 'punc' && '(){},;:'.indexOf(token.value) > -1)\n                tokens = [];\n            tokens.push(token);\n        }\n        if (!tokens.length) {\n            // New line or trailing space\n            return [global_names(ctx), ''];\n        }\n        var last_tok = tokens[tokens.length - 1];\n        if (last_tok.value === '.' || (last_tok.type === 'name' && compiler.IDENTIFIER_PAT.test(last_tok.value))) {\n            last_tok = last_tok.value;\n            if (last_tok === '.') {\n                tokens.push({'value':''});\n                last_tok = '';\n            }\n            if (tokens.length > 1 && tokens[tokens.length - 2].value === '.') {\n                // A compound expression\n                var prefix = '', result;\n                tokens.slice(0, tokens.length - 2).forEach(function (tok) { prefix += tok.value; });\n                if (prefix) {\n                    try {\n                        result = vm.runInContext(prefix, ctx, {'displayErrors':false});\n                    } catch(e) { return []; }\n                    return [object_names(result, last_tok), last_tok];\n                }\n            } else {\n                return [prefix_matches(last_tok, global_names(ctx)), last_tok];\n            }\n        }\n        return [];\n    }\n\n    return find_completions;\n};\n","__stdlib__/aes.pyj":"# vim:fileencoding=utf-8\n# License: BSD Copyright: 2016, Kovid Goyal <kovid at kovidgoyal.net>\n\n# globals: crypto\n\n# Internal API {{{\n\ndef string_to_bytes_encoder(string):\n    return TextEncoder('utf-8').encode(string + '')\n\ndef string_to_bytes_slow(string):\n    escstr = encodeURIComponent(string)\n    binstr = escstr.replace(/%([0-9A-F]{2})/g, def(match, p1):\n        return String.fromCharCode('0x' + p1)\n    )\n    ua = Uint8Array(binstr.length)\n    for i, ch in enumerate(binstr):\n        ua[i] = ch.charCodeAt(0)\n    return ua\n\ndef as_hex(array, sep=''):\n    num = array.BYTES_PER_ELEMENT or 1\n    fmt = '{:0' + num * 2 + 'x}'\n    return [str.format(fmt, x) for x in array].join(sep)\n\ndef bytes_to_string_decoder(bytes, offset):\n    offset = offset or 0\n    if offset:\n        bytes = bytes.subarray(offset)\n    return TextDecoder('utf-8').decode(bytes)\n\ndef bytes_to_string_slow(bytes, offset):\n    ans = v'[]'\n    i = offset or 0\n    while i < bytes.length:\n        c = bytes[i]\n        if c < 128:\n            ans.push(String.fromCharCode(c))\n            i += 1\n        elif 191 < c < 224:\n            ans.push(String.fromCharCode(((c & 0x1f) << 6) | (bytes[i + 1] & 0x3f)))\n            i += 2\n        else:\n            ans.push(String.fromCharCode(((c & 0x0f) << 12) | ((bytes[i + 1] & 0x3f) << 6) | (bytes[i + 2] & 0x3f)))\n            i += 3\n    return ans.join('')\n\nstring_to_bytes = string_to_bytes_encoder if jstype(TextEncoder) is 'function' else string_to_bytes_slow\nbytes_to_string = bytes_to_string_decoder if jstype(TextDecoder) is 'function' else bytes_to_string_slow\n\ndef increment_counter(c):\n    # c must be a Uint8Array of length 16\n    for v'var i = 15; i >= 12; i--':\n        if c[i] is 255:\n            c[i] = 0\n        else:\n            c[i] += 1\n            break\n\ndef convert_to_int32(bytes, output, offset, length):\n    offset = offset or 0\n    length = length or bytes.length\n    for v'var i = offset, j = 0; i < offset + length; i += 4, j++':\n        output[j] = (bytes[i] << 24) | (bytes[i + 1] << 16) | (bytes[i + 2] <<  8) | bytes[i + 3]\n\ndef convert_to_int32_pad(bytes):\n    extra = bytes.length % 4\n    if extra:\n        t = Uint8Array(bytes.length + 4 - extra)\n        t.set(bytes)\n        bytes = t\n    ans = Uint32Array(bytes.length / 4)\n    convert_to_int32(bytes, ans)\n    return ans\n\nif not Uint8Array.prototype.fill:\n    Uint8Array.prototype.fill = Uint32Array.prototype.fill = def(val, start, end):\n        start = start or 0\n        if end is undefined:\n            end = this.length\n        if start < 0:\n            start += this.length\n        if end < 0:\n            end += this.length\n        for v'var i = start; i < end; i++':\n            this[i] = val\n\ndef from_64_to_32(num):\n  # convert 64-bit number to two BE Int32s\n  ans = Uint32Array(2)\n  ans[0] = (num / 0x100000000) | 0\n  ans[1] = num & 0xFFFFFFFF\n  return ans\n\n# Lookup tables for AES {{{\n# Number of rounds by keysize\nnumber_of_rounds = {16: 10, 24: 12, 32: 14}\n# Round constant words\nrcon = v'new Uint32Array([0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91])'\n\n# S-box and Inverse S-box (S is for Substitution)\nS = v'new Uint32Array([0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16])'\nSi = v'new Uint32Array([0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d])'\n\n# Transformations for encryption\nT1 = v'new Uint32Array([0xc66363a5, 0xf87c7c84, 0xee777799, 0xf67b7b8d, 0xfff2f20d, 0xd66b6bbd, 0xde6f6fb1, 0x91c5c554, 0x60303050, 0x02010103, 0xce6767a9, 0x562b2b7d, 0xe7fefe19, 0xb5d7d762, 0x4dababe6, 0xec76769a, 0x8fcaca45, 0x1f82829d, 0x89c9c940, 0xfa7d7d87, 0xeffafa15, 0xb25959eb, 0x8e4747c9, 0xfbf0f00b, 0x41adadec, 0xb3d4d467, 0x5fa2a2fd, 0x45afafea, 0x239c9cbf, 0x53a4a4f7, 0xe4727296, 0x9bc0c05b, 0x75b7b7c2, 0xe1fdfd1c, 0x3d9393ae, 0x4c26266a, 0x6c36365a, 0x7e3f3f41, 0xf5f7f702, 0x83cccc4f, 0x6834345c, 0x51a5a5f4, 0xd1e5e534, 0xf9f1f108, 0xe2717193, 0xabd8d873, 0x62313153, 0x2a15153f, 0x0804040c, 0x95c7c752, 0x46232365, 0x9dc3c35e, 0x30181828, 0x379696a1, 0x0a05050f, 0x2f9a9ab5, 0x0e070709, 0x24121236, 0x1b80809b, 0xdfe2e23d, 0xcdebeb26, 0x4e272769, 0x7fb2b2cd, 0xea75759f, 0x1209091b, 0x1d83839e, 0x582c2c74, 0x341a1a2e, 0x361b1b2d, 0xdc6e6eb2, 0xb45a5aee, 0x5ba0a0fb, 0xa45252f6, 0x763b3b4d, 0xb7d6d661, 0x7db3b3ce, 0x5229297b, 0xdde3e33e, 0x5e2f2f71, 0x13848497, 0xa65353f5, 0xb9d1d168, 0x00000000, 0xc1eded2c, 0x40202060, 0xe3fcfc1f, 0x79b1b1c8, 0xb65b5bed, 0xd46a6abe, 0x8dcbcb46, 0x67bebed9, 0x7239394b, 0x944a4ade, 0x984c4cd4, 0xb05858e8, 0x85cfcf4a, 0xbbd0d06b, 0xc5efef2a, 0x4faaaae5, 0xedfbfb16, 0x864343c5, 0x9a4d4dd7, 0x66333355, 0x11858594, 0x8a4545cf, 0xe9f9f910, 0x04020206, 0xfe7f7f81, 0xa05050f0, 0x783c3c44, 0x259f9fba, 0x4ba8a8e3, 0xa25151f3, 0x5da3a3fe, 0x804040c0, 0x058f8f8a, 0x3f9292ad, 0x219d9dbc, 0x70383848, 0xf1f5f504, 0x63bcbcdf, 0x77b6b6c1, 0xafdada75, 0x42212163, 0x20101030, 0xe5ffff1a, 0xfdf3f30e, 0xbfd2d26d, 0x81cdcd4c, 0x180c0c14, 0x26131335, 0xc3ecec2f, 0xbe5f5fe1, 0x359797a2, 0x884444cc, 0x2e171739, 0x93c4c457, 0x55a7a7f2, 0xfc7e7e82, 0x7a3d3d47, 0xc86464ac, 0xba5d5de7, 0x3219192b, 0xe6737395, 0xc06060a0, 0x19818198, 0x9e4f4fd1, 0xa3dcdc7f, 0x44222266, 0x542a2a7e, 0x3b9090ab, 0x0b888883, 0x8c4646ca, 0xc7eeee29, 0x6bb8b8d3, 0x2814143c, 0xa7dede79, 0xbc5e5ee2, 0x160b0b1d, 0xaddbdb76, 0xdbe0e03b, 0x64323256, 0x743a3a4e, 0x140a0a1e, 0x924949db, 0x0c06060a, 0x4824246c, 0xb85c5ce4, 0x9fc2c25d, 0xbdd3d36e, 0x43acacef, 0xc46262a6, 0x399191a8, 0x319595a4, 0xd3e4e437, 0xf279798b, 0xd5e7e732, 0x8bc8c843, 0x6e373759, 0xda6d6db7, 0x018d8d8c, 0xb1d5d564, 0x9c4e4ed2, 0x49a9a9e0, 0xd86c6cb4, 0xac5656fa, 0xf3f4f407, 0xcfeaea25, 0xca6565af, 0xf47a7a8e, 0x47aeaee9, 0x10080818, 0x6fbabad5, 0xf0787888, 0x4a25256f, 0x5c2e2e72, 0x381c1c24, 0x57a6a6f1, 0x73b4b4c7, 0x97c6c651, 0xcbe8e823, 0xa1dddd7c, 0xe874749c, 0x3e1f1f21, 0x964b4bdd, 0x61bdbddc, 0x0d8b8b86, 0x0f8a8a85, 0xe0707090, 0x7c3e3e42, 0x71b5b5c4, 0xcc6666aa, 0x904848d8, 0x06030305, 0xf7f6f601, 0x1c0e0e12, 0xc26161a3, 0x6a35355f, 0xae5757f9, 0x69b9b9d0, 0x17868691, 0x99c1c158, 0x3a1d1d27, 0x279e9eb9, 0xd9e1e138, 0xebf8f813, 0x2b9898b3, 0x22111133, 0xd26969bb, 0xa9d9d970, 0x078e8e89, 0x339494a7, 0x2d9b9bb6, 0x3c1e1e22, 0x15878792, 0xc9e9e920, 0x87cece49, 0xaa5555ff, 0x50282878, 0xa5dfdf7a, 0x038c8c8f, 0x59a1a1f8, 0x09898980, 0x1a0d0d17, 0x65bfbfda, 0xd7e6e631, 0x844242c6, 0xd06868b8, 0x824141c3, 0x299999b0, 0x5a2d2d77, 0x1e0f0f11, 0x7bb0b0cb, 0xa85454fc, 0x6dbbbbd6, 0x2c16163a])'\nT2 = v'new Uint32Array([0xa5c66363, 0x84f87c7c, 0x99ee7777, 0x8df67b7b, 0x0dfff2f2, 0xbdd66b6b, 0xb1de6f6f, 0x5491c5c5, 0x50603030, 0x03020101, 0xa9ce6767, 0x7d562b2b, 0x19e7fefe, 0x62b5d7d7, 0xe64dabab, 0x9aec7676, 0x458fcaca, 0x9d1f8282, 0x4089c9c9, 0x87fa7d7d, 0x15effafa, 0xebb25959, 0xc98e4747, 0x0bfbf0f0, 0xec41adad, 0x67b3d4d4, 0xfd5fa2a2, 0xea45afaf, 0xbf239c9c, 0xf753a4a4, 0x96e47272, 0x5b9bc0c0, 0xc275b7b7, 0x1ce1fdfd, 0xae3d9393, 0x6a4c2626, 0x5a6c3636, 0x417e3f3f, 0x02f5f7f7, 0x4f83cccc, 0x5c683434, 0xf451a5a5, 0x34d1e5e5, 0x08f9f1f1, 0x93e27171, 0x73abd8d8, 0x53623131, 0x3f2a1515, 0x0c080404, 0x5295c7c7, 0x65462323, 0x5e9dc3c3, 0x28301818, 0xa1379696, 0x0f0a0505, 0xb52f9a9a, 0x090e0707, 0x36241212, 0x9b1b8080, 0x3ddfe2e2, 0x26cdebeb, 0x694e2727, 0xcd7fb2b2, 0x9fea7575, 0x1b120909, 0x9e1d8383, 0x74582c2c, 0x2e341a1a, 0x2d361b1b, 0xb2dc6e6e, 0xeeb45a5a, 0xfb5ba0a0, 0xf6a45252, 0x4d763b3b, 0x61b7d6d6, 0xce7db3b3, 0x7b522929, 0x3edde3e3, 0x715e2f2f, 0x97138484, 0xf5a65353, 0x68b9d1d1, 0x00000000, 0x2cc1eded, 0x60402020, 0x1fe3fcfc, 0xc879b1b1, 0xedb65b5b, 0xbed46a6a, 0x468dcbcb, 0xd967bebe, 0x4b723939, 0xde944a4a, 0xd4984c4c, 0xe8b05858, 0x4a85cfcf, 0x6bbbd0d0, 0x2ac5efef, 0xe54faaaa, 0x16edfbfb, 0xc5864343, 0xd79a4d4d, 0x55663333, 0x94118585, 0xcf8a4545, 0x10e9f9f9, 0x06040202, 0x81fe7f7f, 0xf0a05050, 0x44783c3c, 0xba259f9f, 0xe34ba8a8, 0xf3a25151, 0xfe5da3a3, 0xc0804040, 0x8a058f8f, 0xad3f9292, 0xbc219d9d, 0x48703838, 0x04f1f5f5, 0xdf63bcbc, 0xc177b6b6, 0x75afdada, 0x63422121, 0x30201010, 0x1ae5ffff, 0x0efdf3f3, 0x6dbfd2d2, 0x4c81cdcd, 0x14180c0c, 0x35261313, 0x2fc3ecec, 0xe1be5f5f, 0xa2359797, 0xcc884444, 0x392e1717, 0x5793c4c4, 0xf255a7a7, 0x82fc7e7e, 0x477a3d3d, 0xacc86464, 0xe7ba5d5d, 0x2b321919, 0x95e67373, 0xa0c06060, 0x98198181, 0xd19e4f4f, 0x7fa3dcdc, 0x66442222, 0x7e542a2a, 0xab3b9090, 0x830b8888, 0xca8c4646, 0x29c7eeee, 0xd36bb8b8, 0x3c281414, 0x79a7dede, 0xe2bc5e5e, 0x1d160b0b, 0x76addbdb, 0x3bdbe0e0, 0x56643232, 0x4e743a3a, 0x1e140a0a, 0xdb924949, 0x0a0c0606, 0x6c482424, 0xe4b85c5c, 0x5d9fc2c2, 0x6ebdd3d3, 0xef43acac, 0xa6c46262, 0xa8399191, 0xa4319595, 0x37d3e4e4, 0x8bf27979, 0x32d5e7e7, 0x438bc8c8, 0x596e3737, 0xb7da6d6d, 0x8c018d8d, 0x64b1d5d5, 0xd29c4e4e, 0xe049a9a9, 0xb4d86c6c, 0xfaac5656, 0x07f3f4f4, 0x25cfeaea, 0xafca6565, 0x8ef47a7a, 0xe947aeae, 0x18100808, 0xd56fbaba, 0x88f07878, 0x6f4a2525, 0x725c2e2e, 0x24381c1c, 0xf157a6a6, 0xc773b4b4, 0x5197c6c6, 0x23cbe8e8, 0x7ca1dddd, 0x9ce87474, 0x213e1f1f, 0xdd964b4b, 0xdc61bdbd, 0x860d8b8b, 0x850f8a8a, 0x90e07070, 0x427c3e3e, 0xc471b5b5, 0xaacc6666, 0xd8904848, 0x05060303, 0x01f7f6f6, 0x121c0e0e, 0xa3c26161, 0x5f6a3535, 0xf9ae5757, 0xd069b9b9, 0x91178686, 0x5899c1c1, 0x273a1d1d, 0xb9279e9e, 0x38d9e1e1, 0x13ebf8f8, 0xb32b9898, 0x33221111, 0xbbd26969, 0x70a9d9d9, 0x89078e8e, 0xa7339494, 0xb62d9b9b, 0x223c1e1e, 0x92158787, 0x20c9e9e9, 0x4987cece, 0xffaa5555, 0x78502828, 0x7aa5dfdf, 0x8f038c8c, 0xf859a1a1, 0x80098989, 0x171a0d0d, 0xda65bfbf, 0x31d7e6e6, 0xc6844242, 0xb8d06868, 0xc3824141, 0xb0299999, 0x775a2d2d, 0x111e0f0f, 0xcb7bb0b0, 0xfca85454, 0xd66dbbbb, 0x3a2c1616])'\nT3 = v'new Uint32Array([0x63a5c663, 0x7c84f87c, 0x7799ee77, 0x7b8df67b, 0xf20dfff2, 0x6bbdd66b, 0x6fb1de6f, 0xc55491c5, 0x30506030, 0x01030201, 0x67a9ce67, 0x2b7d562b, 0xfe19e7fe, 0xd762b5d7, 0xabe64dab, 0x769aec76, 0xca458fca, 0x829d1f82, 0xc94089c9, 0x7d87fa7d, 0xfa15effa, 0x59ebb259, 0x47c98e47, 0xf00bfbf0, 0xadec41ad, 0xd467b3d4, 0xa2fd5fa2, 0xafea45af, 0x9cbf239c, 0xa4f753a4, 0x7296e472, 0xc05b9bc0, 0xb7c275b7, 0xfd1ce1fd, 0x93ae3d93, 0x266a4c26, 0x365a6c36, 0x3f417e3f, 0xf702f5f7, 0xcc4f83cc, 0x345c6834, 0xa5f451a5, 0xe534d1e5, 0xf108f9f1, 0x7193e271, 0xd873abd8, 0x31536231, 0x153f2a15, 0x040c0804, 0xc75295c7, 0x23654623, 0xc35e9dc3, 0x18283018, 0x96a13796, 0x050f0a05, 0x9ab52f9a, 0x07090e07, 0x12362412, 0x809b1b80, 0xe23ddfe2, 0xeb26cdeb, 0x27694e27, 0xb2cd7fb2, 0x759fea75, 0x091b1209, 0x839e1d83, 0x2c74582c, 0x1a2e341a, 0x1b2d361b, 0x6eb2dc6e, 0x5aeeb45a, 0xa0fb5ba0, 0x52f6a452, 0x3b4d763b, 0xd661b7d6, 0xb3ce7db3, 0x297b5229, 0xe33edde3, 0x2f715e2f, 0x84971384, 0x53f5a653, 0xd168b9d1, 0x00000000, 0xed2cc1ed, 0x20604020, 0xfc1fe3fc, 0xb1c879b1, 0x5bedb65b, 0x6abed46a, 0xcb468dcb, 0xbed967be, 0x394b7239, 0x4ade944a, 0x4cd4984c, 0x58e8b058, 0xcf4a85cf, 0xd06bbbd0, 0xef2ac5ef, 0xaae54faa, 0xfb16edfb, 0x43c58643, 0x4dd79a4d, 0x33556633, 0x85941185, 0x45cf8a45, 0xf910e9f9, 0x02060402, 0x7f81fe7f, 0x50f0a050, 0x3c44783c, 0x9fba259f, 0xa8e34ba8, 0x51f3a251, 0xa3fe5da3, 0x40c08040, 0x8f8a058f, 0x92ad3f92, 0x9dbc219d, 0x38487038, 0xf504f1f5, 0xbcdf63bc, 0xb6c177b6, 0xda75afda, 0x21634221, 0x10302010, 0xff1ae5ff, 0xf30efdf3, 0xd26dbfd2, 0xcd4c81cd, 0x0c14180c, 0x13352613, 0xec2fc3ec, 0x5fe1be5f, 0x97a23597, 0x44cc8844, 0x17392e17, 0xc45793c4, 0xa7f255a7, 0x7e82fc7e, 0x3d477a3d, 0x64acc864, 0x5de7ba5d, 0x192b3219, 0x7395e673, 0x60a0c060, 0x81981981, 0x4fd19e4f, 0xdc7fa3dc, 0x22664422, 0x2a7e542a, 0x90ab3b90, 0x88830b88, 0x46ca8c46, 0xee29c7ee, 0xb8d36bb8, 0x143c2814, 0xde79a7de, 0x5ee2bc5e, 0x0b1d160b, 0xdb76addb, 0xe03bdbe0, 0x32566432, 0x3a4e743a, 0x0a1e140a, 0x49db9249, 0x060a0c06, 0x246c4824, 0x5ce4b85c, 0xc25d9fc2, 0xd36ebdd3, 0xacef43ac, 0x62a6c462, 0x91a83991, 0x95a43195, 0xe437d3e4, 0x798bf279, 0xe732d5e7, 0xc8438bc8, 0x37596e37, 0x6db7da6d, 0x8d8c018d, 0xd564b1d5, 0x4ed29c4e, 0xa9e049a9, 0x6cb4d86c, 0x56faac56, 0xf407f3f4, 0xea25cfea, 0x65afca65, 0x7a8ef47a, 0xaee947ae, 0x08181008, 0xbad56fba, 0x7888f078, 0x256f4a25, 0x2e725c2e, 0x1c24381c, 0xa6f157a6, 0xb4c773b4, 0xc65197c6, 0xe823cbe8, 0xdd7ca1dd, 0x749ce874, 0x1f213e1f, 0x4bdd964b, 0xbddc61bd, 0x8b860d8b, 0x8a850f8a, 0x7090e070, 0x3e427c3e, 0xb5c471b5, 0x66aacc66, 0x48d89048, 0x03050603, 0xf601f7f6, 0x0e121c0e, 0x61a3c261, 0x355f6a35, 0x57f9ae57, 0xb9d069b9, 0x86911786, 0xc15899c1, 0x1d273a1d, 0x9eb9279e, 0xe138d9e1, 0xf813ebf8, 0x98b32b98, 0x11332211, 0x69bbd269, 0xd970a9d9, 0x8e89078e, 0x94a73394, 0x9bb62d9b, 0x1e223c1e, 0x87921587, 0xe920c9e9, 0xce4987ce, 0x55ffaa55, 0x28785028, 0xdf7aa5df, 0x8c8f038c, 0xa1f859a1, 0x89800989, 0x0d171a0d, 0xbfda65bf, 0xe631d7e6, 0x42c68442, 0x68b8d068, 0x41c38241, 0x99b02999, 0x2d775a2d, 0x0f111e0f, 0xb0cb7bb0, 0x54fca854, 0xbbd66dbb, 0x163a2c16])'\nT4 = v'new Uint32Array([0x6363a5c6, 0x7c7c84f8, 0x777799ee, 0x7b7b8df6, 0xf2f20dff, 0x6b6bbdd6, 0x6f6fb1de, 0xc5c55491, 0x30305060, 0x01010302, 0x6767a9ce, 0x2b2b7d56, 0xfefe19e7, 0xd7d762b5, 0xababe64d, 0x76769aec, 0xcaca458f, 0x82829d1f, 0xc9c94089, 0x7d7d87fa, 0xfafa15ef, 0x5959ebb2, 0x4747c98e, 0xf0f00bfb, 0xadadec41, 0xd4d467b3, 0xa2a2fd5f, 0xafafea45, 0x9c9cbf23, 0xa4a4f753, 0x727296e4, 0xc0c05b9b, 0xb7b7c275, 0xfdfd1ce1, 0x9393ae3d, 0x26266a4c, 0x36365a6c, 0x3f3f417e, 0xf7f702f5, 0xcccc4f83, 0x34345c68, 0xa5a5f451, 0xe5e534d1, 0xf1f108f9, 0x717193e2, 0xd8d873ab, 0x31315362, 0x15153f2a, 0x04040c08, 0xc7c75295, 0x23236546, 0xc3c35e9d, 0x18182830, 0x9696a137, 0x05050f0a, 0x9a9ab52f, 0x0707090e, 0x12123624, 0x80809b1b, 0xe2e23ddf, 0xebeb26cd, 0x2727694e, 0xb2b2cd7f, 0x75759fea, 0x09091b12, 0x83839e1d, 0x2c2c7458, 0x1a1a2e34, 0x1b1b2d36, 0x6e6eb2dc, 0x5a5aeeb4, 0xa0a0fb5b, 0x5252f6a4, 0x3b3b4d76, 0xd6d661b7, 0xb3b3ce7d, 0x29297b52, 0xe3e33edd, 0x2f2f715e, 0x84849713, 0x5353f5a6, 0xd1d168b9, 0x00000000, 0xeded2cc1, 0x20206040, 0xfcfc1fe3, 0xb1b1c879, 0x5b5bedb6, 0x6a6abed4, 0xcbcb468d, 0xbebed967, 0x39394b72, 0x4a4ade94, 0x4c4cd498, 0x5858e8b0, 0xcfcf4a85, 0xd0d06bbb, 0xefef2ac5, 0xaaaae54f, 0xfbfb16ed, 0x4343c586, 0x4d4dd79a, 0x33335566, 0x85859411, 0x4545cf8a, 0xf9f910e9, 0x02020604, 0x7f7f81fe, 0x5050f0a0, 0x3c3c4478, 0x9f9fba25, 0xa8a8e34b, 0x5151f3a2, 0xa3a3fe5d, 0x4040c080, 0x8f8f8a05, 0x9292ad3f, 0x9d9dbc21, 0x38384870, 0xf5f504f1, 0xbcbcdf63, 0xb6b6c177, 0xdada75af, 0x21216342, 0x10103020, 0xffff1ae5, 0xf3f30efd, 0xd2d26dbf, 0xcdcd4c81, 0x0c0c1418, 0x13133526, 0xecec2fc3, 0x5f5fe1be, 0x9797a235, 0x4444cc88, 0x1717392e, 0xc4c45793, 0xa7a7f255, 0x7e7e82fc, 0x3d3d477a, 0x6464acc8, 0x5d5de7ba, 0x19192b32, 0x737395e6, 0x6060a0c0, 0x81819819, 0x4f4fd19e, 0xdcdc7fa3, 0x22226644, 0x2a2a7e54, 0x9090ab3b, 0x8888830b, 0x4646ca8c, 0xeeee29c7, 0xb8b8d36b, 0x14143c28, 0xdede79a7, 0x5e5ee2bc, 0x0b0b1d16, 0xdbdb76ad, 0xe0e03bdb, 0x32325664, 0x3a3a4e74, 0x0a0a1e14, 0x4949db92, 0x06060a0c, 0x24246c48, 0x5c5ce4b8, 0xc2c25d9f, 0xd3d36ebd, 0xacacef43, 0x6262a6c4, 0x9191a839, 0x9595a431, 0xe4e437d3, 0x79798bf2, 0xe7e732d5, 0xc8c8438b, 0x3737596e, 0x6d6db7da, 0x8d8d8c01, 0xd5d564b1, 0x4e4ed29c, 0xa9a9e049, 0x6c6cb4d8, 0x5656faac, 0xf4f407f3, 0xeaea25cf, 0x6565afca, 0x7a7a8ef4, 0xaeaee947, 0x08081810, 0xbabad56f, 0x787888f0, 0x25256f4a, 0x2e2e725c, 0x1c1c2438, 0xa6a6f157, 0xb4b4c773, 0xc6c65197, 0xe8e823cb, 0xdddd7ca1, 0x74749ce8, 0x1f1f213e, 0x4b4bdd96, 0xbdbddc61, 0x8b8b860d, 0x8a8a850f, 0x707090e0, 0x3e3e427c, 0xb5b5c471, 0x6666aacc, 0x4848d890, 0x03030506, 0xf6f601f7, 0x0e0e121c, 0x6161a3c2, 0x35355f6a, 0x5757f9ae, 0xb9b9d069, 0x86869117, 0xc1c15899, 0x1d1d273a, 0x9e9eb927, 0xe1e138d9, 0xf8f813eb, 0x9898b32b, 0x11113322, 0x6969bbd2, 0xd9d970a9, 0x8e8e8907, 0x9494a733, 0x9b9bb62d, 0x1e1e223c, 0x87879215, 0xe9e920c9, 0xcece4987, 0x5555ffaa, 0x28287850, 0xdfdf7aa5, 0x8c8c8f03, 0xa1a1f859, 0x89898009, 0x0d0d171a, 0xbfbfda65, 0xe6e631d7, 0x4242c684, 0x6868b8d0, 0x4141c382, 0x9999b029, 0x2d2d775a, 0x0f0f111e, 0xb0b0cb7b, 0x5454fca8, 0xbbbbd66d, 0x16163a2c])'\n\n# Transformations for decryption\nT5 = v'new Uint32Array([0x51f4a750, 0x7e416553, 0x1a17a4c3, 0x3a275e96, 0x3bab6bcb, 0x1f9d45f1, 0xacfa58ab, 0x4be30393, 0x2030fa55, 0xad766df6, 0x88cc7691, 0xf5024c25, 0x4fe5d7fc, 0xc52acbd7, 0x26354480, 0xb562a38f, 0xdeb15a49, 0x25ba1b67, 0x45ea0e98, 0x5dfec0e1, 0xc32f7502, 0x814cf012, 0x8d4697a3, 0x6bd3f9c6, 0x038f5fe7, 0x15929c95, 0xbf6d7aeb, 0x955259da, 0xd4be832d, 0x587421d3, 0x49e06929, 0x8ec9c844, 0x75c2896a, 0xf48e7978, 0x99583e6b, 0x27b971dd, 0xbee14fb6, 0xf088ad17, 0xc920ac66, 0x7dce3ab4, 0x63df4a18, 0xe51a3182, 0x97513360, 0x62537f45, 0xb16477e0, 0xbb6bae84, 0xfe81a01c, 0xf9082b94, 0x70486858, 0x8f45fd19, 0x94de6c87, 0x527bf8b7, 0xab73d323, 0x724b02e2, 0xe31f8f57, 0x6655ab2a, 0xb2eb2807, 0x2fb5c203, 0x86c57b9a, 0xd33708a5, 0x302887f2, 0x23bfa5b2, 0x02036aba, 0xed16825c, 0x8acf1c2b, 0xa779b492, 0xf307f2f0, 0x4e69e2a1, 0x65daf4cd, 0x0605bed5, 0xd134621f, 0xc4a6fe8a, 0x342e539d, 0xa2f355a0, 0x058ae132, 0xa4f6eb75, 0x0b83ec39, 0x4060efaa, 0x5e719f06, 0xbd6e1051, 0x3e218af9, 0x96dd063d, 0xdd3e05ae, 0x4de6bd46, 0x91548db5, 0x71c45d05, 0x0406d46f, 0x605015ff, 0x1998fb24, 0xd6bde997, 0x894043cc, 0x67d99e77, 0xb0e842bd, 0x07898b88, 0xe7195b38, 0x79c8eedb, 0xa17c0a47, 0x7c420fe9, 0xf8841ec9, 0x00000000, 0x09808683, 0x322bed48, 0x1e1170ac, 0x6c5a724e, 0xfd0efffb, 0x0f853856, 0x3daed51e, 0x362d3927, 0x0a0fd964, 0x685ca621, 0x9b5b54d1, 0x24362e3a, 0x0c0a67b1, 0x9357e70f, 0xb4ee96d2, 0x1b9b919e, 0x80c0c54f, 0x61dc20a2, 0x5a774b69, 0x1c121a16, 0xe293ba0a, 0xc0a02ae5, 0x3c22e043, 0x121b171d, 0x0e090d0b, 0xf28bc7ad, 0x2db6a8b9, 0x141ea9c8, 0x57f11985, 0xaf75074c, 0xee99ddbb, 0xa37f60fd, 0xf701269f, 0x5c72f5bc, 0x44663bc5, 0x5bfb7e34, 0x8b432976, 0xcb23c6dc, 0xb6edfc68, 0xb8e4f163, 0xd731dcca, 0x42638510, 0x13972240, 0x84c61120, 0x854a247d, 0xd2bb3df8, 0xaef93211, 0xc729a16d, 0x1d9e2f4b, 0xdcb230f3, 0x0d8652ec, 0x77c1e3d0, 0x2bb3166c, 0xa970b999, 0x119448fa, 0x47e96422, 0xa8fc8cc4, 0xa0f03f1a, 0x567d2cd8, 0x223390ef, 0x87494ec7, 0xd938d1c1, 0x8ccaa2fe, 0x98d40b36, 0xa6f581cf, 0xa57ade28, 0xdab78e26, 0x3fadbfa4, 0x2c3a9de4, 0x5078920d, 0x6a5fcc9b, 0x547e4662, 0xf68d13c2, 0x90d8b8e8, 0x2e39f75e, 0x82c3aff5, 0x9f5d80be, 0x69d0937c, 0x6fd52da9, 0xcf2512b3, 0xc8ac993b, 0x10187da7, 0xe89c636e, 0xdb3bbb7b, 0xcd267809, 0x6e5918f4, 0xec9ab701, 0x834f9aa8, 0xe6956e65, 0xaaffe67e, 0x21bccf08, 0xef15e8e6, 0xbae79bd9, 0x4a6f36ce, 0xea9f09d4, 0x29b07cd6, 0x31a4b2af, 0x2a3f2331, 0xc6a59430, 0x35a266c0, 0x744ebc37, 0xfc82caa6, 0xe090d0b0, 0x33a7d815, 0xf104984a, 0x41ecdaf7, 0x7fcd500e, 0x1791f62f, 0x764dd68d, 0x43efb04d, 0xccaa4d54, 0xe49604df, 0x9ed1b5e3, 0x4c6a881b, 0xc12c1fb8, 0x4665517f, 0x9d5eea04, 0x018c355d, 0xfa877473, 0xfb0b412e, 0xb3671d5a, 0x92dbd252, 0xe9105633, 0x6dd64713, 0x9ad7618c, 0x37a10c7a, 0x59f8148e, 0xeb133c89, 0xcea927ee, 0xb761c935, 0xe11ce5ed, 0x7a47b13c, 0x9cd2df59, 0x55f2733f, 0x1814ce79, 0x73c737bf, 0x53f7cdea, 0x5ffdaa5b, 0xdf3d6f14, 0x7844db86, 0xcaaff381, 0xb968c43e, 0x3824342c, 0xc2a3405f, 0x161dc372, 0xbce2250c, 0x283c498b, 0xff0d9541, 0x39a80171, 0x080cb3de, 0xd8b4e49c, 0x6456c190, 0x7bcb8461, 0xd532b670, 0x486c5c74, 0xd0b85742])'\nT6 = v'new Uint32Array([0x5051f4a7, 0x537e4165, 0xc31a17a4, 0x963a275e, 0xcb3bab6b, 0xf11f9d45, 0xabacfa58, 0x934be303, 0x552030fa, 0xf6ad766d, 0x9188cc76, 0x25f5024c, 0xfc4fe5d7, 0xd7c52acb, 0x80263544, 0x8fb562a3, 0x49deb15a, 0x6725ba1b, 0x9845ea0e, 0xe15dfec0, 0x02c32f75, 0x12814cf0, 0xa38d4697, 0xc66bd3f9, 0xe7038f5f, 0x9515929c, 0xebbf6d7a, 0xda955259, 0x2dd4be83, 0xd3587421, 0x2949e069, 0x448ec9c8, 0x6a75c289, 0x78f48e79, 0x6b99583e, 0xdd27b971, 0xb6bee14f, 0x17f088ad, 0x66c920ac, 0xb47dce3a, 0x1863df4a, 0x82e51a31, 0x60975133, 0x4562537f, 0xe0b16477, 0x84bb6bae, 0x1cfe81a0, 0x94f9082b, 0x58704868, 0x198f45fd, 0x8794de6c, 0xb7527bf8, 0x23ab73d3, 0xe2724b02, 0x57e31f8f, 0x2a6655ab, 0x07b2eb28, 0x032fb5c2, 0x9a86c57b, 0xa5d33708, 0xf2302887, 0xb223bfa5, 0xba02036a, 0x5ced1682, 0x2b8acf1c, 0x92a779b4, 0xf0f307f2, 0xa14e69e2, 0xcd65daf4, 0xd50605be, 0x1fd13462, 0x8ac4a6fe, 0x9d342e53, 0xa0a2f355, 0x32058ae1, 0x75a4f6eb, 0x390b83ec, 0xaa4060ef, 0x065e719f, 0x51bd6e10, 0xf93e218a, 0x3d96dd06, 0xaedd3e05, 0x464de6bd, 0xb591548d, 0x0571c45d, 0x6f0406d4, 0xff605015, 0x241998fb, 0x97d6bde9, 0xcc894043, 0x7767d99e, 0xbdb0e842, 0x8807898b, 0x38e7195b, 0xdb79c8ee, 0x47a17c0a, 0xe97c420f, 0xc9f8841e, 0x00000000, 0x83098086, 0x48322bed, 0xac1e1170, 0x4e6c5a72, 0xfbfd0eff, 0x560f8538, 0x1e3daed5, 0x27362d39, 0x640a0fd9, 0x21685ca6, 0xd19b5b54, 0x3a24362e, 0xb10c0a67, 0x0f9357e7, 0xd2b4ee96, 0x9e1b9b91, 0x4f80c0c5, 0xa261dc20, 0x695a774b, 0x161c121a, 0x0ae293ba, 0xe5c0a02a, 0x433c22e0, 0x1d121b17, 0x0b0e090d, 0xadf28bc7, 0xb92db6a8, 0xc8141ea9, 0x8557f119, 0x4caf7507, 0xbbee99dd, 0xfda37f60, 0x9ff70126, 0xbc5c72f5, 0xc544663b, 0x345bfb7e, 0x768b4329, 0xdccb23c6, 0x68b6edfc, 0x63b8e4f1, 0xcad731dc, 0x10426385, 0x40139722, 0x2084c611, 0x7d854a24, 0xf8d2bb3d, 0x11aef932, 0x6dc729a1, 0x4b1d9e2f, 0xf3dcb230, 0xec0d8652, 0xd077c1e3, 0x6c2bb316, 0x99a970b9, 0xfa119448, 0x2247e964, 0xc4a8fc8c, 0x1aa0f03f, 0xd8567d2c, 0xef223390, 0xc787494e, 0xc1d938d1, 0xfe8ccaa2, 0x3698d40b, 0xcfa6f581, 0x28a57ade, 0x26dab78e, 0xa43fadbf, 0xe42c3a9d, 0x0d507892, 0x9b6a5fcc, 0x62547e46, 0xc2f68d13, 0xe890d8b8, 0x5e2e39f7, 0xf582c3af, 0xbe9f5d80, 0x7c69d093, 0xa96fd52d, 0xb3cf2512, 0x3bc8ac99, 0xa710187d, 0x6ee89c63, 0x7bdb3bbb, 0x09cd2678, 0xf46e5918, 0x01ec9ab7, 0xa8834f9a, 0x65e6956e, 0x7eaaffe6, 0x0821bccf, 0xe6ef15e8, 0xd9bae79b, 0xce4a6f36, 0xd4ea9f09, 0xd629b07c, 0xaf31a4b2, 0x312a3f23, 0x30c6a594, 0xc035a266, 0x37744ebc, 0xa6fc82ca, 0xb0e090d0, 0x1533a7d8, 0x4af10498, 0xf741ecda, 0x0e7fcd50, 0x2f1791f6, 0x8d764dd6, 0x4d43efb0, 0x54ccaa4d, 0xdfe49604, 0xe39ed1b5, 0x1b4c6a88, 0xb8c12c1f, 0x7f466551, 0x049d5eea, 0x5d018c35, 0x73fa8774, 0x2efb0b41, 0x5ab3671d, 0x5292dbd2, 0x33e91056, 0x136dd647, 0x8c9ad761, 0x7a37a10c, 0x8e59f814, 0x89eb133c, 0xeecea927, 0x35b761c9, 0xede11ce5, 0x3c7a47b1, 0x599cd2df, 0x3f55f273, 0x791814ce, 0xbf73c737, 0xea53f7cd, 0x5b5ffdaa, 0x14df3d6f, 0x867844db, 0x81caaff3, 0x3eb968c4, 0x2c382434, 0x5fc2a340, 0x72161dc3, 0x0cbce225, 0x8b283c49, 0x41ff0d95, 0x7139a801, 0xde080cb3, 0x9cd8b4e4, 0x906456c1, 0x617bcb84, 0x70d532b6, 0x74486c5c, 0x42d0b857])'\nT7 = v'new Uint32Array([0xa75051f4, 0x65537e41, 0xa4c31a17, 0x5e963a27, 0x6bcb3bab, 0x45f11f9d, 0x58abacfa, 0x03934be3, 0xfa552030, 0x6df6ad76, 0x769188cc, 0x4c25f502, 0xd7fc4fe5, 0xcbd7c52a, 0x44802635, 0xa38fb562, 0x5a49deb1, 0x1b6725ba, 0x0e9845ea, 0xc0e15dfe, 0x7502c32f, 0xf012814c, 0x97a38d46, 0xf9c66bd3, 0x5fe7038f, 0x9c951592, 0x7aebbf6d, 0x59da9552, 0x832dd4be, 0x21d35874, 0x692949e0, 0xc8448ec9, 0x896a75c2, 0x7978f48e, 0x3e6b9958, 0x71dd27b9, 0x4fb6bee1, 0xad17f088, 0xac66c920, 0x3ab47dce, 0x4a1863df, 0x3182e51a, 0x33609751, 0x7f456253, 0x77e0b164, 0xae84bb6b, 0xa01cfe81, 0x2b94f908, 0x68587048, 0xfd198f45, 0x6c8794de, 0xf8b7527b, 0xd323ab73, 0x02e2724b, 0x8f57e31f, 0xab2a6655, 0x2807b2eb, 0xc2032fb5, 0x7b9a86c5, 0x08a5d337, 0x87f23028, 0xa5b223bf, 0x6aba0203, 0x825ced16, 0x1c2b8acf, 0xb492a779, 0xf2f0f307, 0xe2a14e69, 0xf4cd65da, 0xbed50605, 0x621fd134, 0xfe8ac4a6, 0x539d342e, 0x55a0a2f3, 0xe132058a, 0xeb75a4f6, 0xec390b83, 0xefaa4060, 0x9f065e71, 0x1051bd6e, 0x8af93e21, 0x063d96dd, 0x05aedd3e, 0xbd464de6, 0x8db59154, 0x5d0571c4, 0xd46f0406, 0x15ff6050, 0xfb241998, 0xe997d6bd, 0x43cc8940, 0x9e7767d9, 0x42bdb0e8, 0x8b880789, 0x5b38e719, 0xeedb79c8, 0x0a47a17c, 0x0fe97c42, 0x1ec9f884, 0x00000000, 0x86830980, 0xed48322b, 0x70ac1e11, 0x724e6c5a, 0xfffbfd0e, 0x38560f85, 0xd51e3dae, 0x3927362d, 0xd9640a0f, 0xa621685c, 0x54d19b5b, 0x2e3a2436, 0x67b10c0a, 0xe70f9357, 0x96d2b4ee, 0x919e1b9b, 0xc54f80c0, 0x20a261dc, 0x4b695a77, 0x1a161c12, 0xba0ae293, 0x2ae5c0a0, 0xe0433c22, 0x171d121b, 0x0d0b0e09, 0xc7adf28b, 0xa8b92db6, 0xa9c8141e, 0x198557f1, 0x074caf75, 0xddbbee99, 0x60fda37f, 0x269ff701, 0xf5bc5c72, 0x3bc54466, 0x7e345bfb, 0x29768b43, 0xc6dccb23, 0xfc68b6ed, 0xf163b8e4, 0xdccad731, 0x85104263, 0x22401397, 0x112084c6, 0x247d854a, 0x3df8d2bb, 0x3211aef9, 0xa16dc729, 0x2f4b1d9e, 0x30f3dcb2, 0x52ec0d86, 0xe3d077c1, 0x166c2bb3, 0xb999a970, 0x48fa1194, 0x642247e9, 0x8cc4a8fc, 0x3f1aa0f0, 0x2cd8567d, 0x90ef2233, 0x4ec78749, 0xd1c1d938, 0xa2fe8cca, 0x0b3698d4, 0x81cfa6f5, 0xde28a57a, 0x8e26dab7, 0xbfa43fad, 0x9de42c3a, 0x920d5078, 0xcc9b6a5f, 0x4662547e, 0x13c2f68d, 0xb8e890d8, 0xf75e2e39, 0xaff582c3, 0x80be9f5d, 0x937c69d0, 0x2da96fd5, 0x12b3cf25, 0x993bc8ac, 0x7da71018, 0x636ee89c, 0xbb7bdb3b, 0x7809cd26, 0x18f46e59, 0xb701ec9a, 0x9aa8834f, 0x6e65e695, 0xe67eaaff, 0xcf0821bc, 0xe8e6ef15, 0x9bd9bae7, 0x36ce4a6f, 0x09d4ea9f, 0x7cd629b0, 0xb2af31a4, 0x23312a3f, 0x9430c6a5, 0x66c035a2, 0xbc37744e, 0xcaa6fc82, 0xd0b0e090, 0xd81533a7, 0x984af104, 0xdaf741ec, 0x500e7fcd, 0xf62f1791, 0xd68d764d, 0xb04d43ef, 0x4d54ccaa, 0x04dfe496, 0xb5e39ed1, 0x881b4c6a, 0x1fb8c12c, 0x517f4665, 0xea049d5e, 0x355d018c, 0x7473fa87, 0x412efb0b, 0x1d5ab367, 0xd25292db, 0x5633e910, 0x47136dd6, 0x618c9ad7, 0x0c7a37a1, 0x148e59f8, 0x3c89eb13, 0x27eecea9, 0xc935b761, 0xe5ede11c, 0xb13c7a47, 0xdf599cd2, 0x733f55f2, 0xce791814, 0x37bf73c7, 0xcdea53f7, 0xaa5b5ffd, 0x6f14df3d, 0xdb867844, 0xf381caaf, 0xc43eb968, 0x342c3824, 0x405fc2a3, 0xc372161d, 0x250cbce2, 0x498b283c, 0x9541ff0d, 0x017139a8, 0xb3de080c, 0xe49cd8b4, 0xc1906456, 0x84617bcb, 0xb670d532, 0x5c74486c, 0x5742d0b8])'\nT8 = v'new Uint32Array([0xf4a75051, 0x4165537e, 0x17a4c31a, 0x275e963a, 0xab6bcb3b, 0x9d45f11f, 0xfa58abac, 0xe303934b, 0x30fa5520, 0x766df6ad, 0xcc769188, 0x024c25f5, 0xe5d7fc4f, 0x2acbd7c5, 0x35448026, 0x62a38fb5, 0xb15a49de, 0xba1b6725, 0xea0e9845, 0xfec0e15d, 0x2f7502c3, 0x4cf01281, 0x4697a38d, 0xd3f9c66b, 0x8f5fe703, 0x929c9515, 0x6d7aebbf, 0x5259da95, 0xbe832dd4, 0x7421d358, 0xe0692949, 0xc9c8448e, 0xc2896a75, 0x8e7978f4, 0x583e6b99, 0xb971dd27, 0xe14fb6be, 0x88ad17f0, 0x20ac66c9, 0xce3ab47d, 0xdf4a1863, 0x1a3182e5, 0x51336097, 0x537f4562, 0x6477e0b1, 0x6bae84bb, 0x81a01cfe, 0x082b94f9, 0x48685870, 0x45fd198f, 0xde6c8794, 0x7bf8b752, 0x73d323ab, 0x4b02e272, 0x1f8f57e3, 0x55ab2a66, 0xeb2807b2, 0xb5c2032f, 0xc57b9a86, 0x3708a5d3, 0x2887f230, 0xbfa5b223, 0x036aba02, 0x16825ced, 0xcf1c2b8a, 0x79b492a7, 0x07f2f0f3, 0x69e2a14e, 0xdaf4cd65, 0x05bed506, 0x34621fd1, 0xa6fe8ac4, 0x2e539d34, 0xf355a0a2, 0x8ae13205, 0xf6eb75a4, 0x83ec390b, 0x60efaa40, 0x719f065e, 0x6e1051bd, 0x218af93e, 0xdd063d96, 0x3e05aedd, 0xe6bd464d, 0x548db591, 0xc45d0571, 0x06d46f04, 0x5015ff60, 0x98fb2419, 0xbde997d6, 0x4043cc89, 0xd99e7767, 0xe842bdb0, 0x898b8807, 0x195b38e7, 0xc8eedb79, 0x7c0a47a1, 0x420fe97c, 0x841ec9f8, 0x00000000, 0x80868309, 0x2bed4832, 0x1170ac1e, 0x5a724e6c, 0x0efffbfd, 0x8538560f, 0xaed51e3d, 0x2d392736, 0x0fd9640a, 0x5ca62168, 0x5b54d19b, 0x362e3a24, 0x0a67b10c, 0x57e70f93, 0xee96d2b4, 0x9b919e1b, 0xc0c54f80, 0xdc20a261, 0x774b695a, 0x121a161c, 0x93ba0ae2, 0xa02ae5c0, 0x22e0433c, 0x1b171d12, 0x090d0b0e, 0x8bc7adf2, 0xb6a8b92d, 0x1ea9c814, 0xf1198557, 0x75074caf, 0x99ddbbee, 0x7f60fda3, 0x01269ff7, 0x72f5bc5c, 0x663bc544, 0xfb7e345b, 0x4329768b, 0x23c6dccb, 0xedfc68b6, 0xe4f163b8, 0x31dccad7, 0x63851042, 0x97224013, 0xc6112084, 0x4a247d85, 0xbb3df8d2, 0xf93211ae, 0x29a16dc7, 0x9e2f4b1d, 0xb230f3dc, 0x8652ec0d, 0xc1e3d077, 0xb3166c2b, 0x70b999a9, 0x9448fa11, 0xe9642247, 0xfc8cc4a8, 0xf03f1aa0, 0x7d2cd856, 0x3390ef22, 0x494ec787, 0x38d1c1d9, 0xcaa2fe8c, 0xd40b3698, 0xf581cfa6, 0x7ade28a5, 0xb78e26da, 0xadbfa43f, 0x3a9de42c, 0x78920d50, 0x5fcc9b6a, 0x7e466254, 0x8d13c2f6, 0xd8b8e890, 0x39f75e2e, 0xc3aff582, 0x5d80be9f, 0xd0937c69, 0xd52da96f, 0x2512b3cf, 0xac993bc8, 0x187da710, 0x9c636ee8, 0x3bbb7bdb, 0x267809cd, 0x5918f46e, 0x9ab701ec, 0x4f9aa883, 0x956e65e6, 0xffe67eaa, 0xbccf0821, 0x15e8e6ef, 0xe79bd9ba, 0x6f36ce4a, 0x9f09d4ea, 0xb07cd629, 0xa4b2af31, 0x3f23312a, 0xa59430c6, 0xa266c035, 0x4ebc3774, 0x82caa6fc, 0x90d0b0e0, 0xa7d81533, 0x04984af1, 0xecdaf741, 0xcd500e7f, 0x91f62f17, 0x4dd68d76, 0xefb04d43, 0xaa4d54cc, 0x9604dfe4, 0xd1b5e39e, 0x6a881b4c, 0x2c1fb8c1, 0x65517f46, 0x5eea049d, 0x8c355d01, 0x877473fa, 0x0b412efb, 0x671d5ab3, 0xdbd25292, 0x105633e9, 0xd647136d, 0xd7618c9a, 0xa10c7a37, 0xf8148e59, 0x133c89eb, 0xa927eece, 0x61c935b7, 0x1ce5ede1, 0x47b13c7a, 0xd2df599c, 0xf2733f55, 0x14ce7918, 0xc737bf73, 0xf7cdea53, 0xfdaa5b5f, 0x3d6f14df, 0x44db8678, 0xaff381ca, 0x68c43eb9, 0x24342c38, 0xa3405fc2, 0x1dc37216, 0xe2250cbc, 0x3c498b28, 0x0d9541ff, 0xa8017139, 0x0cb3de08, 0xb4e49cd8, 0x56c19064, 0xcb84617b, 0x32b670d5, 0x6c5c7448, 0xb85742d0])'\n\n# Transformations for decryption key expansion\nU1 = v'new Uint32Array([0x00000000, 0x0e090d0b, 0x1c121a16, 0x121b171d, 0x3824342c, 0x362d3927, 0x24362e3a, 0x2a3f2331, 0x70486858, 0x7e416553, 0x6c5a724e, 0x62537f45, 0x486c5c74, 0x4665517f, 0x547e4662, 0x5a774b69, 0xe090d0b0, 0xee99ddbb, 0xfc82caa6, 0xf28bc7ad, 0xd8b4e49c, 0xd6bde997, 0xc4a6fe8a, 0xcaaff381, 0x90d8b8e8, 0x9ed1b5e3, 0x8ccaa2fe, 0x82c3aff5, 0xa8fc8cc4, 0xa6f581cf, 0xb4ee96d2, 0xbae79bd9, 0xdb3bbb7b, 0xd532b670, 0xc729a16d, 0xc920ac66, 0xe31f8f57, 0xed16825c, 0xff0d9541, 0xf104984a, 0xab73d323, 0xa57ade28, 0xb761c935, 0xb968c43e, 0x9357e70f, 0x9d5eea04, 0x8f45fd19, 0x814cf012, 0x3bab6bcb, 0x35a266c0, 0x27b971dd, 0x29b07cd6, 0x038f5fe7, 0x0d8652ec, 0x1f9d45f1, 0x119448fa, 0x4be30393, 0x45ea0e98, 0x57f11985, 0x59f8148e, 0x73c737bf, 0x7dce3ab4, 0x6fd52da9, 0x61dc20a2, 0xad766df6, 0xa37f60fd, 0xb16477e0, 0xbf6d7aeb, 0x955259da, 0x9b5b54d1, 0x894043cc, 0x87494ec7, 0xdd3e05ae, 0xd33708a5, 0xc12c1fb8, 0xcf2512b3, 0xe51a3182, 0xeb133c89, 0xf9082b94, 0xf701269f, 0x4de6bd46, 0x43efb04d, 0x51f4a750, 0x5ffdaa5b, 0x75c2896a, 0x7bcb8461, 0x69d0937c, 0x67d99e77, 0x3daed51e, 0x33a7d815, 0x21bccf08, 0x2fb5c203, 0x058ae132, 0x0b83ec39, 0x1998fb24, 0x1791f62f, 0x764dd68d, 0x7844db86, 0x6a5fcc9b, 0x6456c190, 0x4e69e2a1, 0x4060efaa, 0x527bf8b7, 0x5c72f5bc, 0x0605bed5, 0x080cb3de, 0x1a17a4c3, 0x141ea9c8, 0x3e218af9, 0x302887f2, 0x223390ef, 0x2c3a9de4, 0x96dd063d, 0x98d40b36, 0x8acf1c2b, 0x84c61120, 0xaef93211, 0xa0f03f1a, 0xb2eb2807, 0xbce2250c, 0xe6956e65, 0xe89c636e, 0xfa877473, 0xf48e7978, 0xdeb15a49, 0xd0b85742, 0xc2a3405f, 0xccaa4d54, 0x41ecdaf7, 0x4fe5d7fc, 0x5dfec0e1, 0x53f7cdea, 0x79c8eedb, 0x77c1e3d0, 0x65daf4cd, 0x6bd3f9c6, 0x31a4b2af, 0x3fadbfa4, 0x2db6a8b9, 0x23bfa5b2, 0x09808683, 0x07898b88, 0x15929c95, 0x1b9b919e, 0xa17c0a47, 0xaf75074c, 0xbd6e1051, 0xb3671d5a, 0x99583e6b, 0x97513360, 0x854a247d, 0x8b432976, 0xd134621f, 0xdf3d6f14, 0xcd267809, 0xc32f7502, 0xe9105633, 0xe7195b38, 0xf5024c25, 0xfb0b412e, 0x9ad7618c, 0x94de6c87, 0x86c57b9a, 0x88cc7691, 0xa2f355a0, 0xacfa58ab, 0xbee14fb6, 0xb0e842bd, 0xea9f09d4, 0xe49604df, 0xf68d13c2, 0xf8841ec9, 0xd2bb3df8, 0xdcb230f3, 0xcea927ee, 0xc0a02ae5, 0x7a47b13c, 0x744ebc37, 0x6655ab2a, 0x685ca621, 0x42638510, 0x4c6a881b, 0x5e719f06, 0x5078920d, 0x0a0fd964, 0x0406d46f, 0x161dc372, 0x1814ce79, 0x322bed48, 0x3c22e043, 0x2e39f75e, 0x2030fa55, 0xec9ab701, 0xe293ba0a, 0xf088ad17, 0xfe81a01c, 0xd4be832d, 0xdab78e26, 0xc8ac993b, 0xc6a59430, 0x9cd2df59, 0x92dbd252, 0x80c0c54f, 0x8ec9c844, 0xa4f6eb75, 0xaaffe67e, 0xb8e4f163, 0xb6edfc68, 0x0c0a67b1, 0x02036aba, 0x10187da7, 0x1e1170ac, 0x342e539d, 0x3a275e96, 0x283c498b, 0x26354480, 0x7c420fe9, 0x724b02e2, 0x605015ff, 0x6e5918f4, 0x44663bc5, 0x4a6f36ce, 0x587421d3, 0x567d2cd8, 0x37a10c7a, 0x39a80171, 0x2bb3166c, 0x25ba1b67, 0x0f853856, 0x018c355d, 0x13972240, 0x1d9e2f4b, 0x47e96422, 0x49e06929, 0x5bfb7e34, 0x55f2733f, 0x7fcd500e, 0x71c45d05, 0x63df4a18, 0x6dd64713, 0xd731dcca, 0xd938d1c1, 0xcb23c6dc, 0xc52acbd7, 0xef15e8e6, 0xe11ce5ed, 0xf307f2f0, 0xfd0efffb, 0xa779b492, 0xa970b999, 0xbb6bae84, 0xb562a38f, 0x9f5d80be, 0x91548db5, 0x834f9aa8, 0x8d4697a3])'\nU2 = v'new Uint32Array([0x00000000, 0x0b0e090d, 0x161c121a, 0x1d121b17, 0x2c382434, 0x27362d39, 0x3a24362e, 0x312a3f23, 0x58704868, 0x537e4165, 0x4e6c5a72, 0x4562537f, 0x74486c5c, 0x7f466551, 0x62547e46, 0x695a774b, 0xb0e090d0, 0xbbee99dd, 0xa6fc82ca, 0xadf28bc7, 0x9cd8b4e4, 0x97d6bde9, 0x8ac4a6fe, 0x81caaff3, 0xe890d8b8, 0xe39ed1b5, 0xfe8ccaa2, 0xf582c3af, 0xc4a8fc8c, 0xcfa6f581, 0xd2b4ee96, 0xd9bae79b, 0x7bdb3bbb, 0x70d532b6, 0x6dc729a1, 0x66c920ac, 0x57e31f8f, 0x5ced1682, 0x41ff0d95, 0x4af10498, 0x23ab73d3, 0x28a57ade, 0x35b761c9, 0x3eb968c4, 0x0f9357e7, 0x049d5eea, 0x198f45fd, 0x12814cf0, 0xcb3bab6b, 0xc035a266, 0xdd27b971, 0xd629b07c, 0xe7038f5f, 0xec0d8652, 0xf11f9d45, 0xfa119448, 0x934be303, 0x9845ea0e, 0x8557f119, 0x8e59f814, 0xbf73c737, 0xb47dce3a, 0xa96fd52d, 0xa261dc20, 0xf6ad766d, 0xfda37f60, 0xe0b16477, 0xebbf6d7a, 0xda955259, 0xd19b5b54, 0xcc894043, 0xc787494e, 0xaedd3e05, 0xa5d33708, 0xb8c12c1f, 0xb3cf2512, 0x82e51a31, 0x89eb133c, 0x94f9082b, 0x9ff70126, 0x464de6bd, 0x4d43efb0, 0x5051f4a7, 0x5b5ffdaa, 0x6a75c289, 0x617bcb84, 0x7c69d093, 0x7767d99e, 0x1e3daed5, 0x1533a7d8, 0x0821bccf, 0x032fb5c2, 0x32058ae1, 0x390b83ec, 0x241998fb, 0x2f1791f6, 0x8d764dd6, 0x867844db, 0x9b6a5fcc, 0x906456c1, 0xa14e69e2, 0xaa4060ef, 0xb7527bf8, 0xbc5c72f5, 0xd50605be, 0xde080cb3, 0xc31a17a4, 0xc8141ea9, 0xf93e218a, 0xf2302887, 0xef223390, 0xe42c3a9d, 0x3d96dd06, 0x3698d40b, 0x2b8acf1c, 0x2084c611, 0x11aef932, 0x1aa0f03f, 0x07b2eb28, 0x0cbce225, 0x65e6956e, 0x6ee89c63, 0x73fa8774, 0x78f48e79, 0x49deb15a, 0x42d0b857, 0x5fc2a340, 0x54ccaa4d, 0xf741ecda, 0xfc4fe5d7, 0xe15dfec0, 0xea53f7cd, 0xdb79c8ee, 0xd077c1e3, 0xcd65daf4, 0xc66bd3f9, 0xaf31a4b2, 0xa43fadbf, 0xb92db6a8, 0xb223bfa5, 0x83098086, 0x8807898b, 0x9515929c, 0x9e1b9b91, 0x47a17c0a, 0x4caf7507, 0x51bd6e10, 0x5ab3671d, 0x6b99583e, 0x60975133, 0x7d854a24, 0x768b4329, 0x1fd13462, 0x14df3d6f, 0x09cd2678, 0x02c32f75, 0x33e91056, 0x38e7195b, 0x25f5024c, 0x2efb0b41, 0x8c9ad761, 0x8794de6c, 0x9a86c57b, 0x9188cc76, 0xa0a2f355, 0xabacfa58, 0xb6bee14f, 0xbdb0e842, 0xd4ea9f09, 0xdfe49604, 0xc2f68d13, 0xc9f8841e, 0xf8d2bb3d, 0xf3dcb230, 0xeecea927, 0xe5c0a02a, 0x3c7a47b1, 0x37744ebc, 0x2a6655ab, 0x21685ca6, 0x10426385, 0x1b4c6a88, 0x065e719f, 0x0d507892, 0x640a0fd9, 0x6f0406d4, 0x72161dc3, 0x791814ce, 0x48322bed, 0x433c22e0, 0x5e2e39f7, 0x552030fa, 0x01ec9ab7, 0x0ae293ba, 0x17f088ad, 0x1cfe81a0, 0x2dd4be83, 0x26dab78e, 0x3bc8ac99, 0x30c6a594, 0x599cd2df, 0x5292dbd2, 0x4f80c0c5, 0x448ec9c8, 0x75a4f6eb, 0x7eaaffe6, 0x63b8e4f1, 0x68b6edfc, 0xb10c0a67, 0xba02036a, 0xa710187d, 0xac1e1170, 0x9d342e53, 0x963a275e, 0x8b283c49, 0x80263544, 0xe97c420f, 0xe2724b02, 0xff605015, 0xf46e5918, 0xc544663b, 0xce4a6f36, 0xd3587421, 0xd8567d2c, 0x7a37a10c, 0x7139a801, 0x6c2bb316, 0x6725ba1b, 0x560f8538, 0x5d018c35, 0x40139722, 0x4b1d9e2f, 0x2247e964, 0x2949e069, 0x345bfb7e, 0x3f55f273, 0x0e7fcd50, 0x0571c45d, 0x1863df4a, 0x136dd647, 0xcad731dc, 0xc1d938d1, 0xdccb23c6, 0xd7c52acb, 0xe6ef15e8, 0xede11ce5, 0xf0f307f2, 0xfbfd0eff, 0x92a779b4, 0x99a970b9, 0x84bb6bae, 0x8fb562a3, 0xbe9f5d80, 0xb591548d, 0xa8834f9a, 0xa38d4697])'\nU3 = v'new Uint32Array([0x00000000, 0x0d0b0e09, 0x1a161c12, 0x171d121b, 0x342c3824, 0x3927362d, 0x2e3a2436, 0x23312a3f, 0x68587048, 0x65537e41, 0x724e6c5a, 0x7f456253, 0x5c74486c, 0x517f4665, 0x4662547e, 0x4b695a77, 0xd0b0e090, 0xddbbee99, 0xcaa6fc82, 0xc7adf28b, 0xe49cd8b4, 0xe997d6bd, 0xfe8ac4a6, 0xf381caaf, 0xb8e890d8, 0xb5e39ed1, 0xa2fe8cca, 0xaff582c3, 0x8cc4a8fc, 0x81cfa6f5, 0x96d2b4ee, 0x9bd9bae7, 0xbb7bdb3b, 0xb670d532, 0xa16dc729, 0xac66c920, 0x8f57e31f, 0x825ced16, 0x9541ff0d, 0x984af104, 0xd323ab73, 0xde28a57a, 0xc935b761, 0xc43eb968, 0xe70f9357, 0xea049d5e, 0xfd198f45, 0xf012814c, 0x6bcb3bab, 0x66c035a2, 0x71dd27b9, 0x7cd629b0, 0x5fe7038f, 0x52ec0d86, 0x45f11f9d, 0x48fa1194, 0x03934be3, 0x0e9845ea, 0x198557f1, 0x148e59f8, 0x37bf73c7, 0x3ab47dce, 0x2da96fd5, 0x20a261dc, 0x6df6ad76, 0x60fda37f, 0x77e0b164, 0x7aebbf6d, 0x59da9552, 0x54d19b5b, 0x43cc8940, 0x4ec78749, 0x05aedd3e, 0x08a5d337, 0x1fb8c12c, 0x12b3cf25, 0x3182e51a, 0x3c89eb13, 0x2b94f908, 0x269ff701, 0xbd464de6, 0xb04d43ef, 0xa75051f4, 0xaa5b5ffd, 0x896a75c2, 0x84617bcb, 0x937c69d0, 0x9e7767d9, 0xd51e3dae, 0xd81533a7, 0xcf0821bc, 0xc2032fb5, 0xe132058a, 0xec390b83, 0xfb241998, 0xf62f1791, 0xd68d764d, 0xdb867844, 0xcc9b6a5f, 0xc1906456, 0xe2a14e69, 0xefaa4060, 0xf8b7527b, 0xf5bc5c72, 0xbed50605, 0xb3de080c, 0xa4c31a17, 0xa9c8141e, 0x8af93e21, 0x87f23028, 0x90ef2233, 0x9de42c3a, 0x063d96dd, 0x0b3698d4, 0x1c2b8acf, 0x112084c6, 0x3211aef9, 0x3f1aa0f0, 0x2807b2eb, 0x250cbce2, 0x6e65e695, 0x636ee89c, 0x7473fa87, 0x7978f48e, 0x5a49deb1, 0x5742d0b8, 0x405fc2a3, 0x4d54ccaa, 0xdaf741ec, 0xd7fc4fe5, 0xc0e15dfe, 0xcdea53f7, 0xeedb79c8, 0xe3d077c1, 0xf4cd65da, 0xf9c66bd3, 0xb2af31a4, 0xbfa43fad, 0xa8b92db6, 0xa5b223bf, 0x86830980, 0x8b880789, 0x9c951592, 0x919e1b9b, 0x0a47a17c, 0x074caf75, 0x1051bd6e, 0x1d5ab367, 0x3e6b9958, 0x33609751, 0x247d854a, 0x29768b43, 0x621fd134, 0x6f14df3d, 0x7809cd26, 0x7502c32f, 0x5633e910, 0x5b38e719, 0x4c25f502, 0x412efb0b, 0x618c9ad7, 0x6c8794de, 0x7b9a86c5, 0x769188cc, 0x55a0a2f3, 0x58abacfa, 0x4fb6bee1, 0x42bdb0e8, 0x09d4ea9f, 0x04dfe496, 0x13c2f68d, 0x1ec9f884, 0x3df8d2bb, 0x30f3dcb2, 0x27eecea9, 0x2ae5c0a0, 0xb13c7a47, 0xbc37744e, 0xab2a6655, 0xa621685c, 0x85104263, 0x881b4c6a, 0x9f065e71, 0x920d5078, 0xd9640a0f, 0xd46f0406, 0xc372161d, 0xce791814, 0xed48322b, 0xe0433c22, 0xf75e2e39, 0xfa552030, 0xb701ec9a, 0xba0ae293, 0xad17f088, 0xa01cfe81, 0x832dd4be, 0x8e26dab7, 0x993bc8ac, 0x9430c6a5, 0xdf599cd2, 0xd25292db, 0xc54f80c0, 0xc8448ec9, 0xeb75a4f6, 0xe67eaaff, 0xf163b8e4, 0xfc68b6ed, 0x67b10c0a, 0x6aba0203, 0x7da71018, 0x70ac1e11, 0x539d342e, 0x5e963a27, 0x498b283c, 0x44802635, 0x0fe97c42, 0x02e2724b, 0x15ff6050, 0x18f46e59, 0x3bc54466, 0x36ce4a6f, 0x21d35874, 0x2cd8567d, 0x0c7a37a1, 0x017139a8, 0x166c2bb3, 0x1b6725ba, 0x38560f85, 0x355d018c, 0x22401397, 0x2f4b1d9e, 0x642247e9, 0x692949e0, 0x7e345bfb, 0x733f55f2, 0x500e7fcd, 0x5d0571c4, 0x4a1863df, 0x47136dd6, 0xdccad731, 0xd1c1d938, 0xc6dccb23, 0xcbd7c52a, 0xe8e6ef15, 0xe5ede11c, 0xf2f0f307, 0xfffbfd0e, 0xb492a779, 0xb999a970, 0xae84bb6b, 0xa38fb562, 0x80be9f5d, 0x8db59154, 0x9aa8834f, 0x97a38d46])'\nU4 = v'new Uint32Array([0x00000000, 0x090d0b0e, 0x121a161c, 0x1b171d12, 0x24342c38, 0x2d392736, 0x362e3a24, 0x3f23312a, 0x48685870, 0x4165537e, 0x5a724e6c, 0x537f4562, 0x6c5c7448, 0x65517f46, 0x7e466254, 0x774b695a, 0x90d0b0e0, 0x99ddbbee, 0x82caa6fc, 0x8bc7adf2, 0xb4e49cd8, 0xbde997d6, 0xa6fe8ac4, 0xaff381ca, 0xd8b8e890, 0xd1b5e39e, 0xcaa2fe8c, 0xc3aff582, 0xfc8cc4a8, 0xf581cfa6, 0xee96d2b4, 0xe79bd9ba, 0x3bbb7bdb, 0x32b670d5, 0x29a16dc7, 0x20ac66c9, 0x1f8f57e3, 0x16825ced, 0x0d9541ff, 0x04984af1, 0x73d323ab, 0x7ade28a5, 0x61c935b7, 0x68c43eb9, 0x57e70f93, 0x5eea049d, 0x45fd198f, 0x4cf01281, 0xab6bcb3b, 0xa266c035, 0xb971dd27, 0xb07cd629, 0x8f5fe703, 0x8652ec0d, 0x9d45f11f, 0x9448fa11, 0xe303934b, 0xea0e9845, 0xf1198557, 0xf8148e59, 0xc737bf73, 0xce3ab47d, 0xd52da96f, 0xdc20a261, 0x766df6ad, 0x7f60fda3, 0x6477e0b1, 0x6d7aebbf, 0x5259da95, 0x5b54d19b, 0x4043cc89, 0x494ec787, 0x3e05aedd, 0x3708a5d3, 0x2c1fb8c1, 0x2512b3cf, 0x1a3182e5, 0x133c89eb, 0x082b94f9, 0x01269ff7, 0xe6bd464d, 0xefb04d43, 0xf4a75051, 0xfdaa5b5f, 0xc2896a75, 0xcb84617b, 0xd0937c69, 0xd99e7767, 0xaed51e3d, 0xa7d81533, 0xbccf0821, 0xb5c2032f, 0x8ae13205, 0x83ec390b, 0x98fb2419, 0x91f62f17, 0x4dd68d76, 0x44db8678, 0x5fcc9b6a, 0x56c19064, 0x69e2a14e, 0x60efaa40, 0x7bf8b752, 0x72f5bc5c, 0x05bed506, 0x0cb3de08, 0x17a4c31a, 0x1ea9c814, 0x218af93e, 0x2887f230, 0x3390ef22, 0x3a9de42c, 0xdd063d96, 0xd40b3698, 0xcf1c2b8a, 0xc6112084, 0xf93211ae, 0xf03f1aa0, 0xeb2807b2, 0xe2250cbc, 0x956e65e6, 0x9c636ee8, 0x877473fa, 0x8e7978f4, 0xb15a49de, 0xb85742d0, 0xa3405fc2, 0xaa4d54cc, 0xecdaf741, 0xe5d7fc4f, 0xfec0e15d, 0xf7cdea53, 0xc8eedb79, 0xc1e3d077, 0xdaf4cd65, 0xd3f9c66b, 0xa4b2af31, 0xadbfa43f, 0xb6a8b92d, 0xbfa5b223, 0x80868309, 0x898b8807, 0x929c9515, 0x9b919e1b, 0x7c0a47a1, 0x75074caf, 0x6e1051bd, 0x671d5ab3, 0x583e6b99, 0x51336097, 0x4a247d85, 0x4329768b, 0x34621fd1, 0x3d6f14df, 0x267809cd, 0x2f7502c3, 0x105633e9, 0x195b38e7, 0x024c25f5, 0x0b412efb, 0xd7618c9a, 0xde6c8794, 0xc57b9a86, 0xcc769188, 0xf355a0a2, 0xfa58abac, 0xe14fb6be, 0xe842bdb0, 0x9f09d4ea, 0x9604dfe4, 0x8d13c2f6, 0x841ec9f8, 0xbb3df8d2, 0xb230f3dc, 0xa927eece, 0xa02ae5c0, 0x47b13c7a, 0x4ebc3774, 0x55ab2a66, 0x5ca62168, 0x63851042, 0x6a881b4c, 0x719f065e, 0x78920d50, 0x0fd9640a, 0x06d46f04, 0x1dc37216, 0x14ce7918, 0x2bed4832, 0x22e0433c, 0x39f75e2e, 0x30fa5520, 0x9ab701ec, 0x93ba0ae2, 0x88ad17f0, 0x81a01cfe, 0xbe832dd4, 0xb78e26da, 0xac993bc8, 0xa59430c6, 0xd2df599c, 0xdbd25292, 0xc0c54f80, 0xc9c8448e, 0xf6eb75a4, 0xffe67eaa, 0xe4f163b8, 0xedfc68b6, 0x0a67b10c, 0x036aba02, 0x187da710, 0x1170ac1e, 0x2e539d34, 0x275e963a, 0x3c498b28, 0x35448026, 0x420fe97c, 0x4b02e272, 0x5015ff60, 0x5918f46e, 0x663bc544, 0x6f36ce4a, 0x7421d358, 0x7d2cd856, 0xa10c7a37, 0xa8017139, 0xb3166c2b, 0xba1b6725, 0x8538560f, 0x8c355d01, 0x97224013, 0x9e2f4b1d, 0xe9642247, 0xe0692949, 0xfb7e345b, 0xf2733f55, 0xcd500e7f, 0xc45d0571, 0xdf4a1863, 0xd647136d, 0x31dccad7, 0x38d1c1d9, 0x23c6dccb, 0x2acbd7c5, 0x15e8e6ef, 0x1ce5ede1, 0x07f2f0f3, 0x0efffbfd, 0x79b492a7, 0x70b999a9, 0x6bae84bb, 0x62a38fb5, 0x5d80be9f, 0x548db591, 0x4f9aa883, 0x4697a38d])'\n\n# }}}\n\nclass AES: # {{{\n\n    def __init__(self, key):\n        self.working_mem = [Uint32Array(4), Uint32Array(4)]\n        rounds = number_of_rounds[key.length]\n        if not rounds:\n            raise ValueError('invalid key size (must be length 16, 24 or 32)')\n\n        # encryption round keys\n        self._Ke = v'[]'\n\n        # decryption round keys\n        self._Kd = v'[]'\n\n        for v'var i = 0; i <= rounds; i++':\n            self._Ke.push(Uint32Array(4))\n            self._Kd.push(Uint32Array(4))\n\n        round_key_count = (rounds + 1) * 4\n        KC = key.length / 4\n\n        # convert the key into ints\n        tk = Uint32Array(KC)\n        convert_to_int32(key, tk)\n\n        # copy values into round key arrays\n        index = 0\n        for v'var i = 0; i < KC; i++':\n            index = i >> 2\n            self._Ke[index][i % 4] = tk[i]\n            self._Kd[rounds - index][i % 4] = tk[i]\n\n        # key expansion (fips-197 section 5.2)\n        rconpointer = 0\n        t = KC\n        while t < round_key_count:\n            tt = tk[KC - 1]\n            tk[0] ^= ((S[(tt >> 16) & 0xFF] << 24) ^\n                      (S[(tt >>  8) & 0xFF] << 16) ^\n                      (S[ tt        & 0xFF] <<  8) ^\n                       S[(tt >> 24) & 0xFF]        ^\n                      (rcon[rconpointer] << 24))\n            rconpointer += 1\n\n            # key expansion (for non-256 bit)\n            if KC != 8:\n                for v'var i = 1; i < KC; i++':\n                    tk[i] ^= tk[i - 1]\n\n            # key expansion for 256-bit keys is \"slightly different\" (fips-197)\n            else:\n                for v'var i = 1; i < (KC / 2); i++':\n                    tk[i] ^= tk[i - 1]\n                tt = tk[(KC / 2) - 1]\n\n                tk[KC / 2] ^= (S[ tt        & 0xFF]        ^\n                              (S[(tt >>  8) & 0xFF] <<  8) ^\n                              (S[(tt >> 16) & 0xFF] << 16) ^\n                              (S[(tt >> 24) & 0xFF] << 24))\n\n                for v'var i = (KC / 2) + 1; i < KC; i++':\n                    tk[i] ^= tk[i - 1]\n\n            # copy values into round key arrays\n            i = 0\n            while i < KC and t < round_key_count:\n                r = t >> 2\n                c = t % 4\n                self._Ke[r][c] = tk[i]\n                self._Kd[rounds - r][c] = tk[v'i++']\n                t += 1\n\n        # inverse-cipher-ify the decryption round key (fips-197 section 5.3)\n        for v'var r = 1; r < rounds; r++':\n            for v'var c = 0; c < 4; c++':\n                tt = self._Kd[r][c]\n                self._Kd[r][c] = (U1[(tt >> 24) & 0xFF] ^\n                                  U2[(tt >> 16) & 0xFF] ^\n                                  U3[(tt >>  8) & 0xFF] ^\n                                  U4[ tt        & 0xFF])\n\n    def _crypt(self, ciphertext, offset, encrypt):\n        if encrypt:\n            R1 = T1; R2 = T2; R3 = T3; R4 = T4\n            o1 = 1; o3 = 3\n            SB = S\n            K = self._Ke\n        else:\n            R1 = T5; R2 = T6; R3 = T7; R4 = T8\n            o1 = 3; o3 = 1\n            SB = Si\n            K = self._Kd\n        rounds = K.length - 1\n        a = self.working_mem[0]\n        t = self.working_mem[1]\n\n        # XOR plaintext with key\n        for v'var i = 0; i < 4; i++':\n            t[i] ^= K[0][i]\n\n        # apply round transforms\n        for v'var r = 1; r < rounds; r++':\n            for v'var i = 0; i < 4; i++':\n                a[i] = (R1[(t[i] >> 24) & 0xff] ^\n                        R2[(t[(i + o1) % 4] >> 16) & 0xff] ^\n                        R3[(t[(i +  2) % 4] >>  8) & 0xff] ^\n                        R4[ t[(i + o3) % 4]        & 0xff] ^\n                        K[r][i])\n            t.set(a)\n\n        # the last round is special\n        for v'var i = 0; i < 4; i++':\n            tt = K[rounds][i]\n            ciphertext[offset + 4 * i] = (SB[(t[i] >> 24) & 0xff] ^ (tt >> 24)) & 0xff\n            ciphertext[offset + 4 * i + 1] = (SB[(t[(i + o1) % 4] >> 16) & 0xff] ^ (tt >> 16)) & 0xff\n            ciphertext[offset + 4 * i + 2] = (SB[(t[(i +  2) % 4] >>  8) & 0xff] ^ (tt >>  8)) & 0xff\n            ciphertext[offset + 4 * i + 3] = (SB[ t[(i + o3) % 4]        & 0xff] ^  tt       ) & 0xff\n\n    def encrypt(self, plaintext, ciphertext, offset):\n        convert_to_int32(plaintext, self.working_mem[1], offset, 16)\n        return self._crypt(ciphertext, offset, True)\n\n    def encrypt32(self, plaintext, ciphertext, offset):\n        self.working_mem[1].set(plaintext)\n        return self._crypt(ciphertext, offset, True)\n\n    def decrypt(self, ciphertext, plaintext, offset):\n        convert_to_int32(ciphertext, self.working_mem[1], offset, 16)\n        return self._crypt(plaintext, offset, False)\n\n    def decrypt32(self, ciphertext, plaintext, offset):\n        self.working_mem[1].set(ciphertext)\n        return self._crypt(plaintext, offset, False)\n# }}}\n\ndef random_bytes_insecure(sz):\n    ans = Uint8Array(sz)\n    for v'var i = 0; i < sz; i++':\n        ans[i] = Math.floor(Math.random() * 256)\n    return ans\n\ndef random_bytes_secure(sz):\n    ans = Uint8Array(sz)\n    crypto.getRandomValues(ans)\n    return ans\n\nrandom_bytes = random_bytes_secure if jstype(crypto) is not 'undefined' and jstype(crypto.getRandomValues) is 'function' else random_bytes_insecure\nif random_bytes is random_bytes_insecure:\n    try:\n        noderandom = require('crypto').randomBytes\n        random_bytes = def(sz):\n            return Uint8Array(noderandom(sz))\n    except:\n        print('WARNING: Using insecure RNG for AES')\n\nclass ModeOfOperation:  # {{{\n\n    def __init__(self, key):\n        self.key = key or generate_key(32)\n        self.aes = AES(self.key)\n\n    @property\n    def key_as_js(self):\n        return typed_array_as_js(self.key)\n\n    def tag_as_bytes(self, tag):\n        if isinstance(tag, Uint8Array):\n            return tag\n        if not tag:\n            return Uint8Array(0)\n        if jstype(tag) is 'string':\n            return string_to_bytes(tag)\n        raise TypeError('Invalid tag, must be a string or a Uint8Array')\n# }}}\n\nclass GaloisField:  # {{{\n\n    def __init__(self, sub_key):\n        k32 = Uint32Array(4)\n        convert_to_int32(sub_key, k32, 0)\n        self.m = self.generate_hash_table(k32)\n        self.wmem = Uint32Array(4)\n\n    def power(self, x, out):\n        lsb = x[3] & 1\n        for v'var i = 3; i > 0; --i':\n            out[i] = (x[i] >>> 1) | ((x[i - 1] & 1) << 31)\n        out[0] = x[0] >>> 1\n        if lsb:\n            out[0] ^= 0xE1000000\n\n    def multiply(self, x, y):\n        z_i = Uint32Array(4)\n        v_i = Uint32Array(y)\n        for v'var i = 0; i < 128; ++i':\n            x_i = x[(i / 32) | 0] & (1 << (31 - i % 32))\n            if x_i:\n                z_i[0] ^= v_i[0]\n                z_i[1] ^= v_i[1]\n                z_i[2] ^= v_i[2]\n                z_i[3] ^= v_i[3]\n            self.power(v_i, v_i)\n        return z_i\n\n    def generate_sub_hash_table(self, mid):\n        bits = mid.length\n        size = 1 << bits\n        half = size >>> 1\n        m = Array(size)\n        m[half] = Uint32Array(mid)\n        i = half >>> 1\n        while i > 0:\n            m[i] = Uint32Array(4)\n            self.power(m[2 * i], m[i])\n            i >>= 1\n        i = 2\n        while i < half:\n            for v'var j = 1; j < i; ++j':\n                m_i = m[i]\n                m_j = m[j]\n                m[i + j] = x = Uint32Array(4)\n                for v'var c = 0; c < 4; c++':\n                    x[c] = m_i[c] ^ m_j[c]\n            i *= 2\n        m[0] = Uint32Array(4)\n        for v'i = half + 1; i < size; ++i':\n            x = m[i ^ half]\n            m[i] = y = Uint32Array(4)\n            for v'var c = 0; c < 4; c++':\n                y[c] = mid[c] ^ x[c]\n        return m\n\n    def generate_hash_table(self, key_as_int32_array):\n        bits = key_as_int32_array.length\n        multiplier = 8 / bits\n        per_int = 4 * multiplier\n        size = 16 * multiplier\n        ans = Array(size)\n        for v'var i =0; i < size; ++i':\n            tmp = Uint32Array(4)\n            idx = (i/ per_int) | 0\n            shft = ((per_int - 1 - (i % per_int)) * bits)\n            tmp[idx] = (1 << (bits - 1)) << shft\n            ans[i] = self.generate_sub_hash_table(self.multiply(tmp, key_as_int32_array))\n        return ans\n\n    def table_multiply(self, x):\n        z = Uint32Array(4)\n        for v'var i = 0; i < 32; ++i':\n            idx = (i / 8) | 0\n            x_i = (x[idx] >>> ((7 - (i % 8)) * 4)) & 0xF\n            ah = self.m[i][x_i]\n            z[0] ^= ah[0]\n            z[1] ^= ah[1]\n            z[2] ^= ah[2]\n            z[3] ^= ah[3]\n        return z\n\n    def ghash(self, x, y):\n        # Corresponds to the XOR + mult_H operation from the paper\n        z = self.wmem\n        z[0] = y[0] ^ x[0]\n        z[1] = y[1] ^ x[1]\n        z[2] = y[2] ^ x[2]\n        z[3] = y[3] ^ x[3]\n        return self.table_multiply(z)\n\n# }}}\n\n# }}}\n\ndef generate_key(sz):\n    if not number_of_rounds[sz]:\n        raise ValueError('Invalid key size, must be: 16, 24 or 32')\n    return random_bytes(sz)\n\ndef generate_tag(sz):\n    return random_bytes(sz or 32)\n\ndef typed_array_as_js(x):\n    name = x.constructor.name or 'Uint8Array'\n    return '(new ' + name + '(' + JSON.stringify(Array.prototype.slice.call(x)) + '))'\n\nclass CBC(ModeOfOperation):  # {{{\n\n    def encrypt_bytes(self, bytes, tag_bytes, iv):\n        iv = first_iv = iv or random_bytes(16)\n        mlen = bytes.length + tag_bytes.length\n        padsz = (16 - (mlen % 16)) % 16\n        inputbytes = Uint8Array(mlen + padsz)\n        if tag_bytes.length:\n            inputbytes.set(tag_bytes)\n        inputbytes.set(bytes, tag_bytes.length)\n\n        offset = 0\n        outputbytes = Uint8Array(inputbytes.length)\n        for v'var block = 0; block < inputbytes.length; block += 16':\n            if block > 0:\n                iv, offset = outputbytes, block - 16\n            for v'var i = 0; i < 16; i++':\n                inputbytes[block + i] ^= iv[offset + i]\n            self.aes.encrypt(inputbytes, outputbytes, block)\n        return {'iv':first_iv, 'cipherbytes':outputbytes}\n\n    def encrypt(self, plaintext, tag):\n        return self.encrypt_bytes(string_to_bytes(plaintext), self.tag_as_bytes(tag))\n\n    def decrypt_bytes(self, inputbytes, tag_bytes, iv):\n        offset = 0\n        outputbytes = Uint8Array(inputbytes.length)\n        for v'var block = 0; block < inputbytes.length; block += 16':\n            self.aes.decrypt(inputbytes, outputbytes, block)\n            if block > 0:\n                iv, offset = inputbytes, block - 16\n            for v'var i = 0; i < 16; i++':\n                outputbytes[block + i] ^= iv[offset + i]\n        for v'var i = 0; i < tag_bytes.length; i++':\n            if tag_bytes[i] != outputbytes[i]:\n                raise ValueError('Corrupt message')\n        outputbytes = outputbytes.subarray(tag_bytes.length)\n        return outputbytes\n\n    def decrypt(self, output_from_encrypt, tag):\n        ans = self.decrypt_bytes(output_from_encrypt.cipherbytes, self.tag_as_bytes(tag), output_from_encrypt.iv)\n        return str.rstrip(bytes_to_string(ans), '\\0')\n# }}}\n\nclass CTR(ModeOfOperation):  # {{{\n\n    # Note that this mode of operation requires the pair of (counterbytes,\n    # secret key) to always be unique, for every block. Therefore, if you are\n    # using it for bi-directional messaging it is best to use a different\n    # secret key for each direction\n\n    def __init__(self, key, iv):\n        ModeOfOperation.__init__(self, key)\n        self.wmem = Uint8Array(16)\n        self.counter_block = Uint8Array(iv or 16)\n        if self.counter_block.length != 16:\n            raise ValueError('iv must be 16 bytes long')\n        self.counter_index = 16\n\n    def _crypt(self, bytes):\n        for v'var i = 0; i < bytes.length; i++, self.counter_index++':\n            if self.counter_index is 16:\n                self.counter_index = 0\n                self.aes.encrypt(self.counter_block, self.wmem, 0)\n                increment_counter(self.counter_block)\n            bytes[i] ^= self.wmem[self.counter_index]\n        self.counter_index = 16\n\n    def encrypt(self, plaintext, tag):\n        outbytes = string_to_bytes(plaintext)\n        counterbytes = Uint8Array(self.counter_block)\n        if tag:\n            tag_bytes = self.tag_as_bytes(tag)\n            t = Uint8Array(outbytes.length + tag_bytes.length)\n            t.set(tag_bytes)\n            t.set(outbytes, tag_bytes.length)\n            outbytes = t\n        self._crypt(outbytes)\n        return {'cipherbytes':outbytes, 'counterbytes':counterbytes}\n\n    def __enter__(self):\n        self.before_index = self.counter_index\n        self.before_counter = Uint8Array(self.counter_block)\n\n    def __exit__(self):\n        self.counter_index = self.before_index\n        self.counter_block = self.before_counter\n\n    def decrypt(self, output_from_encrypt, tag):\n        b = Uint8Array(output_from_encrypt.cipherbytes)\n        with self:\n            self.counter_block = output_from_encrypt.counterbytes\n            self.counter_index = 16\n            self._crypt(b)\n        offset = 0\n        if tag:\n            tag_bytes = self.tag_as_bytes(tag)\n            for v'var i = 0; i < tag_bytes.length; i++':\n                if tag_bytes[i] != b[i]:\n                    raise ValueError('Corrupted message')\n            offset = tag_bytes.length\n        return bytes_to_string(b, offset)\n# }}}\n\nclass GCM(ModeOfOperation):  # {{{\n\n    # Note that this mode of operation requires the pair of (iv,\n    # secret key) to always be unique, for every message. Therefore, if you are\n    # using it for bi-directional messaging it is best to use a different\n    # secret key for each direction (you could also use random_key,\n    # but that has a non-zero probability of repeating keys).\n    # See http://web.cs.ucdavis.edu/~rogaway/ocb/gcm.pdf\n\n    def __init__(self, key, random_iv=False):\n        ModeOfOperation.__init__(self, key)\n        self.random_iv = random_iv\n        if not random_iv:\n            self.current_iv = Uint8Array(12)\n\n        # Generate the hash subkey\n        H = Uint8Array(16)\n        self.aes.encrypt(Uint8Array(16), H, 0)\n        self.galois = GaloisField(H)\n\n        # Working memory\n        self.J0 = Uint32Array(4)\n        self.wmem = Uint32Array(4)\n        self.byte_block = Uint8Array(16)\n\n    def increment_iv(self):\n        c = self.current_iv\n        for v'var i = 11; i >=0; i--':\n            if c[i] is 255:\n                if i is 0:\n                    raise ValueError('The GCM IV space is exhausted, cannot encrypt anymore messages with this key as doing so would cause the IV to repeat')\n                c[i] = 0\n            else:\n                c[i] += 1\n                break\n\n    def _create_j0(self, iv):\n        J0 = self.J0\n        if iv.length is 12:\n            convert_to_int32(iv, J0)\n            J0[3] = 1\n        else:\n            J0.fill(0)\n            tmp = convert_to_int32_pad(iv)\n            while tmp.length:\n                J0 = self.galois.ghash(J0, tmp)\n                tmp = tmp.subarray(4)\n            tmp = Uint32Array(4)\n            tmp.set(from_64_to_32(iv.length * 8), 2)\n            J0 = self.galois.ghash(J0, tmp)\n        return J0\n\n    def _start(self, iv, additional_data):\n        J0 = self._create_j0(iv)\n        # Generate initial counter block\n        in_block = Uint32Array(J0)\n        in_block[3] = (in_block[3] + 1) & 0xFFFFFFFF  # increment counter\n\n        # Process additional_data\n        S = Uint32Array(4)\n        overflow = additional_data.length % 16\n        for v'var i = 0; i < additional_data.length - overflow; i += 16':\n            convert_to_int32(additional_data, self.wmem, i, 16)\n            S = self.galois.ghash(S, self.wmem)\n        if overflow:\n            self.byte_block.fill(0)\n            self.byte_block.set(additional_data.subarray(additional_data.length - overflow))\n            convert_to_int32(self.byte_block, self.wmem)\n            S = self.galois.ghash(S, self.wmem)\n        return J0, in_block, S\n\n    def _finish(self, iv, J0, adata_len, S, outbytes):\n        # Mix the lengths into S\n        lengths = Uint32Array(4)\n        lengths.set(from_64_to_32(adata_len * 8))\n        lengths.set(from_64_to_32(outbytes.length * 8), 2)\n        S = self.galois.ghash(S, lengths)\n\n        # Create the tag\n        self.aes.encrypt32(J0, self.byte_block, 0)\n        convert_to_int32(self.byte_block, self.wmem)\n        tag = Uint32Array(4)\n        for v'var i = 0; i < S.length; i++':\n            tag[i] = S[i] ^ self.wmem[i]\n        return {'iv':iv, 'cipherbytes':outbytes, 'tag':tag}\n\n    def _crypt(self, iv, bytes, additional_data, decrypt):\n        ghash = self.galois.ghash.bind(self.galois)\n        outbytes = Uint8Array(bytes.length)\n        J0, in_block, S = self._start(iv, additional_data)\n        bb = self.byte_block\n        enc = self.aes.encrypt32.bind(self.aes)\n        hash_bytes = bytes if decrypt else outbytes\n\n        # Create the ciphertext, encrypting block by block\n        for v'var i = 0, counter_index = 16; i < bytes.length; i++, counter_index++':\n            if counter_index is 16:\n                # Encrypt counter and increment it\n                enc(in_block, bb, 0)\n                in_block[3] = (in_block[3] + 1) & 0xFFFFFFFF  # increment counter\n                counter_index = 0\n            # Output is XOR of encrypted counter with input\n            outbytes[i] = bytes[i] ^ bb[counter_index]\n            if counter_index is 15:\n                # We have completed a block, update the hash\n                convert_to_int32(hash_bytes, self.wmem, i - 15, 16)\n                S = ghash(S, self.wmem)\n\n        # Check if we have a last partial block\n        overflow = outbytes.length % 16\n        if overflow:\n            # partial output block\n            bb.fill(0)\n            bb.set(hash_bytes.subarray(hash_bytes.length - overflow))\n            convert_to_int32(bb, self.wmem)\n            S = ghash(S, self.wmem)\n\n        return self._finish(iv, J0, additional_data.length, S, outbytes)\n\n    def encrypt(self, plaintext, tag):\n        if self.random_iv:\n            iv = random_bytes(12)\n        else:\n            self.increment_iv()\n            iv = self.current_iv\n        return self._crypt(iv, string_to_bytes(plaintext), self.tag_as_bytes(tag), False)\n\n    def decrypt(self, output_from_encrypt, tag):\n        if output_from_encrypt.tag.length != 4:\n            raise ValueError('Corrupted message')\n        ans = self._crypt(output_from_encrypt.iv, output_from_encrypt.cipherbytes, self.tag_as_bytes(tag), True)\n        if ans.tag != output_from_encrypt.tag:\n            raise ValueError('Corrupted message')\n        return bytes_to_string(ans.cipherbytes)\n# }}}\n","__stdlib__/elementmaker.pyj":"# vim:fileencoding=utf-8\n# License: GPL v3 Copyright: 2015, Kovid Goyal <kovid at kovidgoyal.net>\n\nhtml_elements = {\n    'a', 'abbr', 'acronym', 'address', 'area',\n    'article', 'aside', 'audio', 'b', 'big', 'blockquote', 'br', 'button',\n    'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup',\n    'command', 'datagrid', 'datalist', 'dd', 'del', 'details', 'dfn',\n    'dialog', 'dir', 'div', 'dl', 'dt', 'em', 'event-source', 'fieldset',\n    'figcaption', 'figure', 'footer', 'font', 'form', 'header', 'h1',\n    'h2', 'h3', 'h4', 'h5', 'h6', 'hr', 'i', 'iframe', 'img', 'input', 'ins',\n    'keygen', 'kbd', 'label', 'legend', 'li', 'm', 'map', 'menu', 'meter',\n    'multicol', 'nav', 'nextid', 'ol', 'output', 'optgroup', 'option',\n    'p', 'pre', 'progress', 'q', 's', 'samp', 'script', 'section', 'select',\n    'small', 'sound', 'source', 'spacer', 'span', 'strike', 'strong', 'style',\n    'sub', 'sup', 'table', 'tbody', 'td', 'textarea', 'time', 'tfoot',\n    'th', 'thead', 'tr', 'tt', 'u', 'ul', 'var', 'video'\n}\n\nmathml_elements = {\n    'maction', 'math', 'merror', 'mfrac', 'mi',\n    'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom',\n    'mprescripts', 'mroot', 'mrow', 'mspace', 'msqrt', 'mstyle', 'msub',\n    'msubsup', 'msup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder',\n    'munderover', 'none'\n}\n\nsvg_elements = {\n    'a', 'animate', 'animateColor', 'animateMotion',\n    'animateTransform', 'clipPath', 'circle', 'defs', 'desc', 'ellipse',\n    'font-face', 'font-face-name', 'font-face-src', 'g', 'glyph', 'hkern',\n    'linearGradient', 'line', 'marker', 'metadata', 'missing-glyph',\n    'mpath', 'path', 'polygon', 'polyline', 'radialGradient', 'rect',\n    'set', 'stop', 'svg', 'switch', 'text', 'title', 'tspan', 'use'\n}\n\nhtml5_tags = html_elements.union(mathml_elements).union(svg_elements)\n\ndef _makeelement(tag, *args, **kwargs):\n    ans = this.createElement(tag)\n\n    for attr in kwargs:\n        vattr = str.replace(str.rstrip(attr, '_'), '_', '-')\n        val = kwargs[attr]\n        if callable(val):\n            if str.startswith(attr, 'on'):\n                attr = attr[2:]\n            ans.addEventListener(attr, val)\n        elif val is True:\n            ans.setAttribute(vattr, vattr)\n        elif jstype(val) is 'string':\n            ans.setAttribute(vattr, val)\n\n    for arg in args:\n        if jstype(arg) is 'string':\n            arg = this.createTextNode(arg)\n        ans.appendChild(arg)\n    return ans\n\ndef maker_for_document(document):\n    # Create an elementmaker to be used with the specified document\n    E = _makeelement.bind(document)\n    Object.defineProperties(E, {\n        tag: {\n            'value':_makeelement.bind(document, tag)\n        } for tag in html5_tags\n    })\n    return E\n\nif jstype(document) is 'undefined':\n    E = maker_for_document({\n        'createTextNode': def(value): return value;,\n        'createElement': def(name):\n            return  {\n                'name':name,\n                'children':[],\n                'attributes':{},\n                'setAttribute': def(name, val): this.attributes[name] = val;,\n                'appendChild': def(child): this.children.push(child);,\n            }\n    })\nelse:\n    E = maker_for_document(document)\n","__stdlib__/encodings.pyj":"# vim:fileencoding=utf-8\n# License: BSD Copyright: 2016, Kovid Goyal <kovid at kovidgoyal.net>\n\ndef base64encode(bytes, altchars, pad_char):\n    # Convert an array of bytes into a base-64 encoded string\n    l = bytes.length\n    remainder = l % 3\n    main_length = l - remainder\n    encodings = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789' + (altchars or '+/')\n    pad_char = '=' if pad_char is undefined else pad_char\n    ans = v'[]'\n    for v'var i = 0; i < main_length; i += 3':\n        chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2]\n        ans.push(encodings[(chunk & 16515072) >> 18], encodings[(chunk & 258048) >> 12], encodings[(chunk & 4032) >> 6], encodings[chunk & 63])\n    if remainder is 1:\n        chunk = bytes[main_length]\n        ans.push(encodings[(chunk & 252) >> 2], encodings[(chunk & 3) << 4], pad_char, pad_char)\n    elif remainder is 2:\n        chunk = (bytes[main_length] << 8) | bytes[main_length + 1]\n        ans.push(encodings[(chunk & 64512) >> 10], encodings[(chunk & 1008) >> 4], encodings[(chunk & 15) << 2], pad_char)\n    return ans.join('')\n\ndef base64decode(string):\n    # convert the output of base64encode back into an array of bytes\n    # (Uint8Array) only works with the standard altchars and pad_char\n    if jstype(window) is not 'undefined':\n        chars = window.atob(string)\n    else:\n        chars = new Buffer(string, 'base64').toString('binary')  # noqa: undef\n    ans = Uint8Array(chars.length)\n    for i in range(ans.length):\n        ans[i] = chars.charCodeAt(i)\n    return ans\n\ndef urlsafe_b64encode(bytes, pad_char):\n    return base64encode(bytes, '-_', pad_char)\n\ndef urlsafe_b64decode(string):\n    string = String.prototype.replace.call(string, /[_-]/g, def(m): return '+' if m is '-' else '/';)\n    return base64decode(string)\n\ndef hexlify(bytes):\n    ans = v'[]'\n    for v'var i = 0; i < bytes.length; i++':\n        x = bytes[i].toString(16)\n        if x.length is 1:\n            x = '0' + x\n        ans.push(x)\n    return ans.join('')\n\ndef unhexlify(string):\n    num = string.length // 2\n    if num * 2 is not string.length:\n        raise ValueError('string length is not a multiple of two')\n    ans = Uint8Array(num)\n    for v'var i = 0; i < num; i++':\n        x = parseInt(string[i*2:i*2+2], 16)\n        if isNaN(x):\n            raise ValueError('string is not hex-encoded')\n        ans[i] = x\n    return ans\n\nutf8_decoder_table = v'''[\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 00..1f\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 20..3f\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 40..5f\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 60..7f\n  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9, // 80..9f\n  7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7, // a0..bf\n  8,8,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, // c0..df\n  0xa,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x3,0x4,0x3,0x3, // e0..ef\n  0xb,0x6,0x6,0x6,0x5,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8, // f0..ff\n  0x0,0x1,0x2,0x3,0x5,0x8,0x7,0x1,0x1,0x1,0x4,0x6,0x1,0x1,0x1,0x1, // s0..s0\n  1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,1,0,1,1,1,1,1,1, // s1..s2\n  1,2,1,1,1,1,1,2,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1, // s3..s4\n  1,2,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,3,1,3,1,1,1,1,1,1, // s5..s6\n  1,3,1,1,1,1,1,3,1,3,1,1,1,1,1,1,1,3,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // s7..s8\n]'''\n\ndef _from_code_point(x):\n    if x <= 0xFFFF:\n        return String.fromCharCode(x)\n    x -= 0x10000\n    return String.fromCharCode((x >> 10) + 0xD800, (x % 0x400) + 0xDC00)\n\ndef utf8_decode(bytes, errors, replacement):\n    # Convert an array of UTF-8 encoded bytes into a string\n    state = 0\n    ans = v'[]'\n\n    for v'var i = 0, l = bytes.length; i < l; i++':  # noqa\n        byte = bytes[i]\n        typ = utf8_decoder_table[byte]\n        codep = (byte & 0x3f) | (codep << 6) if state is not 0 else (0xff >> typ) & (byte)\n        state = utf8_decoder_table[256 + state*16 + typ]\n        if state is 0:\n            ans.push(_from_code_point(codep))\n        elif state is 1:\n            if not errors or errors is 'strict':\n                raise UnicodeDecodeError(str.format('The byte 0x{:02x} at position {} is not valid UTF-8', byte, i))\n            elif errors is 'replace':\n                ans.push(replacement or '?')\n    return ans.join('')\n\ndef utf8_encode_js(string):\n    # Encode a string as an array of UTF-8 bytes\n    escstr = encodeURIComponent(string)\n    ans = v'[]'\n    for v'var i = 0; i < escstr.length; i++':\n        ch = escstr[i]\n        if ch is '%':\n            ans.push(parseInt(escstr[i+1:i+3], 16))\n            i += 2\n        else:\n            ans.push(ch.charCodeAt(0))\n    return Uint8Array(ans)\n\nif jstype(TextEncoder) is 'function':\n    _u8enc = TextEncoder('utf-8')\n    utf8_encode = _u8enc.encode.bind(_u8enc)\n    _u8enc = undefined\nelse:\n    utf8_encode = utf8_encode_js\n\ndef utf8_encode_native(string):\n    return _u8enc.encode(string)\n","__stdlib__/gettext.pyj":"# vim:fileencoding=utf-8\n# License: BSD Copyright: 2015, Kovid Goyal <kovid at kovidgoyal.net>\n\n# noqa: eol-semicolon\n\n# The Plural-Forms parser {{{\n# From: https://github.com/SlexAxton/Jed/blob/master/jed.js licensed under the WTFPL\n\nJed = {}\n\nvr'''\n  Jed.PF = {};\n\n  Jed.PF.parse = function ( p ) {\n    var plural_str = Jed.PF.extractPluralExpr( p );\n    return Jed.PF.parser.parse.call(Jed.PF.parser, plural_str);\n  };\n\n  Jed.PF.compile = function ( p ) {\n    // Handle trues and falses as 0 and 1\n    function imply( val ) {\n      return (val === true ? 1 : val ? val : 0);\n    }\n\n    var ast = Jed.PF.parse( p );\n    return function ( n ) {\n      return imply( Jed.PF.interpreter( ast )( n ) );\n    };\n  };\n\n  Jed.PF.interpreter = function ( ast ) {\n    return function ( n ) {\n      var res;\n      switch ( ast.type ) {\n        case 'GROUP':\n          return Jed.PF.interpreter( ast.expr )( n );\n        case 'TERNARY':\n          if ( Jed.PF.interpreter( ast.expr )( n ) ) {\n            return Jed.PF.interpreter( ast.truthy )( n );\n          }\n          return Jed.PF.interpreter( ast.falsey )( n );\n        case 'OR':\n          return Jed.PF.interpreter( ast.left )( n ) || Jed.PF.interpreter( ast.right )( n );\n        case 'AND':\n          return Jed.PF.interpreter( ast.left )( n ) && Jed.PF.interpreter( ast.right )( n );\n        case 'LT':\n          return Jed.PF.interpreter( ast.left )( n ) < Jed.PF.interpreter( ast.right )( n );\n        case 'GT':\n          return Jed.PF.interpreter( ast.left )( n ) > Jed.PF.interpreter( ast.right )( n );\n        case 'LTE':\n          return Jed.PF.interpreter( ast.left )( n ) <= Jed.PF.interpreter( ast.right )( n );\n        case 'GTE':\n          return Jed.PF.interpreter( ast.left )( n ) >= Jed.PF.interpreter( ast.right )( n );\n        case 'EQ':\n          return Jed.PF.interpreter( ast.left )( n ) == Jed.PF.interpreter( ast.right )( n );\n        case 'NEQ':\n          return Jed.PF.interpreter( ast.left )( n ) != Jed.PF.interpreter( ast.right )( n );\n        case 'MOD':\n          return Jed.PF.interpreter( ast.left )( n ) % Jed.PF.interpreter( ast.right )( n );\n        case 'VAR':\n          return n;\n        case 'NUM':\n          return ast.val;\n        default:\n          throw new Error(\"Invalid Token found.\");\n      }\n    };\n  };\n\n  Jed.PF.extractPluralExpr = function ( p ) {\n    // trim first\n    p = p.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\n\n    if (! /;\\s*$/.test(p)) {\n      p = p.concat(';');\n    }\n\n    var nplurals_re = /nplurals\\=(\\d+);/,\n        plural_re = /plural\\=(.*);/,\n        nplurals_matches = p.match( nplurals_re ),\n        res = {},\n        plural_matches;\n\n    // Find the nplurals number\n    if ( nplurals_matches.length > 1 ) {\n      res.nplurals = nplurals_matches[1];\n    }\n    else {\n      throw new Error('nplurals not found in plural_forms string: ' + p );\n    }\n\n    // remove that data to get to the formula\n    p = p.replace( nplurals_re, \"\" );\n    plural_matches = p.match( plural_re );\n\n    if (!( plural_matches && plural_matches.length > 1 ) ) {\n      throw new Error('`plural` expression not found: ' + p);\n    }\n    return plural_matches[ 1 ];\n  };\n\n  /* Jison generated parser */\n  Jed.PF.parser = (function(){\n\nvar parser = {trace: function trace() { },\nyy: {},\nsymbols_: {\"error\":2,\"expressions\":3,\"e\":4,\"EOF\":5,\"?\":6,\":\":7,\"||\":8,\"&&\":9,\"<\":10,\"<=\":11,\">\":12,\">=\":13,\"!=\":14,\"==\":15,\"%\":16,\"(\":17,\")\":18,\"n\":19,\"NUMBER\":20,\"$accept\":0,\"$end\":1},\nterminals_: {2:\"error\",5:\"EOF\",6:\"?\",7:\":\",8:\"||\",9:\"&&\",10:\"<\",11:\"<=\",12:\">\",13:\">=\",14:\"!=\",15:\"==\",16:\"%\",17:\"(\",18:\")\",19:\"n\",20:\"NUMBER\"},\nproductions_: [0,[3,2],[4,5],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,3],[4,1],[4,1]],\nperformAction: function anonymous(yytext,yyleng,yylineno,yy,yystate,$$,_$) {\n\nvar $0 = $$.length - 1;\nswitch (yystate) {\ncase 1: return { type : 'GROUP', expr: $$[$0-1] };\ncase 2:this.$ = { type: 'TERNARY', expr: $$[$0-4], truthy : $$[$0-2], falsey: $$[$0] };\nbreak;\ncase 3:this.$ = { type: \"OR\", left: $$[$0-2], right: $$[$0] };\nbreak;\ncase 4:this.$ = { type: \"AND\", left: $$[$0-2], right: $$[$0] };\nbreak;\ncase 5:this.$ = { type: 'LT', left: $$[$0-2], right: $$[$0] };\nbreak;\ncase 6:this.$ = { type: 'LTE', left: $$[$0-2], right: $$[$0] };\nbreak;\ncase 7:this.$ = { type: 'GT', left: $$[$0-2], right: $$[$0] };\nbreak;\ncase 8:this.$ = { type: 'GTE', left: $$[$0-2], right: $$[$0] };\nbreak;\ncase 9:this.$ = { type: 'NEQ', left: $$[$0-2], right: $$[$0] };\nbreak;\ncase 10:this.$ = { type: 'EQ', left: $$[$0-2], right: $$[$0] };\nbreak;\ncase 11:this.$ = { type: 'MOD', left: $$[$0-2], right: $$[$0] };\nbreak;\ncase 12:this.$ = { type: 'GROUP', expr: $$[$0-1] };\nbreak;\ncase 13:this.$ = { type: 'VAR' };\nbreak;\ncase 14:this.$ = { type: 'NUM', val: Number(yytext) };\nbreak;\n}\n},\ntable: [{3:1,4:2,17:[1,3],19:[1,4],20:[1,5]},{1:[3]},{5:[1,6],6:[1,7],8:[1,8],9:[1,9],10:[1,10],11:[1,11],12:[1,12],13:[1,13],14:[1,14],15:[1,15],16:[1,16]},{4:17,17:[1,3],19:[1,4],20:[1,5]},{5:[2,13],6:[2,13],7:[2,13],8:[2,13],9:[2,13],10:[2,13],11:[2,13],12:[2,13],13:[2,13],14:[2,13],15:[2,13],16:[2,13],18:[2,13]},{5:[2,14],6:[2,14],7:[2,14],8:[2,14],9:[2,14],10:[2,14],11:[2,14],12:[2,14],13:[2,14],14:[2,14],15:[2,14],16:[2,14],18:[2,14]},{1:[2,1]},{4:18,17:[1,3],19:[1,4],20:[1,5]},{4:19,17:[1,3],19:[1,4],20:[1,5]},{4:20,17:[1,3],19:[1,4],20:[1,5]},{4:21,17:[1,3],19:[1,4],20:[1,5]},{4:22,17:[1,3],19:[1,4],20:[1,5]},{4:23,17:[1,3],19:[1,4],20:[1,5]},{4:24,17:[1,3],19:[1,4],20:[1,5]},{4:25,17:[1,3],19:[1,4],20:[1,5]},{4:26,17:[1,3],19:[1,4],20:[1,5]},{4:27,17:[1,3],19:[1,4],20:[1,5]},{6:[1,7],8:[1,8],9:[1,9],10:[1,10],11:[1,11],12:[1,12],13:[1,13],14:[1,14],15:[1,15],16:[1,16],18:[1,28]},{6:[1,7],7:[1,29],8:[1,8],9:[1,9],10:[1,10],11:[1,11],12:[1,12],13:[1,13],14:[1,14],15:[1,15],16:[1,16]},{5:[2,3],6:[2,3],7:[2,3],8:[2,3],9:[1,9],10:[1,10],11:[1,11],12:[1,12],13:[1,13],14:[1,14],15:[1,15],16:[1,16],18:[2,3]},{5:[2,4],6:[2,4],7:[2,4],8:[2,4],9:[2,4],10:[1,10],11:[1,11],12:[1,12],13:[1,13],14:[1,14],15:[1,15],16:[1,16],18:[2,4]},{5:[2,5],6:[2,5],7:[2,5],8:[2,5],9:[2,5],10:[2,5],11:[2,5],12:[2,5],13:[2,5],14:[2,5],15:[2,5],16:[1,16],18:[2,5]},{5:[2,6],6:[2,6],7:[2,6],8:[2,6],9:[2,6],10:[2,6],11:[2,6],12:[2,6],13:[2,6],14:[2,6],15:[2,6],16:[1,16],18:[2,6]},{5:[2,7],6:[2,7],7:[2,7],8:[2,7],9:[2,7],10:[2,7],11:[2,7],12:[2,7],13:[2,7],14:[2,7],15:[2,7],16:[1,16],18:[2,7]},{5:[2,8],6:[2,8],7:[2,8],8:[2,8],9:[2,8],10:[2,8],11:[2,8],12:[2,8],13:[2,8],14:[2,8],15:[2,8],16:[1,16],18:[2,8]},{5:[2,9],6:[2,9],7:[2,9],8:[2,9],9:[2,9],10:[2,9],11:[2,9],12:[2,9],13:[2,9],14:[2,9],15:[2,9],16:[1,16],18:[2,9]},{5:[2,10],6:[2,10],7:[2,10],8:[2,10],9:[2,10],10:[2,10],11:[2,10],12:[2,10],13:[2,10],14:[2,10],15:[2,10],16:[1,16],18:[2,10]},{5:[2,11],6:[2,11],7:[2,11],8:[2,11],9:[2,11],10:[2,11],11:[2,11],12:[2,11],13:[2,11],14:[2,11],15:[2,11],16:[2,11],18:[2,11]},{5:[2,12],6:[2,12],7:[2,12],8:[2,12],9:[2,12],10:[2,12],11:[2,12],12:[2,12],13:[2,12],14:[2,12],15:[2,12],16:[2,12],18:[2,12]},{4:30,17:[1,3],19:[1,4],20:[1,5]},{5:[2,2],6:[1,7],7:[2,2],8:[1,8],9:[1,9],10:[1,10],11:[1,11],12:[1,12],13:[1,13],14:[1,14],15:[1,15],16:[1,16],18:[2,2]}],\ndefaultActions: {6:[2,1]},\nparseError: function parseError(str, hash) {\n    throw new Error(str);\n},\nparse: function parse(input) {\n    var self = this,\n        stack = [0],\n        vstack = [null], // semantic value stack\n        lstack = [], // location stack\n        table = this.table,\n        yytext = '',\n        yylineno = 0,\n        yyleng = 0,\n        recovering = 0,\n        TERROR = 2,\n        EOF = 1;\n\n    //this.reductionCount = this.shiftCount = 0;\n\n    this.lexer.setInput(input);\n    this.lexer.yy = this.yy;\n    this.yy.lexer = this.lexer;\n    if (typeof this.lexer.yylloc == 'undefined')\n        this.lexer.yylloc = {};\n    var yyloc = this.lexer.yylloc;\n    lstack.push(yyloc);\n\n    if (typeof this.yy.parseError === 'function')\n        this.parseError = this.yy.parseError;\n\n    function popStack (n) {\n        stack.length = stack.length - 2*n;\n        vstack.length = vstack.length - n;\n        lstack.length = lstack.length - n;\n    }\n\n    function lex() {\n        var token;\n        token = self.lexer.lex() || 1; // $end = 1\n        // if token isn't its numeric value, convert\n        if (typeof token !== 'number') {\n            token = self.symbols_[token] || token;\n        }\n        return token;\n    }\n\n    var symbol, preErrorSymbol, state, action, a, r, yyval={},p,len,newState, expected, errStr;\n    while (true) {\n        // retreive state number from top of stack\n        state = stack[stack.length-1];\n\n        // use default actions if available\n        if (this.defaultActions[state]) {\n            action = this.defaultActions[state];\n        } else {\n            if (symbol === null || symbol === undefined)\n                symbol = lex();\n            // read action for current state and first input\n            action = table[state] && table[state][symbol];\n        }\n\n        // handle parse error\n        _handle_error:\n        if (typeof action === 'undefined' || !action.length || !action[0]) {\n\n            if (!recovering) {\n                // Report error\n                expected = [];\n                for (p in table[state]) if (this.terminals_[p] && p > 2) {\n                    expected.push(\"'\"+this.terminals_[p]+\"'\");\n                }\n                errStr = '';\n                if (this.lexer.showPosition) {\n                    errStr = 'Parse error on line '+(yylineno+1)+\":\\n\"+this.lexer.showPosition()+\"\\nExpecting \"+expected.join(', ') + \", got '\" + this.terminals_[symbol]+ \"'\";\n                } else {\n                    errStr = 'Parse error on line '+(yylineno+1)+\": Unexpected \" +\n                                  (symbol == 1 /*EOF*/ ? \"end of input\" :\n                                              (\"'\"+(this.terminals_[symbol] || symbol)+\"'\"));\n                }\n                this.parseError(errStr,\n                    {text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected: expected});\n            }\n\n            // just recovered from another error\n            if (recovering == 3) {\n                if (symbol == EOF) {\n                    throw new Error(errStr || 'Parsing halted.');\n                }\n\n                // discard current lookahead and grab another\n                yyleng = this.lexer.yyleng;\n                yytext = this.lexer.yytext;\n                yylineno = this.lexer.yylineno;\n                yyloc = this.lexer.yylloc;\n                symbol = lex();\n            }\n\n            // try to recover from error\n            while (1) {\n                // check for error recovery rule in this state\n                if ((TERROR.toString()) in table[state]) {\n                    break;\n                }\n                if (state === 0) {\n                    throw new Error(errStr || 'Parsing halted.');\n                }\n                popStack(1);\n                state = stack[stack.length-1];\n            }\n\n            preErrorSymbol = symbol; // save the lookahead token\n            symbol = TERROR;         // insert generic error symbol as new lookahead\n            state = stack[stack.length-1];\n            action = table[state] && table[state][TERROR];\n            recovering = 3; // allow 3 real symbols to be shifted before reporting a new error\n        }\n\n        // this shouldn't happen, unless resolve defaults are off\n        if (action[0] instanceof Array && action.length > 1) {\n            throw new Error('Parse Error: multiple actions possible at state: '+state+', token: '+symbol);\n        }\n\n        switch (action[0]) {\n\n            case 1: // shift\n                //this.shiftCount++;\n\n                stack.push(symbol);\n                vstack.push(this.lexer.yytext);\n                lstack.push(this.lexer.yylloc);\n                stack.push(action[1]); // push state\n                symbol = null;\n                if (!preErrorSymbol) { // normal execution/no error\n                    yyleng = this.lexer.yyleng;\n                    yytext = this.lexer.yytext;\n                    yylineno = this.lexer.yylineno;\n                    yyloc = this.lexer.yylloc;\n                    if (recovering > 0)\n                        recovering--;\n                } else { // error just occurred, resume old lookahead f/ before error\n                    symbol = preErrorSymbol;\n                    preErrorSymbol = null;\n                }\n                break;\n\n            case 2: // reduce\n                //this.reductionCount++;\n\n                len = this.productions_[action[1]][1];\n\n                // perform semantic action\n                yyval.$ = vstack[vstack.length-len]; // default to $$ = $1\n                // default location, uses first token for firsts, last for lasts\n                yyval._$ = {\n                    first_line: lstack[lstack.length-(len||1)].first_line,\n                    last_line: lstack[lstack.length-1].last_line,\n                    first_column: lstack[lstack.length-(len||1)].first_column,\n                    last_column: lstack[lstack.length-1].last_column\n                };\n                r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);\n\n                if (typeof r !== 'undefined') {\n                    return r;\n                }\n\n                // pop off stack\n                if (len) {\n                    stack = stack.slice(0,-1*len*2);\n                    vstack = vstack.slice(0, -1*len);\n                    lstack = lstack.slice(0, -1*len);\n                }\n\n                stack.push(this.productions_[action[1]][0]);    // push nonterminal (reduce)\n                vstack.push(yyval.$);\n                lstack.push(yyval._$);\n                // goto new state = table[STATE][NONTERMINAL]\n                newState = table[stack[stack.length-2]][stack[stack.length-1]];\n                stack.push(newState);\n                break;\n\n            case 3: // accept\n                return true;\n        }\n\n    }\n\n    return true;\n}};/* Jison generated lexer */\nvar lexer = (function(){\n\nvar lexer = ({EOF:1,\nparseError:function parseError(str, hash) {\n        if (this.yy.parseError) {\n            this.yy.parseError(str, hash);\n        } else {\n            throw new Error(str);\n        }\n    },\nsetInput:function (input) {\n        this._input = input;\n        this._more = this._less = this.done = false;\n        this.yylineno = this.yyleng = 0;\n        this.yytext = this.matched = this.match = '';\n        this.conditionStack = ['INITIAL'];\n        this.yylloc = {first_line:1,first_column:0,last_line:1,last_column:0};\n        return this;\n    },\ninput:function () {\n        var ch = this._input[0];\n        this.yytext+=ch;\n        this.yyleng++;\n        this.match+=ch;\n        this.matched+=ch;\n        var lines = ch.match(/\\n/);\n        if (lines) this.yylineno++;\n        this._input = this._input.slice(1);\n        return ch;\n    },\nunput:function (ch) {\n        this._input = ch + this._input;\n        return this;\n    },\nmore:function () {\n        this._more = true;\n        return this;\n    },\npastInput:function () {\n        var past = this.matched.substr(0, this.matched.length - this.match.length);\n        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\\n/g, \"\");\n    },\nupcomingInput:function () {\n        var next = this.match;\n        if (next.length < 20) {\n            next += this._input.substr(0, 20-next.length);\n        }\n        return (next.substr(0,20)+(next.length > 20 ? '...':'')).replace(/\\n/g, \"\");\n    },\nshowPosition:function () {\n        var pre = this.pastInput();\n        var c = new Array(pre.length + 1).join(\"-\");\n        return pre + this.upcomingInput() + \"\\n\" + c+\"^\";\n    },\nnext:function () {\n        if (this.done) {\n            return this.EOF;\n        }\n        if (!this._input) this.done = true;\n\n        var token,\n            match,\n            col,\n            lines;\n        if (!this._more) {\n            this.yytext = '';\n            this.match = '';\n        }\n        var rules = this._currentRules();\n        for (var i=0;i < rules.length; i++) {\n            match = this._input.match(this.rules[rules[i]]);\n            if (match) {\n                lines = match[0].match(/\\n.*/g);\n                if (lines) this.yylineno += lines.length;\n                this.yylloc = {first_line: this.yylloc.last_line,\n                               last_line: this.yylineno+1,\n                               first_column: this.yylloc.last_column,\n                               last_column: lines ? lines[lines.length-1].length-1 : this.yylloc.last_column + match[0].length};\n                this.yytext += match[0];\n                this.match += match[0];\n                this.matches = match;\n                this.yyleng = this.yytext.length;\n                this._more = false;\n                this._input = this._input.slice(match[0].length);\n                this.matched += match[0];\n                token = this.performAction.call(this, this.yy, this, rules[i],this.conditionStack[this.conditionStack.length-1]);\n                if (token) return token;\n                else return;\n            }\n        }\n        if (this._input === \"\") {\n            return this.EOF;\n        } else {\n            this.parseError('Lexical error on line '+(this.yylineno+1)+'. Unrecognized text.\\n'+this.showPosition(),\n                    {text: \"\", token: null, line: this.yylineno});\n        }\n    },\nlex:function lex() {\n        var r = this.next();\n        if (typeof r !== 'undefined') {\n            return r;\n        } else {\n            return this.lex();\n        }\n    },\nbegin:function begin(condition) {\n        this.conditionStack.push(condition);\n    },\npopState:function popState() {\n        return this.conditionStack.pop();\n    },\n_currentRules:function _currentRules() {\n        return this.conditions[this.conditionStack[this.conditionStack.length-1]].rules;\n    },\ntopState:function () {\n        return this.conditionStack[this.conditionStack.length-2];\n    },\npushState:function begin(condition) {\n        this.begin(condition);\n    }});\nlexer.performAction = function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {\n\nvar YYSTATE=YY_START;\nswitch($avoiding_name_collisions) {\ncase 0:/* skip whitespace */\nbreak;\ncase 1:return 20\nbreak;\ncase 2:return 19\nbreak;\ncase 3:return 8\nbreak;\ncase 4:return 9\nbreak;\ncase 5:return 6\nbreak;\ncase 6:return 7\nbreak;\ncase 7:return 11\nbreak;\ncase 8:return 13\nbreak;\ncase 9:return 10\nbreak;\ncase 10:return 12\nbreak;\ncase 11:return 14\nbreak;\ncase 12:return 15\nbreak;\ncase 13:return 16\nbreak;\ncase 14:return 17\nbreak;\ncase 15:return 18\nbreak;\ncase 16:return 5\nbreak;\ncase 17:return 'INVALID'\nbreak;\n}\n};\nlexer.rules = [/^\\s+/,/^[0-9]+(\\.[0-9]+)?\\b/,/^n\\b/,/^\\|\\|/,/^&&/,/^\\?/,/^:/,/^<=/,/^>=/,/^</,/^>/,/^!=/,/^==/,/^%/,/^\\(/,/^\\)/,/^$/,/^./];\nlexer.conditions = {\"INITIAL\":{\"rules\":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17],\"inclusive\":true}};return lexer;})()\nparser.lexer = lexer;\nreturn parser;\n})();\n'''\nplural_forms_parser = Jed.PF\n# }}}\n\ndef _get_plural_forms_function(plural_forms_string):\n    return plural_forms_parser.compile(plural_forms_string or \"nplurals=2; plural=(n != 1);\")\n\n_gettext = def(text): return text\n\n_ngettext = def(text, plural, n): return text if n is 1 else plural\n\ndef gettext(text):\n    return _gettext(text)\n\ndef ngettext(text, plural, n):\n    return _ngettext(text, plural, n)\n\ndef install(translation_data):\n    t = new Translations(translation_data)\n    t.install()\n    for func in register_callback.install_callbacks:\n        try:\n            func(t)\n        except:\n            pass\n    return t\n\nhas_prop = Object.prototype.hasOwnProperty.call.bind(Object.prototype.hasOwnProperty)\n\ndef register_callback(func):\n    # Register callbacks that will be called when new translation data is\n    # installed\n    register_callback.install_callbacks.push(func)\nregister_callback.install_callbacks = v'[]'\n\nclass Translations:\n\n    def __init__(self, translation_data):\n        translation_data = translation_data or {}\n        func = _get_plural_forms_function(translation_data['plural_forms'])\n        self.translations = [[translation_data, func]]\n        self.language = translation_data['language']\n\n    def add_fallback(self, fallback):\n        fallback = fallback or {}\n        func = _get_plural_forms_function(fallback['plural_forms'])\n        self.translations.push([fallback, func])\n\n    def gettext(self, text):\n        for t in self.translations:\n            m = t[0]['entries']\n            if has_prop(m, text):\n                return m[text][0]\n        return text\n\n    def ngettext(self, text, plural, n):\n        for t in self.translations:\n            m = t[0]['entries']\n            if has_prop(m, text):\n                idx = t[1](n)\n                return m[text][idx] or (text if n is 1 else plural)\n        return text if n is 1 else plural\n\n    def install(self):\n        nonlocal _gettext, _ngettext\n        _gettext = def ():\n            return self.gettext.apply(self, arguments)\n        _ngettext = def ():\n            return self.ngettext.apply(self, arguments)\n\n","__stdlib__/math.pyj":"###########################################################\n# RapydScript Standard Library\n# Author: Alexander Tsepkov\n# Copyright 2013 Pyjeon Software LLC\n# License: Apache License    2.0\n# This library is covered under Apache license, so that\n# you can distribute it with your RapydScript applications.\n###########################################################\n\n\n# basic implementation of Python's 'math' library\n\n# NOTE: this is only meant to aid those porting lots of Python code into RapydScript,\n# if you're writing a new RapydScript application, in most cases you probably want to\n# use JavaScript's Math module directly instead\n\n\npi = Math.PI\ne = Math.E\n\n########################################\n# Number-theoretic and representation functions\n########################################\ndef ceil(x):\n    return Math.ceil(x)\ndef copysign(x, y):\n    x = Math.abs(x)\n    if y < 0:\n        return -x\n    else:\n        return x\ndef fabs(x):\n    return Math.abs(x)\ndef factorial(x):\n    if Math.abs(int(x)) is not x:\n        raise ValueError(\"factorial() only accepts integral values\")\n    factorial.cache = []\n    r = def(n):\n        if n is 0 or n is 1:\n            return 1\n        if not factorial.cache[n]:\n            factorial.cache[n] = r(n-1) * n\n        return factorial.cache[n]\n    return r(x)\ndef floor(x):\n    return Math.floor(x)\ndef fmod(x, y):\n    # javascript's % operator isn't consistent with C fmod implementation, this function is\n    while y <= x:\n        x -= y\n    return x\ndef fsum(iterable):\n    # like Python's fsum, this method is much more resilient to rounding errors than regular sum\n    partials = []   # sorted, non-overlapping partial sums\n    for x in iterable:\n        i = 0\n        for y in partials:\n            if Math.abs(x) < Math.abs(y):\n                x, y = y, x\n            hi = x + y\n            lo = y - (hi - x)\n            if lo:\n                partials[i] = lo\n                i += 1\n            x = hi\n        #partials[i:] = [x]\n        partials.splice(i, partials.length-i, x)\n    return sum(partials)\ndef isinf(x):\n    return not isFinite(x)\ndef isnan(x):\n    return isNaN(x)\ndef modf(x):\n    m = fmod(x, 1)\n    return m, x-m\ndef trunc(x):\n    return x | 0\n\n########################################\n# Power and logarithmic functions\n########################################\ndef exp(x):\n    return Math.exp(x)\ndef expm1(x):\n    # NOTE: Math.expm1() is currently only implemented in Firefox, this provides alternative implementation\n    # https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/expm1\n    #return Math.expm1(x)\n    if Math.abs(x) < 1e-5:\n        return x + 0.5*x*x\n    else:\n        return Math.exp(x) - 1\ndef log(x, base=e):\n    return Math.log(x)/Math.log(base)\ndef log1p(x):\n    # NOTE: Math.log1p() is currently only implemented in Firefox, this provides alternative implementation\n    # https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/log1p\n    # this version has been taken from http://phpjs.org/functions/log1p/\n    # admittedly it's not as accurate as MDN version, as you can see from math.log1p(1) result\n    ret = 0\n    n = 50\n    if x <= -1:\n        return Number.NEGATIVE_INFINITY\n    if x < 0 or x > 1:\n        return Math.log(1 + x)\n    for i in range(1, n):\n        if i % 2 is 0:\n            ret -= Math.pow(x, i) / i\n        else:\n            ret += Math.pow(x, i) / i\n    return ret\ndef log10(x):\n    # NOTE: Math.log10() is currently only implemented in Firefox, this provides alternative implementation\n    # https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/log10\n    # I didn't find a more accurate algorithm so I'm using the basic implementation\n    return Math.log(x)/Math.LN10\ndef pow(x, y):\n    if x < 0 and int(y) is not y:\n        raise ValueError('math domain error')\n    if isnan(y) and x is 1:\n        return 1\n    return Math.pow(x, y)\ndef sqrt(x):\n    return Math.sqrt(x)\n\n########################################\n# Trigonometric functions\n########################################\ndef acos(x):        return Math.acos(x)\ndef asin(x):        return Math.asin(x)\ndef atan(x):        return Math.atan(x)\ndef atan2(y, x):    return Math.atan2(y, x)\ndef cos(x):         return Math.cos(x)\ndef sin(x):         return Math.sin(x)\ndef hypot(x, y):    return Math.sqrt(x*x + y*y)\ndef tan(x):         return Math.tan(x)\n\n########################################\n# Angular conversion\n########################################\ndef degrees(x):     return x*180/pi\ndef radians(x):     return x*pi/180\n\n########################################\n# Hyperbolic functions\n########################################\ndef acosh(x):\n    # NOTE: will be replaced with official, when it becomes mainstream\n    # https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/acosh\n    return Math.log(x + Math.sqrt(x*x - 1))\ndef asinh(x):\n    # NOTE: will be replaced with official, when it becomes mainstream\n    # https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/asinh\n    return Math.log(x + Math.sqrt(x*x + 1))\ndef atanh(x):\n    # NOTE: will be replaced with official, when it becomes mainstream\n    # https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/atanh\n    return 0.5 * Math.log((1 + x) / (1 - x))\ndef cosh(x):\n    # NOTE: will be replaced with official, when it becomes mainstream\n    # https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/cosh\n    return (Math.exp(x) + Math.exp(-x)) / 2\ndef sinh(x):\n    # NOTE: will be replaced with official, when it becomes mainstream\n    # https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sinh\n    return (Math.exp(x) - Math.exp(-x)) / 2\ndef tanh(x):\n    # NOTE: will be replaced with official, when it becomes mainstream\n    # https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/tanh\n    return (Math.exp(x) - Math.exp(-x)) / (Math.exp(x) + Math.exp(-x))\n\n\n\n#import stdlib\n#print(math.ceil(4.2))\n#print(math.floor(4.2))\n#print(math.fabs(-6))\n#print(math.copysign(-5, 7))\n#print(math.factorial(4))\n#print(math.fmod(-1e100, 1e100))\n#\n#d = [0.9999999, 1, 2, 3]\n#print(sum(d), math.fsum(d))\n#print(math.isinf(5), math.isinf(Infinity))\n#print(math.modf(5.5))\n#print(math.trunc(2.6), math.trunc(-2.6))\n#print(math.exp(1e-5), math.expm1(1e-5))\n#print(math.log(10), math.log(10, 1000))\n#print(math.log1p(1e-15), math.log1p(1))\n#print(math.log10(1000), math.log(1000, 10))\n#print(math.pow(1, 0), math.pow(1, NaN), math.pow(0, 0), math.pow(NaN, 0), math.pow(4,3), math.pow(100, -2))\n#print(math.hypot(3,4))\n#print(math.acosh(2), math.asinh(1), math.atanh(0.5), math.cosh(1), math.cosh(-1), math.sinh(1), math.tanh(1))\n","__stdlib__/operator.pyj":"add = __add__ = def(x, y): return x + y\nsub = __sub__ = def(x, y): return x - y\nmul = __mul__ = def(x, y): return x * y\ndiv = __div__ = def(x, y): return x / y\n\nlt = __lt__ = def(x, y): return x < y\nle = __le__ = def(x, y): return x <= y\neq = __eq__ = def(x, y): return x is y\nne = __ne__ = def(x, y): return x is not y\nge = __ge__ = def(x, y): return x >= y\ngt = __gt__ = def(x, y): return x > y\n","__stdlib__/pythonize.pyj":"# vim:fileencoding=utf-8\n# License: BSD Copyright: 2016, Kovid Goyal <kovid at kovidgoyal.net>\n# globals: ρσ_str\n\ndef strings():\n    string_funcs = set((\n        'capitalize strip lstrip rstrip islower isupper isspace lower upper swapcase'\n        ' center count endswith startswith find rfind index rindex format join ljust rjust'\n        ' partition rpartition replace split rsplit splitlines zfill').split(' '))\n\n    if not arguments.length:\n        exclude = {'split', 'replace'}\n    elif arguments[0]:\n        exclude = Array.prototype.slice.call(arguments)\n    else:\n        exclude = None\n    if exclude:\n        string_funcs = string_funcs.difference(set(exclude))\n    for name in string_funcs:\n        String.prototype[name] = ρσ_str.prototype[name]\n","__stdlib__/random.pyj":"###########################################################\n# RapydScript Standard Library\n# Author: Alexander Tsepkov\n# Copyright 2013 Pyjeon Software LLC\n# License: Apache License    2.0\n# This library is covered under Apache license, so that\n# you can distribute it with your RapydScript applications.\n###########################################################\n\n\n# basic implementation of Python's 'random' library\n\n# JavaScript's Math.random() does not allow seeding its random generator, to bypass that, this module implements its own\n# version that can be seeded. I decided on RC4 algorithm for this.\n\n# please don't mess with this from the outside\n\nρσ_seed_state = {\n    'key': [],\n    'key_i': 0,\n    'key_j': 0\n}\n\nρσ_get_random_byte = def():\n    ρσ_seed_state.key_i = (ρσ_seed_state.key_i + 1) % 256\n    ρσ_seed_state.key_j = (ρσ_seed_state.key_j + ρσ_seed_state.key[ρσ_seed_state.key_i]) % 256\n    ρσ_seed_state.key[ρσ_seed_state.key_i], ρσ_seed_state.key[ρσ_seed_state.key_j] = \\\n            ρσ_seed_state.key[ρσ_seed_state.key_j], ρσ_seed_state.key[ρσ_seed_state.key_i]\n    return ρσ_seed_state.key[(ρσ_seed_state.key[ρσ_seed_state.key_i] + \\\n            ρσ_seed_state.key[ρσ_seed_state.key_j]) % 256]\n\ndef seed(x=Date().getTime()):\n    if jstype(x) is 'number':\n        x = x.toString()\n    elif jstype(x) is not 'string':\n        raise TypeError(\"unhashable type: '\" + jstype(x) + \"'\")\n    for i in range(256):\n        ρσ_seed_state.key[i] = i\n    j = 0\n    for i in range(256):\n        j = (j + ρσ_seed_state.key[i] + x.charCodeAt(i % x.length)) % 256\n        ρσ_seed_state.key[i], ρσ_seed_state.key[j] = ρσ_seed_state.key[j], ρσ_seed_state.key[i]\nseed()\n\ndef random():\n    n = 0\n    m = 1\n    for i in range(8):\n        n += ρσ_get_random_byte() * m\n        m *= 256\n    return n / 18446744073709551616\n\n# unlike the python version, this DOES build a range object, feel free to reimplement\ndef randrange():\n    return choice(range.apply(this, arguments))\n\ndef randint(a, b):\n    return int(random()*(b-a+1) + a)\n\ndef uniform(a, b):\n    return random()*(b-a) + a\n\ndef choice(seq):\n    if seq.length > 0:\n        return seq[Math.floor(random()*seq.length)]\n    else:\n        raise IndexError()\n\n# uses Fisher-Yates algorithm to shuffle an array\ndef shuffle(x, random_f=random):\n    for i in range(x.length):\n        j = Math.floor(random_f() * (i+1))\n        x[i], x[j] = x[j], x[i]\n    return x\n\n# similar to shuffle, but only shuffles a subset and creates a copy\ndef sample(population, k):\n    x = population.slice()\n    for i in range(population.length-1, population.length-k-1, -1):\n        j = Math.floor(random() * (i+1))\n        x[i], x[j] = x[j], x[i]\n    return x.slice(population.length-k)\n\n\n#import stdlib\n#a = range(50)\n#random.seed(5)\n#print(random.choice(a))\n#print(random.shuffle(a))\n#print(random.randrange(10))\n#print(random.randint(1,5))\n#print(random.uniform(1,5))\n#print(random.sample(range(20),5))\n","__stdlib__/re.pyj":"# vim:fileencoding=utf-8\n# License: BSD\n# Copyright: 2015, Kovid Goyal <kovid at kovidgoyal.net>\n# Copyright: 2013, Alexander Tsepkov\n\n# globals: ρσ_iterator_symbol, ρσ_list_decorate\n\n# basic implementation of Python's 're' library\n\nfrom __python__ import bound_methods\n\n# Alias DB from http://www.unicode.org/Public/8.0.0/ucd/NameAliases.txt {{{\n_ALIAS_MAP = {\"null\":0,\"nul\":0,\"start of heading\":1,\"soh\":1,\"start of text\":2,\"stx\":2,\"end of text\":3,\"etx\":3,\"end of transmission\":4,\"eot\":4,\"enquiry\":5,\"enq\":5,\"acknowledge\":6,\"ack\":6,\"alert\":7,\"bel\":7,\"backspace\":8,\"bs\":8,\"character tabulation\":9,\"horizontal tabulation\":9,\"ht\":9,\"tab\":9,\"line feed\":10,\"new line\":10,\"end of line\":10,\"lf\":10,\"nl\":10,\"eol\":10,\"line tabulation\":11,\"vertical tabulation\":11,\"vt\":11,\"form feed\":12,\"ff\":12,\"carriage return\":13,\"cr\":13,\"shift out\":14,\"locking-shift one\":14,\"so\":14,\"shift in\":15,\"locking-shift zero\":15,\"si\":15,\"data link escape\":16,\"dle\":16,\"device control one\":17,\"dc1\":17,\"device control two\":18,\"dc2\":18,\"device control three\":19,\"dc3\":19,\"device control four\":20,\"dc4\":20,\"negative acknowledge\":21,\"nak\":21,\"synchronous idle\":22,\"syn\":22,\"end of transmission block\":23,\"etb\":23,\"cancel\":24,\"can\":24,\"end of medium\":25,\"eom\":25,\"substitute\":26,\"sub\":26,\"escape\":27,\"esc\":27,\"information separator four\":28,\"file separator\":28,\"fs\":28,\"information separator three\":29,\"group separator\":29,\"gs\":29,\"information separator two\":30,\"record separator\":30,\"rs\":30,\"information separator one\":31,\"unit separator\":31,\"us\":31,\"sp\":32,\"delete\":127,\"del\":127,\"padding character\":128,\"pad\":128,\"high octet preset\":129,\"hop\":129,\"break permitted here\":130,\"bph\":130,\"no break here\":131,\"nbh\":131,\"index\":132,\"ind\":132,\"next line\":133,\"nel\":133,\"start of selected area\":134,\"ssa\":134,\"end of selected area\":135,\"esa\":135,\"character tabulation set\":136,\"horizontal tabulation set\":136,\"hts\":136,\"character tabulation with justification\":137,\"horizontal tabulation with justification\":137,\"htj\":137,\"line tabulation set\":138,\"vertical tabulation set\":138,\"vts\":138,\"partial line forward\":139,\"partial line down\":139,\"pld\":139,\"partial line backward\":140,\"partial line up\":140,\"plu\":140,\"reverse line feed\":141,\"reverse index\":141,\"ri\":141,\"single shift two\":142,\"single-shift-2\":142,\"ss2\":142,\"single shift three\":143,\"single-shift-3\":143,\"ss3\":143,\"device control string\":144,\"dcs\":144,\"private use one\":145,\"private use-1\":145,\"pu1\":145,\"private use two\":146,\"private use-2\":146,\"pu2\":146,\"set transmit state\":147,\"sts\":147,\"cancel character\":148,\"cch\":148,\"message waiting\":149,\"mw\":149,\"start of guarded area\":150,\"start of protected area\":150,\"spa\":150,\"end of guarded area\":151,\"end of protected area\":151,\"epa\":151,\"start of string\":152,\"sos\":152,\"single graphic character introducer\":153,\"sgc\":153,\"single character introducer\":154,\"sci\":154,\"control sequence introducer\":155,\"csi\":155,\"string terminator\":156,\"st\":156,\"operating system command\":157,\"osc\":157,\"privacy message\":158,\"pm\":158,\"application program command\":159,\"apc\":159,\"nbsp\":160,\"shy\":173,\"latin capital letter gha\":418,\"latin small letter gha\":419,\"cgj\":847,\"alm\":1564,\"syriac sublinear colon skewed left\":1801,\"kannada letter llla\":3294,\"lao letter fo fon\":3741,\"lao letter fo fay\":3743,\"lao letter ro\":3747,\"lao letter lo\":3749,\"tibetan mark bka- shog gi mgo rgyan\":4048,\"fvs1\":6155,\"fvs2\":6156,\"fvs3\":6157,\"mvs\":6158,\"zwsp\":8203,\"zwnj\":8204,\"zwj\":8205,\"lrm\":8206,\"rlm\":8207,\"lre\":8234,\"rle\":8235,\"pdf\":8236,\"lro\":8237,\"rlo\":8238,\"nnbsp\":8239,\"mmsp\":8287,\"wj\":8288,\"lri\":8294,\"rli\":8295,\"fsi\":8296,\"pdi\":8297,\"weierstrass elliptic function\":8472,\"micr on us symbol\":9288,\"micr dash symbol\":9289,\"leftwards triangle-headed arrow with double vertical stroke\":11130,\"rightwards triangle-headed arrow with double vertical stroke\":11132,\"yi syllable iteration mark\":40981,\"presentation form for vertical right white lenticular bracket\":65048,\"vs1\":65024,\"vs2\":65025,\"vs3\":65026,\"vs4\":65027,\"vs5\":65028,\"vs6\":65029,\"vs7\":65030,\"vs8\":65031,\"vs9\":65032,\"vs10\":65033,\"vs11\":65034,\"vs12\":65035,\"vs13\":65036,\"vs14\":65037,\"vs15\":65038,\"vs16\":65039,\"byte order mark\":65279,\"bom\":65279,\"zwnbsp\":65279,\"cuneiform sign nu11 tenu\":74452,\"cuneiform sign nu11 over nu11 bur over bur\":74453,\"byzantine musical symbol fthora skliron chroma vasis\":118981,\"vs17\":917760,\"vs18\":917761,\"vs19\":917762,\"vs20\":917763,\"vs21\":917764,\"vs22\":917765,\"vs23\":917766,\"vs24\":917767,\"vs25\":917768,\"vs26\":917769,\"vs27\":917770,\"vs28\":917771,\"vs29\":917772,\"vs30\":917773,\"vs31\":917774,\"vs32\":917775,\"vs33\":917776,\"vs34\":917777,\"vs35\":917778,\"vs36\":917779,\"vs37\":917780,\"vs38\":917781,\"vs39\":917782,\"vs40\":917783,\"vs41\":917784,\"vs42\":917785,\"vs43\":917786,\"vs44\":917787,\"vs45\":917788,\"vs46\":917789,\"vs47\":917790,\"vs48\":917791,\"vs49\":917792,\"vs50\":917793,\"vs51\":917794,\"vs52\":917795,\"vs53\":917796,\"vs54\":917797,\"vs55\":917798,\"vs56\":917799,\"vs57\":917800,\"vs58\":917801,\"vs59\":917802,\"vs60\":917803,\"vs61\":917804,\"vs62\":917805,\"vs63\":917806,\"vs64\":917807,\"vs65\":917808,\"vs66\":917809,\"vs67\":917810,\"vs68\":917811,\"vs69\":917812,\"vs70\":917813,\"vs71\":917814,\"vs72\":917815,\"vs73\":917816,\"vs74\":917817,\"vs75\":917818,\"vs76\":917819,\"vs77\":917820,\"vs78\":917821,\"vs79\":917822,\"vs80\":917823,\"vs81\":917824,\"vs82\":917825,\"vs83\":917826,\"vs84\":917827,\"vs85\":917828,\"vs86\":917829,\"vs87\":917830,\"vs88\":917831,\"vs89\":917832,\"vs90\":917833,\"vs91\":917834,\"vs92\":917835,\"vs93\":917836,\"vs94\":917837,\"vs95\":917838,\"vs96\":917839,\"vs97\":917840,\"vs98\":917841,\"vs99\":917842,\"vs100\":917843,\"vs101\":917844,\"vs102\":917845,\"vs103\":917846,\"vs104\":917847,\"vs105\":917848,\"vs106\":917849,\"vs107\":917850,\"vs108\":917851,\"vs109\":917852,\"vs110\":917853,\"vs111\":917854,\"vs112\":917855,\"vs113\":917856,\"vs114\":917857,\"vs115\":917858,\"vs116\":917859,\"vs117\":917860,\"vs118\":917861,\"vs119\":917862,\"vs120\":917863,\"vs121\":917864,\"vs122\":917865,\"vs123\":917866,\"vs124\":917867,\"vs125\":917868,\"vs126\":917869,\"vs127\":917870,\"vs128\":917871,\"vs129\":917872,\"vs130\":917873,\"vs131\":917874,\"vs132\":917875,\"vs133\":917876,\"vs134\":917877,\"vs135\":917878,\"vs136\":917879,\"vs137\":917880,\"vs138\":917881,\"vs139\":917882,\"vs140\":917883,\"vs141\":917884,\"vs142\":917885,\"vs143\":917886,\"vs144\":917887,\"vs145\":917888,\"vs146\":917889,\"vs147\":917890,\"vs148\":917891,\"vs149\":917892,\"vs150\":917893,\"vs151\":917894,\"vs152\":917895,\"vs153\":917896,\"vs154\":917897,\"vs155\":917898,\"vs156\":917899,\"vs157\":917900,\"vs158\":917901,\"vs159\":917902,\"vs160\":917903,\"vs161\":917904,\"vs162\":917905,\"vs163\":917906,\"vs164\":917907,\"vs165\":917908,\"vs166\":917909,\"vs167\":917910,\"vs168\":917911,\"vs169\":917912,\"vs170\":917913,\"vs171\":917914,\"vs172\":917915,\"vs173\":917916,\"vs174\":917917,\"vs175\":917918,\"vs176\":917919,\"vs177\":917920,\"vs178\":917921,\"vs179\":917922,\"vs180\":917923,\"vs181\":917924,\"vs182\":917925,\"vs183\":917926,\"vs184\":917927,\"vs185\":917928,\"vs186\":917929,\"vs187\":917930,\"vs188\":917931,\"vs189\":917932,\"vs190\":917933,\"vs191\":917934,\"vs192\":917935,\"vs193\":917936,\"vs194\":917937,\"vs195\":917938,\"vs196\":917939,\"vs197\":917940,\"vs198\":917941,\"vs199\":917942,\"vs200\":917943,\"vs201\":917944,\"vs202\":917945,\"vs203\":917946,\"vs204\":917947,\"vs205\":917948,\"vs206\":917949,\"vs207\":917950,\"vs208\":917951,\"vs209\":917952,\"vs210\":917953,\"vs211\":917954,\"vs212\":917955,\"vs213\":917956,\"vs214\":917957,\"vs215\":917958,\"vs216\":917959,\"vs217\":917960,\"vs218\":917961,\"vs219\":917962,\"vs220\":917963,\"vs221\":917964,\"vs222\":917965,\"vs223\":917966,\"vs224\":917967,\"vs225\":917968,\"vs226\":917969,\"vs227\":917970,\"vs228\":917971,\"vs229\":917972,\"vs230\":917973,\"vs231\":917974,\"vs232\":917975,\"vs233\":917976,\"vs234\":917977,\"vs235\":917978,\"vs236\":917979,\"vs237\":917980,\"vs238\":917981,\"vs239\":917982,\"vs240\":917983,\"vs241\":917984,\"vs242\":917985,\"vs243\":917986,\"vs244\":917987,\"vs245\":917988,\"vs246\":917989,\"vs247\":917990,\"vs248\":917991,\"vs249\":917992,\"vs250\":917993,\"vs251\":917994,\"vs252\":917995,\"vs253\":917996,\"vs254\":917997,\"vs255\":917998,\"vs256\":917999}\n# }}}\n\n_ASCII_CONTROL_CHARS = {'a':7, 'b':8, 'f': 12, 'n': 10, 'r': 13, 't': 9, 'v': 11}\n_HEX_PAT = /^[a-fA-F0-9]/\n_NUM_PAT =  /^[0-9]/\n_GROUP_PAT = /<([^>]+)>/\n_NAME_PAT = /^[a-zA-Z ]/\n\nI = IGNORECASE = 2\nL = LOCALE = 4\nM = MULTILINE = 8\nD = DOTALL = 16\nU = UNICODE = 32\nX = VERBOSE = 64\nDEBUG = 128\nA = ASCII = 256\n\nsupports_unicode = RegExp.prototype.unicode is not undefined\n\n_RE_ESCAPE = /[-\\/\\\\^$*+?.()|[\\]{}]/g\n\n_re_cache_map = {}\n_re_cache_items = v'[]'\n\nerror = SyntaxError  # This is the error JS throws for invalid regexps\nhas_prop = Object.prototype.hasOwnProperty.call.bind(Object.prototype.hasOwnProperty)\n\ndef _expand(groups, repl, group_name_map):\n    i = 0\n\n    def next():\n        nonlocal i\n        return v'repl[i++]'\n\n    def peek():\n        return repl[i]\n\n    def read_digits(count, pat, base, maxval, prefix):\n        ans = prefix or ''\n        greedy = count is Number.MAX_VALUE\n        while count > 0:\n            count -= 1\n            if not pat.test(peek()):\n                if greedy:\n                    break\n                return ans\n            ans += next()\n        nval = parseInt(ans, base)\n        if nval > maxval:\n            return ans\n        return nval\n\n    def read_escape_sequence():\n        nonlocal i\n        q = next()\n        if not q or q is '\\\\':\n            return '\\\\'\n        if '\"\\''.indexOf(q) is not -1:\n            return q\n        if _ASCII_CONTROL_CHARS[q]:\n            return String.fromCharCode(_ASCII_CONTROL_CHARS[q])\n        if '0' <= q <= '9':\n            ans = read_digits(Number.MAX_VALUE, _NUM_PAT, 10, Number.MAX_VALUE, q)\n            if jstype(ans) is 'number':\n                return groups[ans] or ''\n            return '\\\\' + ans\n        if q is 'g':\n            m = _GROUP_PAT.exec(repl[i:])\n            if m is not None:\n                i += m[0].length\n                gn = m[1]\n                if isNaN(parseInt(gn, 10)):\n                    if not has_prop(group_name_map, gn):\n                        return ''\n                    gn = group_name_map[gn][-1]\n                return groups[gn] or ''\n        if q is 'x':\n            code = read_digits(2, _HEX_PAT, 16, 0x10FFFF)\n            if jstype(code) is 'number':\n                return String.fromCharCode(code)\n            return '\\\\x' + code\n        if q is 'u':\n            code = read_digits(4, _HEX_PAT, 16, 0x10FFFF)\n            if jstype(code) is 'number':\n                return String.fromCharCode(code)\n            return '\\\\u' + code\n        if q is 'U':\n            code = read_digits(8, _HEX_PAT, 16, 0x10FFFF)\n            if jstype(code) is 'number':\n                if code <= 0xFFFF:\n                    return String.fromCharCode(code)\n                code -= 0x10000\n                return String.fromCharCode(0xD800+(code>>10), 0xDC00+(code&0x3FF))\n            return '\\\\U' + code\n        if q is 'N' and peek() is '{':\n            next()\n            name = ''\n            while _NAME_PAT.test(peek()):\n                name += next()\n            if peek() is not '}':\n                return '\\\\N{' + name\n            next()\n            key = (name or '').toLowerCase()\n            if not name or not has_prop(_ALIAS_MAP, key):\n                return '\\\\N{' + name + '}'\n            code = _ALIAS_MAP[key]\n            if code <= 0xFFFF:\n                return String.fromCharCode(code)\n            code -= 0x10000\n            return String.fromCharCode(0xD800+(code>>10), 0xDC00+(code&0x3FF))\n\n        return '\\\\' + q\n\n    ans = ch = ''\n    while (ch = next()):\n        if ch is '\\\\':\n            ans += read_escape_sequence()\n        else:\n            ans += ch\n    return ans\n\ndef transform_regex(source, flags):\n    pos = 0\n    previous_backslash = in_class = False\n    ans = ''\n    group_map = {}\n    flags = flags or 0\n    group_count = 0\n\n    while pos < source.length:\n        ch = v'source[pos++]'\n        if previous_backslash:\n            ans += '\\\\' + ch\n            previous_backslash = False\n            continue\n\n        if in_class:\n            if ch is ']':\n                in_class = False\n            ans += ch\n            continue\n\n        if ch is '\\\\':\n            previous_backslash = True\n            continue\n\n        if ch is '[':\n            in_class = True\n            if source[pos] is ']':  # in python the empty set is not allowed, instead []] is the same as [\\]]\n                pos += 1\n                ch = r'[\\]'\n        elif ch is '(':\n            if source[pos] is '?':\n                extension = source[pos + 1]\n                if extension is '#':\n                    close = source.indexOf(')', pos + 1)\n                    if close is -1:\n                        raise ValueError('Expecting a closing )')\n                    pos = close + 1\n                    continue\n                if 'aiLmsux'.indexOf(extension) is not -1:\n                    flag_map = {'a':ASCII, 'i':IGNORECASE, 'L':LOCALE, 'm':MULTILINE, 's':DOTALL, 'u':UNICODE, 'x':VERBOSE}\n                    close = source.indexOf(')', pos + 1)\n                    if close is -1:\n                        raise SyntaxError('Expecting a closing )')\n                    flgs = source[pos+1:close]\n                    for v'var i = 0; i < flgs.length; i++':\n                        q = flgs[i]  # noqa:undef\n                        if not has_prop(flag_map, q):\n                            raise SyntaxError('Invalid flag: ' + q)\n                        flags |= flag_map[q]\n                    pos = close + 1\n                    continue\n                if extension is '<':\n                    raise SyntaxError('Look behind assertions are not supported in JavaScript')\n                if extension is '(':\n                    raise SyntaxError('Group existence assertions are not supported in JavaScript')\n                if extension is 'P':\n                    pos += 2\n                    q = source[pos]\n                    if q is '<':\n                        close = source.indexOf('>', pos)\n                        if close is -1:\n                            raise SyntaxError('Named group not closed, expecting >')\n                        name = source[pos+1:close]\n                        if not has_prop(group_map, name):\n                            group_map[name] = v'[]'\n                        group_map[name].push(v'++group_count')\n                        pos = close + 1\n                    elif q is '=':\n                        close = source.indexOf(')', pos)\n                        if close is -1:\n                            raise SyntaxError('Named group back-reference not closed, expecting a )')\n                        name = source[pos+1:close]\n                        if not isNaN(parseInt(name, 10)):\n                            ans += '\\\\' + name\n                        else:\n                            if not has_prop(group_map, name):\n                                raise SyntaxError('Invalid back-reference. The named group: ' + name + ' has not yet been defined.')\n                            ans += '\\\\' + group_map[name][-1]\n                        pos = close + 1\n                        continue\n                    else:\n                        raise SyntaxError('Expecting < or = after (?P')\n            else:\n                group_count += 1\n        elif ch is '.' and (flags & DOTALL):\n            ans += r'[\\s\\S]'  # JavaScript has no DOTALL\n            continue\n\n        ans += ch\n\n    return ans, flags, group_map\n\nclass MatchObject:\n\n    def __init__(self, regex, match, pos, endpos):\n        self.re = regex\n        self.string = match.input\n        self._start_pos = match.index\n        self._groups = match\n        self.pos, self.endpos = pos, endpos\n\n    def _compute_extents(self):\n        # compute start/end for each group\n        match = self._groups\n        self._start = v'Array(match.length)'\n        self._end = v'Array(match.length)'\n        self._start[0] = self._start_pos\n        self._end[0] = self._start_pos + match[0].length\n        offset = self._start_pos\n        extent = match[0]\n        loc = 0\n        for v'var i = 1; i < match.length; i++':\n            g = match[i]\n            loc = extent.indexOf(g, loc)\n            if loc is -1:\n                self._start[i] = self._start[i-1]\n                self._end[i] = self._end[i-1]\n            else:\n                self._start[i] = offset + loc\n                loc += g.length\n                self._end[i] = offset + loc # noqa:undef\n\n    def groups(self, defval=None):\n        ans = v'[]'\n        for v'var i = 1; i < self._groups.length; i++':\n            val = self._groups[i]  # noqa:undef\n            if val is undefined:\n                val = defval\n            ans.push(val)\n        return ans\n\n    def _group_number(self, g):\n        if jstype(g) is 'number':\n            return g\n        if has_prop(self.re.group_name_map, g):\n            return self.re.group_name_map[g][-1]\n        return g\n\n    def _group_val(self, q, defval):\n        val = undefined\n        if jstype(q) is 'number' and -1 < q < self._groups.length:\n            val = self._groups[q]\n        else:\n            if has_prop(self.re.group_name_map, q):\n                val = self._groups[self.re.group_name_map[q][-1]]\n        if val is undefined:\n            val = defval\n        return val\n\n    def group(self):\n        if arguments.length is 0:\n            return self._groups[0]\n        ans = v'[]'\n        for v'var i = 0; i < arguments.length; i++':\n            q = arguments[i]  # noqa:undef\n            ans.push(self._group_val(q, None))\n        return ans[0] if ans.length is 1 else ans\n\n    def start(self, g):\n        if self._start is undefined:\n            self._compute_extents()\n        val = self._start[self._group_number(g or 0)]\n        if val is undefined:\n            val = -1\n        return val\n\n    def end(self, g):\n        if self._end is undefined:\n            self._compute_extents()\n        val = self._end[self._group_number(g or 0)]\n        if val is undefined:\n            val = -1\n        return val\n\n    def span(self, g):\n        return [self.start(g), self.end(g)]\n\n    def expand(self, repl):\n        return _expand(repl, this._groups, this.re.group_name_map)\n\n    def groupdict(self, defval=None):\n        gnm = self.re.group_name_map\n        names = Object.keys(gnm)\n        ans = {}\n        for v\"var i = 0; i < names.length; i++\":\n            name = names[i]  # noqa:undef\n            if has_prop(gnm, name):\n                val = self._groups[gnm[name][-1]]\n                if val is undefined:\n                    val = defval\n                ans[name] = val\n        return ans\n\n    def captures(self, group_name):\n        ans = []\n        if not has_prop(self.re.group_name_map, group_name):\n            return ans\n        groups = self.re.group_name_map[group_name]\n        for v'var i = 0; i < groups.length; i++':\n            val = self._groups[groups[i]]  # noqa:undef\n            if val is not undefined:\n                ans.push(val)\n        return ans\n\n    def capturesdict(self):\n        gnm = self.re.group_name_map\n        names = Object.keys(gnm)\n        ans = {}\n        for v'var i = 0; i < names.length; i++':\n            name = names[i]  # noqa:undef\n            ans[name] = self.captures(name)\n        return ans\n\nclass RegexObject:\n\n    def __init__(self, pattern, flags):\n        self.pattern = pattern.source if isinstance(pattern, RegExp) else pattern\n        self.js_pattern, self.flags, self.group_name_map = transform_regex(self.pattern, flags)\n\n        modifiers = ''\n        if self.flags & IGNORECASE: modifiers += 'i'\n        if self.flags & MULTILINE: modifiers += 'm'\n        if not (self.flags & ASCII) and supports_unicode:\n            modifiers += 'u'\n        self._modifiers = modifiers + 'g'\n        self._pattern = RegExp(self.js_pattern, self._modifiers)\n\n    def _do_search(self, pat, string, pos, endpos):\n        pat.lastIndex = 0\n        if endpos is not None:\n            string = string[:endpos]\n        while True:\n            n = pat.exec(string)\n            if n is None:\n                return None\n            if n.index >= pos:\n                return MatchObject(self, n, pos, endpos)\n\n    def search(self, string, pos=0, endpos=None):\n        return self._do_search(self._pattern, string, pos, endpos)\n\n    def match(self, string, pos=0, endpos=None):\n        return self._do_search(RegExp('^' + self.js_pattern, self._modifiers), string, pos, endpos)\n\n    def split(self, string, maxsplit=0):\n        self._pattern.lastIndex = 0\n        return string.split(self._pattern, maxsplit or undefined)\n\n    def findall(self, string):\n        self._pattern.lastIndex = 0\n        return ρσ_list_decorate(string.match(self._pattern) or v'[]')\n\n    def finditer(self, string):\n        # We have to copy pat since lastIndex is mutable\n        pat = RegExp(this._pattern.source, this._modifiers)  # noqa: unused-local\n        ans = v\"{'_string':string, '_r':pat, '_self':self}\"\n        ans[ρσ_iterator_symbol] = def():\n            return this\n        ans['next'] = def():\n            m = this._r.exec(this._string)\n            if m is None:\n                return v\"{'done':true}\"\n            return v\"{'done':false, 'value':new MatchObject(this._self, m, 0, null)}\"\n        return ans\n\n    def subn(self, repl, string, count=0):\n        expand = _expand\n        if jstype(repl) is 'function':\n            expand = def(m, repl, gnm): return '' + repl(MatchObject(self, m, 0, None))\n        this._pattern.lastIndex = 0\n        num = 0\n        matches = v'[]'\n\n        while count < 1 or num < count:\n            m = this._pattern.exec(string)\n            if m is None:\n                break\n            matches.push(m)\n            num += 1\n\n        for v'var i = matches.length - 1; i > -1; i--':\n            m = matches[i]  # noqa:undef\n            start = m.index\n            end = start + m[0].length\n            string = string[:start] + expand(m, repl, self.group_name_map) + string[end:]\n        return string, matches.length\n\n    def sub(self, repl, string, count=0):\n        return self.subn(repl, string, count)[0]\n\ndef _get_from_cache(pattern, flags):\n    if isinstance(pattern, RegExp):\n        pattern = pattern.source\n    key = JSON.stringify(v'[pattern, flags]')\n    if has_prop(_re_cache_map, key):\n        return _re_cache_map[key]\n    if _re_cache_items.length >= 100:\n        v'delete _re_cache_map[_re_cache_items.shift()]'\n    ans = RegexObject(pattern, flags)\n    _re_cache_map[key] = ans\n    _re_cache_items.push(key)\n    return ans\n\ndef compile(pattern, flags=0):\n    return _get_from_cache(pattern, flags)\n\ndef search(pattern, string, flags=0):\n    return _get_from_cache(pattern, flags).search(string)\n\ndef match(pattern, string, flags=0):\n    return _get_from_cache(pattern, flags).match(string)\n\ndef split(pattern, string, maxsplit=0, flags=0):\n    return _get_from_cache(pattern, flags).split(string)\n\ndef findall(pattern, string, flags=0):\n    return _get_from_cache(pattern, flags).findall(string)\n\ndef finditer(pattern, string, flags=0):\n    return _get_from_cache(pattern, flags).finditer(string)\n\ndef sub(pattern, repl, string, count=0, flags=0):\n    return _get_from_cache(pattern, flags).sub(repl, string, count)\n\ndef subn(pattern, repl, string, count=0, flags=0):\n    return _get_from_cache(pattern, flags).subn(repl, string, count)\n\ndef escape(string):\n    return string.replace(_RE_ESCAPE, '\\\\$&')\n\ndef purge():\n    nonlocal _re_cache_map, _re_cache_items\n    _re_cache_map = {}\n    _re_cache_items = v'[]'\n","__stdlib__/traceback.pyj":"# vim:fileencoding=utf-8\n# License: BSD Copyright: 2016, Kovid Goyal <kovid at kovidgoyal.net>\n# globals: ρσ_str, ρσ_last_exception\n\ndef _get_internal_traceback(err):\n    if isinstance(err, Exception) and err.stack:\n        lines = ρσ_str.splitlines(err.stack)\n        for i, line in enumerate(lines):\n            line = ρσ_str.strip(line)\n            # These two conditions work on desktop Chrome and Firefox to identify the correct\n            # line in the traceback.\n            if line.startsWith('at new ' + err.name) or line.startsWith(err.name + '@'):\n                return err.__repr__() + '\\n' +  lines.slice(i+1).join('\\n')\n    return err and err.stack\n\ndef format_exception(exc, limit):\n    if not isinstance(exc, Error):\n        if exc and exc.toString:\n            return [exc.toString()]\n        return []\n    tb = _get_internal_traceback(exc)\n    if tb:\n        lines = ρσ_str.splitlines(tb)\n        e = lines[0]\n        lines = [l for l in lines[1:]]\n        if limit:\n            lines = lines[:limit+1] if limit > 0 else lines[limit:]\n        lines.reverse()\n        lines.push(e)\n        lines.insert(0, 'Traceback (most recent call last):')\n        return [l+'\\n' for l in lines]\n    return [exc.toString()]\n\ndef format_exc(limit):\n    return format_exception(ρσ_last_exception, limit).join('')\n\ndef print_exc(limit):\n    print(format_exc(limit))\n\ndef format_stack(limit):\n    stack = Error().stack\n    if not stack:\n        return []\n    lines = str.splitlines(stack)[2:]\n    lines.reverse()\n    if limit:\n        lines = lines[:limit+1] if limit > 0 else lines[limit:]\n    return [l + '\\n' for l in lines]\n\ndef print_stack(limit):\n    print(format_stack(limit).join(''))\n","__stdlib__/uuid.pyj":"# vim:fileencoding=utf-8\n# License: BSD Copyright: 2017, Kovid Goyal <kovid at kovidgoyal.net>\n# globals: crypto\nfrom __python__ import hash_literals\n\nfrom encodings import hexlify, urlsafe_b64decode, urlsafe_b64encode\n\nRFC_4122 = 1\n\nif jstype(crypto) is 'object' and crypto.getRandomValues:\n    random_bytes = def (num):\n        ans = Uint8Array(num or 16)\n        crypto.getRandomValues(ans)\n        return ans\nelse:\n    random_bytes = def (num):\n        ans = Uint8Array(num or 16)\n        for i in range(ans.length):\n            ans[i] = Math.floor(Math.random() * 256)\n        return ans\n\n\ndef uuid4_bytes():\n    data = random_bytes()\n    data[6] = 0b01000000 | (data[6] & 0b1111)\n    data[8] = (((data[8] >> 4) & 0b11 | 0b1000) << 4) | (data[8] & 0b1111)\n    return data\n\n\ndef as_str():\n    h = this.hex\n    return h[:8] + '-' + h[8:12] + '-' + h[12:16] + '-' + h[16:20] + '-' + h[20:]\n\n\ndef uuid4():\n    b = uuid4_bytes()\n    return {\n        'hex': hexlify(b),\n        'bytes': b,\n        'variant': RFC_4122,\n        'version': 4,\n        '__str__': as_str,\n        'toString': as_str,\n    }\n\n\ndef num_to_string(numbers, alphabet, pad_to_length):\n    ans = v'[]'\n    alphabet_len = alphabet.length\n    numbers = Array.prototype.slice.call(numbers)\n    for v'var i = 0; i < numbers.length - 1; i++':\n        x = divmod(numbers[i], alphabet_len)\n        numbers[i] = x[0]\n        numbers[i+1] += x[1]\n    for v'var i = 0; i < numbers.length; i++':\n        number = numbers[i]\n        while number:\n            x = divmod(number, alphabet_len)\n            number = x[0]\n            ans.push(alphabet[x[1]])\n    if pad_to_length and pad_to_length > ans.length:\n        ans.push(alphabet[0].repeat(pad_to_length - ans.length))\n    return ans.join('')\n\n\ndef short_uuid():\n    # A totally random uuid encoded using only URL and filename safe characters\n    return urlsafe_b64encode(random_bytes(), '')\n\n\ndef short_uuid4():\n    # A uuid4 encoded using only URL and filename safe characters\n    return urlsafe_b64encode(uuid4_bytes(), '')\n\n\ndef decode_short_uuid(val):\n    return urlsafe_b64decode(val + '==')\n"};

// End embedded modules }}}

/* vim:fileencoding=utf-8
 * 
 * Copyright (C) 2016 Kovid Goyal <kovid at kovidgoyal.net>
 *
 * Distributed under terms of the BSD license
 */

var namespace = {}, jsSHA = {};

var write_cache = {};

var builtin_modules = {
    'crypto' : {
        'createHash': function create_hash() {
            var ans = new jsSHA.jsSHA('SHA-1', 'TEXT');
            ans.digest = function hex_digest() { return ans.getHash('HEX'); };
            return ans;
        },
    },

    'vm': {
        'createContext': function create_context(ctx) {
            var iframe = document.createElement('iframe');
            iframe.style.display = 'none';
            document.body.appendChild(iframe);
            var win = iframe.contentWindow;
            if(!ctx) ctx = {};
            if (!ctx.sha1sum) ctx.sha1sum = sha1sum;
            if (!ctx.require) ctx.require = require;
            Object.keys(ctx).forEach(function(k) { win[k] = ctx[k]; });
            return win;
        },

        'runInContext': function run_in_context(code, ctx) {
            return ctx.eval(code);
        },

        'runInThisContext': function run_in_this(code){ return eval(code) },
    },
    'path': {
        'join': function path_join() { return Array.prototype.slice.call(arguments).join('/'); },
        'dirname': function path_dirname(path) {
            return path.split('/').slice(0, -1).join('/');
        },
    },
    'inspect': function inspect(x) { return x.toString(); },

    'fs': {
        'readFileSync': function readfile(name) {
            var data = namespace.file_data[name];
            if (data) return data;
            data = write_cache[name];
            if (data) return data;
            var err = Error();
            err.code = 'ENOENT';
            throw err;
        },

        'writeFileSync': function writefile(name, data) {
            write_cache[name] = data;
        },

    },
};

function require(name) {
    return builtin_modules[name] || {};
}

// Embedded sha1 implementation {{{
(function() {
/*
 A JavaScript implementation of the SHA family of hashes, as
 defined in FIPS PUB 180-2 as well as the corresponding HMAC implementation
 as defined in FIPS PUB 198a

 Copyright Brian Turek 2008-2015
 Distributed under the BSD License
 See http://caligatio.github.io/jsSHA/ for more information

 Several functions taken from Paul Johnston
*/
'use strict';(function(E){function t(e,a,c){var g=0,b=[],d=0,f,k,l,h,m,w,n,q=!1,r=!1,p=[],t=[],v,u=!1;c=c||{};f=c.encoding||"UTF8";v=c.numRounds||1;l=y(a,f);if(v!==parseInt(v,10)||1>v)throw Error("numRounds must a integer >= 1");if("SHA-1"===e)m=512,w=z,n=F,h=160;else throw Error("Chosen SHA variant is not supported");k=x(e);this.setHMACKey=function(a,b,d){var c;if(!0===r)throw Error("HMAC key already set");if(!0===q)throw Error("Cannot set HMAC key after finalizing hash");if(!0===u)throw Error("Cannot set HMAC key after calling update");
f=(d||{}).encoding||"UTF8";b=y(b,f)(a);a=b.binLen;b=b.value;c=m>>>3;d=c/4-1;if(c<a/8){for(b=n(b,a,0,x(e));b.length<=d;)b.push(0);b[d]&=4294967040}else if(c>a/8){for(;b.length<=d;)b.push(0);b[d]&=4294967040}for(a=0;a<=d;a+=1)p[a]=b[a]^909522486,t[a]=b[a]^1549556828;k=w(p,k);g=m;r=!0};this.update=function(a){var e,c,f,h=0,n=m>>>5;e=l(a,b,d);a=e.binLen;c=e.value;e=a>>>5;for(f=0;f<e;f+=n)h+m<=a&&(k=w(c.slice(f,f+n),k),h+=m);g+=h;b=c.slice(h>>>5);d=a%m;u=!0};this.getHash=function(a,c){var f,l,m;if(!0===
r)throw Error("Cannot call getHash after setting HMAC key");m=A(c);switch(a){case "HEX":f=function(a){return B(a,m)};break;case "B64":f=function(a){return C(a,m)};break;case "BYTES":f=D;break;default:throw Error("format must be HEX, B64, or BYTES");}if(!1===q)for(k=n(b,d,g,k),l=1;l<v;l+=1)k=n(k,h,0,x(e));q=!0;return f(k)};this.getHMAC=function(a,c){var f,l,p;if(!1===r)throw Error("Cannot call getHMAC without first setting HMAC key");p=A(c);switch(a){case "HEX":f=function(a){return B(a,p)};break;case "B64":f=
function(a){return C(a,p)};break;case "BYTES":f=D;break;default:throw Error("outputFormat must be HEX, B64, or BYTES");}!1===q&&(l=n(b,d,g,k),k=w(t,x(e)),k=n(l,h,m,k));q=!0;return f(k)}}function G(e,a,c){var g=e.length,b,d,f,k,l;a=a||[0];c=c||0;l=c>>>3;if(0!==g%2)throw Error("String of HEX type must be in byte increments");for(b=0;b<g;b+=2){d=parseInt(e.substr(b,2),16);if(isNaN(d))throw Error("String of HEX type contains invalid characters");k=(b>>>1)+l;for(f=k>>>2;a.length<=f;)a.push(0);a[f]|=d<<
8*(3-k%4)}return{value:a,binLen:4*g+c}}function H(e,a,c){var g=[],b,d,f,k,g=a||[0];c=c||0;d=c>>>3;for(b=0;b<e.length;b+=1)a=e.charCodeAt(b),k=b+d,f=k>>>2,g.length<=f&&g.push(0),g[f]|=a<<8*(3-k%4);return{value:g,binLen:8*e.length+c}}function I(e,a,c){var g=[],b=0,d,f,k,l,h,m,g=a||[0];c=c||0;a=c>>>3;if(-1===e.search(/^[a-zA-Z0-9=+\/]+$/))throw Error("Invalid character in base-64 string");f=e.indexOf("=");e=e.replace(/\=/g,"");if(-1!==f&&f<e.length)throw Error("Invalid '=' found in base-64 string");
for(f=0;f<e.length;f+=4){h=e.substr(f,4);for(k=l=0;k<h.length;k+=1)d="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(h[k]),l|=d<<18-6*k;for(k=0;k<h.length-1;k+=1){m=b+a;for(d=m>>>2;g.length<=d;)g.push(0);g[d]|=(l>>>16-8*k&255)<<8*(3-m%4);b+=1}}return{value:g,binLen:8*b+c}}function B(e,a){var c="",g=4*e.length,b,d;for(b=0;b<g;b+=1)d=e[b>>>2]>>>8*(3-b%4),c+="0123456789abcdef".charAt(d>>>4&15)+"0123456789abcdef".charAt(d&15);return a.outputUpper?c.toUpperCase():c}function C(e,
a){var c="",g=4*e.length,b,d,f;for(b=0;b<g;b+=3)for(f=b+1>>>2,d=e.length<=f?0:e[f],f=b+2>>>2,f=e.length<=f?0:e[f],f=(e[b>>>2]>>>8*(3-b%4)&255)<<16|(d>>>8*(3-(b+1)%4)&255)<<8|f>>>8*(3-(b+2)%4)&255,d=0;4>d;d+=1)8*b+6*d<=32*e.length?c+="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(f>>>6*(3-d)&63):c+=a.b64Pad;return c}function D(e){var a="",c=4*e.length,g,b;for(g=0;g<c;g+=1)b=e[g>>>2]>>>8*(3-g%4)&255,a+=String.fromCharCode(b);return a}function A(e){var a={outputUpper:!1,b64Pad:"="};
e=e||{};a.outputUpper=e.outputUpper||!1;!0===e.hasOwnProperty("b64Pad")&&(a.b64Pad=e.b64Pad);if("boolean"!==typeof a.outputUpper)throw Error("Invalid outputUpper formatting option");if("string"!==typeof a.b64Pad)throw Error("Invalid b64Pad formatting option");return a}function y(e,a){var c;switch(a){case "UTF8":case "UTF16BE":case "UTF16LE":break;default:throw Error("encoding must be UTF8, UTF16BE, or UTF16LE");}switch(e){case "HEX":c=G;break;case "TEXT":c=function(e,b,d){var f=[],c=[],l=0,h,m,p,
n,q,f=b||[0];b=d||0;p=b>>>3;if("UTF8"===a)for(h=0;h<e.length;h+=1)for(d=e.charCodeAt(h),c=[],128>d?c.push(d):2048>d?(c.push(192|d>>>6),c.push(128|d&63)):55296>d||57344<=d?c.push(224|d>>>12,128|d>>>6&63,128|d&63):(h+=1,d=65536+((d&1023)<<10|e.charCodeAt(h)&1023),c.push(240|d>>>18,128|d>>>12&63,128|d>>>6&63,128|d&63)),m=0;m<c.length;m+=1){q=l+p;for(n=q>>>2;f.length<=n;)f.push(0);f[n]|=c[m]<<8*(3-q%4);l+=1}else if("UTF16BE"===a||"UTF16LE"===a)for(h=0;h<e.length;h+=1){d=e.charCodeAt(h);"UTF16LE"===a&&
(m=d&255,d=m<<8|d>>>8);q=l+p;for(n=q>>>2;f.length<=n;)f.push(0);f[n]|=d<<8*(2-q%4);l+=2}return{value:f,binLen:8*l+b}};break;case "B64":c=I;break;case "BYTES":c=H;break;default:throw Error("format must be HEX, TEXT, B64, or BYTES");}return c}function r(e,a){return e<<a|e>>>32-a}function p(e,a){var c=(e&65535)+(a&65535);return((e>>>16)+(a>>>16)+(c>>>16)&65535)<<16|c&65535}function u(e,a,c,g,b){var d=(e&65535)+(a&65535)+(c&65535)+(g&65535)+(b&65535);return((e>>>16)+(a>>>16)+(c>>>16)+(g>>>16)+(b>>>16)+
(d>>>16)&65535)<<16|d&65535}function x(e){if("SHA-1"===e)e=[1732584193,4023233417,2562383102,271733878,3285377520];else throw Error("No SHA variants supported");return e}function z(e,a){var c=[],g,b,d,f,k,l,h;g=a[0];b=a[1];d=a[2];f=a[3];k=a[4];for(h=0;80>h;h+=1)c[h]=16>h?e[h]:r(c[h-3]^c[h-8]^c[h-14]^c[h-16],1),l=20>h?u(r(g,5),b&d^~b&f,k,1518500249,c[h]):40>h?u(r(g,5),b^d^f,k,1859775393,c[h]):60>h?u(r(g,5),b&d^b&f^d&f,k,2400959708,c[h]):u(r(g,5),b^d^f,k,3395469782,c[h]),k=f,f=d,d=r(b,30),b=g,g=l;a[0]=
p(g,a[0]);a[1]=p(b,a[1]);a[2]=p(d,a[2]);a[3]=p(f,a[3]);a[4]=p(k,a[4]);return a}function F(e,a,c,g){var b;for(b=(a+65>>>9<<4)+15;e.length<=b;)e.push(0);e[a>>>5]|=128<<24-a%32;e[b]=a+c;c=e.length;for(a=0;a<c;a+=16)g=z(e.slice(a,a+16),g);return g}"function"===typeof define&&define.amd?define(function(){return t}):"undefined"!==typeof exports?"undefined"!==typeof module&&module.exports?module.exports=exports=t:exports=t:E.jsSHA=t})(this);
}).call(jsSHA);
// End embedded sha1 implementation }}}

var exports = namespace;
/* 
 * Copyright (C) 2015 Kovid Goyal <kovid at kovidgoyal.net>
 *
 * Distributed under terms of the BSD license
 */

var vm = require('vm');
var native_require = require;

function normalize_array(parts, allowAboveRoot) {
  var res = [];
  for (var i = 0; i < parts.length; i++) {
    var p = parts[i];

    // ignore empty parts
    if (!p || p === '.')
      continue;

    if (p === '..') {
      if (res.length && res[res.length - 1] !== '..') {
        res.pop();
      } else if (allowAboveRoot) {
        res.push('..');
      }
    } else {
      res.push(p);
    }
  }

  return res;
}

function normalize(path) {
    var is_abs = path && path[0] === '/';
    var trailing_slash = path && path[path.length - 1] === '/';
    path = normalize_array(path.split('/'), !is_abs).join('/');

    if (!path && !is_abs) {
        path = '.';
    }
    if (path && trailing_slash) {
        path += '/';
    }

    return (is_abs ? '/' : '') + path;
}

function dirname(path) {
    var idx = path.lastIndexOf('/');
    if (idx != -1) path = path.slice(0, idx);
    else path = '';
    return path;
}

function basename(path) {
    var idx = path.lastIndexOf('/');
    if (idx != -1) path = path.slice(idx + 1);
    return path;
}

var cache = {};

function load(filepath) {
    var cached = cache[filepath];
    if (cached) return cached.exports;
    var module = {'id':filepath, 'exports':{}};
    cache[filepath] = module;

    var content = data[filepath];
    if (Array.isArray(content)) content = data[content[0]];
    if (!content) throw 'Failed to load: ' + JSON.stringify(filepath);

    if (filepath.slice(-5) == '.json') { module.exports = JSON.parse(content); return module.exports; }

    var base = dirname(filepath);
    function mrequire(x) {
        return vrequire(x, base);
    }
    content = content.replace(/^\#\!.*/, '');
    var wrapped = '(function(exports, require, module, __filename, __dirname, create_rapydscript_compiler) { ';
    wrapped += content + '\n;})';
    try {
        vm.runInThisContext(wrapped, {'filename': filepath})(module.exports, mrequire, module, filepath, dirname(filepath), create_compiler);
    } catch (e) {
        console.error(e);
        delete cache[filepath];
        throw e;
    }
    return module.exports;
}

function has(x, y) { return Object.prototype.hasOwnProperty.call(x, y); }

function try_files(candidate) {
    if (has(data, candidate)) return candidate;
    if (has(data, candidate + '.js')) return candidate + '.js';
    if (has(data, candidate + '.json')) return candidate + '.json';
    return null;
}

function find_in_modules_dir(name, base) {
    var candidate = normalize(base + (base ? '/':'') + 'node_modules/' + name);
    var q = try_files(candidate);
    if (q) return q;

    var pj = candidate + '/package.json';
    if (has(data, pj)) {
        var ans = normalize(candidate + '/' + JSON.parse(data[pj]).main);
        if (has(data, ans)) return ans;
    }
    var index = candidate + '/index.js';
    if (has(data, index)) return index;

    var p = dirname(base);
    if (p) return find_in_modules_dir(name, p);
    return null;
}

function find_module(name, base) {
    if (name[0] == '/') throw 'Cannot find absolute module: ' + name;
    if (name.slice(0, 2) == './' || name.slice(0, 3) == '../') {
        var candidate = normalize((base ? base + '/' : base) + name);
        return try_files(candidate);
    }
    var q = try_files(name);
    if (q) return q;
    return find_in_modules_dir(name, base);
}

function vrequire(name, base) {
    var exports = {};
    var modpath = '';
    base = base || '';
    // console.log('vrequire', name, base);
    if (!name) throw new Error('Cannot load a module from an empty name');

    modpath = find_module(name, base);
    if (!modpath && name && './'.indexOf(name[0]) === -1) {
            try {
                return native_require(name);
            } catch (e) {}
        }

    if (!modpath) throw new Error("Failed to find module: " + JSON.stringify(name) + " with base: " + JSON.stringify(base));
    return load(modpath);
}

var UglifyJS = null, regenerator = null;
var crypto = null, fs = require('fs');

function uglify(x) {
    if (!UglifyJS) UglifyJS = vrequire("uglify-js");
    return UglifyJS.minify(ans, {fromString:true}).code;
}

function regenerate(code, beautify) {
    var orig = fs.readFileSync;
    fs.readFileSync = function(name) { 
        if (!has(data, name)) {
            throw {message: "Failed to readfile from data: " + name};
        }
        return data[name]; 
    };
    if (!regenerator) regenerator = vrequire('regenerator');
    var ans;
    if (code) {
        try {
            ans = regenerator.compile(code).code;
        } catch (e) {
            console.error('regenerator failed for code: ' + code + 'with error stack:\n' + e.stack);
            throw e;
        }
        if (!beautify) ans = uglify(ans);
    } else {
        // Return the runtime
        ans = regenerator.compile('', {includeRuntime:true}).code;
        ans = ans.slice(ans.indexOf('!'), ans.lastIndexOf(')(')) + ')';
        if (!beautify) ans = uglify(ans+'();').slice(0, -3);
    }
    fs.readFileSync = orig;
    return ans;
}

if (typeof this != 'object' || typeof this.sha1sum !== 'function') {
    var sha1sum = function (data) { 
        if (!crypto) crypto = require('crypto');
        var h = crypto.createHash('sha1');
        h.update(data);
        return h.digest('hex');
    };
} else var sha1sum = this.sha1sum;

function create_compiler() {
    var compilerjs = data['compiler.js'];
    var module = {'id':'compiler', 'exports':{}};
    var wrapped = '(function(module, exports, readfile, writefile, sha1sum, regenerate) {' + data['compiler.js'] + ';\n})';
    vm.runInThisContext(wrapped, {'filename': 'compiler.js'})(module, module.exports, fs.readFileSync, fs.writeFileSync, sha1sum, regenerate);
    return module.exports;
}

var RapydScript = null;

function compile(code, filename, options) {
    if (!RapydScript) RapydScript = create_compiler();
    options = options || {};
    var ast = RapydScript.parse(code, {
        filename: filename || '<eval>',
        basedir: options.basedir || dirname(filename || ''),
        libdir: options.libdir,
    });
    var out_ops = {
        beautify: (options.beautify === undefined ? true : options.beautify),
        private_scope: !options.bare,
        omit_baselib: !!options.omit_baselib,
        js_version: options.js_version || 5,
    };
    if (!out_ops.omit_baselib) out_ops.baselib_plain = data['baselib-plain-' + (out_ops.beautify ? 'pretty' : 'ugly') + '.js'];
    var out = new RapydScript.OutputStream(out_ops);
    ast.print(out);
    return out.get();
}

function create_embedded_compiler(runjs) {
    var c = vrequire('tools/embedded_compiler.js');
    return c(create_compiler(), data['baselib-plain-pretty.js'], runjs);
}

function web_repl() {
    var repl = vrequire('tools/web_repl.js');
    return repl(create_compiler(), data['baselib-plain-pretty.js']);
}

function init_repl(options) {
    var repl = vrequire('tools/repl.js');
    options.baselib = data['baselib-plain-pretty.js'];
    return repl(options);
}

function gettext_parse(catalog, code, filename) {
    g = vrequire('tools/gettext.js');
    g.gettext(catalog, code, filename);
}

function gettext_output(catalog, options, write) {
    g = vrequire('tools/gettext.js');
    g.write_output(catalog, options, write);
}

function msgfmt(data, options) {
    m = vrequire('tools/msgfmt.js');
    return m.build(data, options);
}

function completer(compiler, options) {
    m = vrequire('tools/completer.js');
    return m(compiler, options);
}

if (typeof exports === 'object') {
    exports.compile = compile;
    exports.create_embedded_compiler = create_embedded_compiler;
    exports.web_repl = web_repl;
    exports.init_repl = init_repl;
    exports.gettext_parse = gettext_parse;
    exports.gettext_output = gettext_output;
    exports.msgfmt = msgfmt;
    exports.rs_version = rs_version;
    exports.file_data = data;
    exports.completer = completer;
    if (typeof rs_commit_sha === 'string') exports.rs_commit_sha = rs_commit_sha;
}
external_namespace.RapydScript = namespace;
})(this)
